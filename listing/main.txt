; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\MEDIA_USB_KEY\main.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\MEDIA_USB_KEY\main.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\MEDIA_USB_KEY\main.crf src\main.c]
                          THUMB

                          AREA ||i.ADC3_CH12_DMA_Config||, CODE, READONLY, ALIGN=2

                  ADC3_CH12_DMA_Config PROC
;;;137    
;;;138    void ADC3_CH12_DMA_Config(void)
000000  b570              PUSH     {r4-r6,lr}
;;;139    {
000002  b09c              SUB      sp,sp,#0x70
;;;140      ADC_InitTypeDef       ADC_InitStructure;
;;;141      ADC_CommonInitTypeDef ADC_CommonInitStructure;
;;;142      DMA_InitTypeDef       DMA_InitStructure;
;;;143      GPIO_InitTypeDef      GPIO_InitStructure;
;;;144    
;;;145      // Enable ADC3, DMA2 and GPIO clocks **************************************
;;;146      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2 | RCC_AHB1Periph_GPIOC, ENABLE);
000004  2101              MOVS     r1,#1
000006  482e              LDR      r0,|L1.192|
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;147      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0288              LSLS     r0,r1,#10
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;148    
;;;149      // DMA2 Stream0 channel0 configuration ************************************
;;;150      DMA_InitStructure.DMA_Channel = DMA_Channel_2;  
000014  f04f6080          MOV      r0,#0x4000000
;;;151      DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC3_DR_ADDRESS;
000018  9000              STR      r0,[sp,#0]
00001a  482a              LDR      r0,|L1.196|
;;;152      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&ADC3ConvertedValue;
00001c  9001              STR      r0,[sp,#4]
00001e  482a              LDR      r0,|L1.200|
;;;153      DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
;;;154      DMA_InitStructure.DMA_BufferSize = 1;
000020  a902              ADD      r1,sp,#8
000022  2400              MOVS     r4,#0                 ;153
000024  2501              MOVS     r5,#1
000026  c131              STM      r1!,{r0,r4,r5}
;;;155      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
;;;156      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;
;;;157      DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
000028  02e8              LSLS     r0,r5,#11
00002a  e9cd4006          STRD     r4,r0,[sp,#0x18]
;;;158      DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
00002e  0080              LSLS     r0,r0,#2
;;;159      DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
000030  9008              STR      r0,[sp,#0x20]
000032  1140              ASRS     r0,r0,#5
;;;160      DMA_InitStructure.DMA_Priority = DMA_Priority_High;
000034  9009              STR      r0,[sp,#0x24]
000036  a90a              ADD      r1,sp,#0x28
000038  9405              STR      r4,[sp,#0x14]         ;157
00003a  0240              LSLS     r0,r0,#9
00003c  c131              STM      r1!,{r0,r4,r5}
;;;161      DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;         
;;;162      DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
;;;163      DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
;;;164      DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
;;;165      DMA_Init(DMA2_Stream0, &DMA_InitStructure);
00003e  4e23              LDR      r6,|L1.204|
000040  940d              STR      r4,[sp,#0x34]         ;164
000042  4669              MOV      r1,sp
000044  4630              MOV      r0,r6
000046  940e              STR      r4,[sp,#0x38]
000048  f7fffffe          BL       DMA_Init
;;;166      DMA_Cmd(DMA2_Stream0, ENABLE);
00004c  2101              MOVS     r1,#1
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       DMA_Cmd
;;;167    
;;;168     // Configure ADC3 Channel12 pin as analog input ****************************
;;;169      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000054  2004              MOVS     r0,#4
;;;170      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
000056  9019              STR      r0,[sp,#0x64]
000058  2003              MOVS     r0,#3
00005a  f88d0068          STRB     r0,[sp,#0x68]
;;;171      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
00005e  f88d406b          STRB     r4,[sp,#0x6b]
;;;172      GPIO_Init(GPIOC, &GPIO_InitStructure);
000062  a919              ADD      r1,sp,#0x64
000064  481a              LDR      r0,|L1.208|
000066  f7fffffe          BL       GPIO_Init
;;;173    
;;;174      // ADC Common Init *********************************************************
;;;175      ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
;;;176      ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
00006a  9415              STR      r4,[sp,#0x54]
;;;177      ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
00006c  9416              STR      r4,[sp,#0x58]
;;;178      ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
00006e  9417              STR      r4,[sp,#0x5c]
;;;179      ADC_CommonInit(&ADC_CommonInitStructure);
000070  a815              ADD      r0,sp,#0x54
000072  9418              STR      r4,[sp,#0x60]
000074  f7fffffe          BL       ADC_CommonInit
;;;180    
;;;181     // ADC3 Init ***************************************************************
;;;182      ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
;;;183      ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000078  940f              STR      r4,[sp,#0x3c]
00007a  f88d4040          STRB     r4,[sp,#0x40]
;;;184      ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
;;;185      ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
;;;186      ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
00007e  9411              STR      r4,[sp,#0x44]
;;;187      ADC_InitStructure.ADC_NbrOfConversion = 1;
000080  9413              STR      r4,[sp,#0x4c]
;;;188      ADC_Init(ADC3, &ADC_InitStructure);
000082  4c10              LDR      r4,|L1.196|
000084  f88d5041          STRB     r5,[sp,#0x41]         ;184
000088  3c4c              SUBS     r4,r4,#0x4c
00008a  f88d5050          STRB     r5,[sp,#0x50]         ;187
00008e  a90f              ADD      r1,sp,#0x3c
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       ADC_Init
;;;189    
;;;190      // ADC3 regular channel12 configuration ***********************************
;;;191      ADC_RegularChannelConfig(ADC3, ADC_Channel_12, 1, ADC_SampleTime_3Cycles);
000096  2300              MOVS     r3,#0
000098  2201              MOVS     r2,#1
00009a  210c              MOVS     r1,#0xc
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       ADC_RegularChannelConfig
;;;192    
;;;193     // Enable DMA request after last transfer (Single-ADC mode)
;;;194      ADC_DMARequestAfterLastTransferCmd(ADC3, ENABLE);
0000a2  2101              MOVS     r1,#1
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       ADC_DMARequestAfterLastTransferCmd
;;;195    
;;;196      // Enable ADC3 DMA 
;;;197      ADC_DMACmd(ADC3, ENABLE);
0000aa  2101              MOVS     r1,#1
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       ADC_DMACmd
;;;198    
;;;199      // Enable ADC3 
;;;200      ADC_Cmd(ADC3, ENABLE);
0000b2  2101              MOVS     r1,#1
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       ADC_Cmd
;;;201    }
0000ba  b01c              ADD      sp,sp,#0x70
0000bc  bd70              POP      {r4-r6,pc}
;;;202    
                          ENDP

0000be  0000              DCW      0x0000
                  |L1.192|
                          DCD      0x00400004
                  |L1.196|
                          DCD      0x4001224c
                  |L1.200|
                          DCD      ||area_number.34||+0x6
                  |L1.204|
                          DCD      0x40026410
                  |L1.208|
                          DCD      0x40020800

                          AREA ||i.TIM_LED_Config||, CODE, READONLY, ALIGN=2

                  TIM_LED_Config PROC
;;;1639     */
;;;1640   static void TIM_LED_Config(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1641   {
000002  b08a              SUB      sp,sp,#0x28
;;;1642     TIM_OCInitTypeDef  TIM_OCInitStructure;
;;;1643     TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;1644     NVIC_InitTypeDef NVIC_InitStructure;
;;;1645     uint16_t prescalervalue = 0;
;;;1646     
;;;1647     /* TIM4 clock enable */
;;;1648     RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;1649     
;;;1650     NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
00000c  f44f60a0          MOV      r0,#0x500
000010  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;1651     
;;;1652     /* Enable the TIM3 gloabal Interrupt */
;;;1653     NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;
000014  201e              MOVS     r0,#0x1e
000016  f88d0020          STRB     r0,[sp,#0x20]
;;;1654     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00001a  2400              MOVS     r4,#0
00001c  f88d4021          STRB     r4,[sp,#0x21]
;;;1655     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000020  f88d4022          STRB     r4,[sp,#0x22]
;;;1656     NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000024  2501              MOVS     r5,#1
000026  f88d5023          STRB     r5,[sp,#0x23]
;;;1657     NVIC_Init(&NVIC_InitStructure);
00002a  a808              ADD      r0,sp,#0x20
00002c  f7fffffe          BL       NVIC_Init
;;;1658   
;;;1659     /* Initialize Leds mounted on STM324F4-EVAL board */
;;;1660     STM_EVAL_LEDInit(LED3);
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       STM_EVAL_LEDInit
;;;1661     STM_EVAL_LEDInit(LED4);
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       STM_EVAL_LEDInit
;;;1662     STM_EVAL_LEDInit(LED6);
00003c  2003              MOVS     r0,#3
00003e  f7fffffe          BL       STM_EVAL_LEDInit
;;;1663     
;;;1664     /* Compute the prescaler value */
;;;1665     prescalervalue = (uint16_t) ((SystemCoreClock ) / 550000) - 1;
000042  481a              LDR      r0,|L2.172|
000044  491a              LDR      r1,|L2.176|
;;;1666     
;;;1667     /* Time base configuration */
;;;1668     TIM_TimeBaseStructure.TIM_Period = 65535;
;;;1669     TIM_TimeBaseStructure.TIM_Prescaler = prescalervalue;
;;;1670     TIM_TimeBaseStructure.TIM_ClockDivision = 0;
;;;1671     TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
;;;1672     TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
000046  4e1b              LDR      r6,|L2.180|
000048  6800              LDR      r0,[r0,#0]            ;1665  ; SystemCoreClock
00004a  f8ad401c          STRH     r4,[sp,#0x1c]         ;1670
00004e  fbb0f0f1          UDIV     r0,r0,r1              ;1665
000052  1e40              SUBS     r0,r0,#1              ;1665
000054  f64f71ff          MOV      r1,#0xffff            ;1668
000058  f8ad0014          STRH     r0,[sp,#0x14]         ;1669
00005c  9106              STR      r1,[sp,#0x18]         ;1669
00005e  f8ad4016          STRH     r4,[sp,#0x16]         ;1671
000062  a905              ADD      r1,sp,#0x14
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       TIM_TimeBaseInit
;;;1673     
;;;1674     /* Enable TIM4 Preload register on ARR */
;;;1675     TIM_ARRPreloadConfig(TIM4, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  4630              MOV      r0,r6
00006e  f7fffffe          BL       TIM_ARRPreloadConfig
;;;1676     
;;;1677     /* TIM PWM1 Mode configuration: Channel */
;;;1678     TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Timing;
;;;1679     TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
;;;1680     TIM_OCInitStructure.TIM_Pulse = CCR_Val;
000072  4811              LDR      r0,|L2.184|
000074  f8ad4000          STRH     r4,[sp,#0]            ;1678
000078  f8ad5002          STRH     r5,[sp,#2]            ;1679
00007c  8880              LDRH     r0,[r0,#4]  ; CCR_Val
;;;1681     TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
00007e  9002              STR      r0,[sp,#8]
000080  f8ad400c          STRH     r4,[sp,#0xc]
;;;1682     
;;;1683     /* Output Compare PWM1 Mode configuration: Channel2 */
;;;1684     TIM_OC1Init(TIM4, &TIM_OCInitStructure);
000084  4669              MOV      r1,sp
000086  4630              MOV      r0,r6
000088  f7fffffe          BL       TIM_OC1Init
;;;1685     TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Disable);
00008c  2100              MOVS     r1,#0
00008e  4630              MOV      r0,r6
000090  f7fffffe          BL       TIM_OC1PreloadConfig
;;;1686       
;;;1687     /* TIM Interrupts enable */
;;;1688     TIM_ITConfig(TIM4, TIM_IT_CC1 , ENABLE);
000094  2201              MOVS     r2,#1
000096  2102              MOVS     r1,#2
000098  4630              MOV      r0,r6
00009a  f7fffffe          BL       TIM_ITConfig
;;;1689     
;;;1690     /* TIM4 enable counter */
;;;1691     TIM_Cmd(TIM4, ENABLE);
00009e  2101              MOVS     r1,#1
0000a0  4630              MOV      r0,r6
0000a2  f7fffffe          BL       TIM_Cmd
;;;1692   }
0000a6  b00a              ADD      sp,sp,#0x28
0000a8  bd70              POP      {r4-r6,pc}
;;;1693   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L2.172|
                          DCD      SystemCoreClock
                  |L2.176|
                          DCD      0x00086470
                  |L2.180|
                          DCD      0x40000800
                  |L2.184|
                          DCD      ||area_number.34||

                          AREA ||i.UART2Init||, CODE, READONLY, ALIGN=2

                  UART2Init PROC
;;;203    
;;;204    void UART2Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;205    {
;;;206    
;;;207       GPIO_InitTypeDef GPIO_InitStructure;
;;;208       USART_InitTypeDef USART_InitStructure;
;;;209    
;;;210       RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);    	// 1.
000002  2101              MOVS     r1,#1
000004  b086              SUB      sp,sp,#0x18           ;205
000006  0448              LSLS     r0,r1,#17
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;211       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD,ENABLE); 			// 2.
00000c  2101              MOVS     r1,#1
00000e  2008              MOVS     r0,#8
000010  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;212    
;;;213       GPIO_PinAFConfig  ( GPIOD, GPIO_PinSource5 , GPIO_AF_USART2) ;
000014  4e1c              LDR      r6,|L3.136|
000016  2207              MOVS     r2,#7
000018  2105              MOVS     r1,#5
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       GPIO_PinAFConfig
;;;214       GPIO_PinAFConfig  ( GPIOD, GPIO_PinSource6 , GPIO_AF_USART2) ;   
000020  2207              MOVS     r2,#7
000022  2106              MOVS     r1,#6
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       GPIO_PinAFConfig
;;;215       // 
;;;216       //     //  Tx
;;;217         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
;;;218         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; // alternate function!
00002a  2502              MOVS     r5,#2
00002c  2020              MOVS     r0,#0x20              ;217
00002e  f88d5004          STRB     r5,[sp,#4]
;;;219       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP ;
000032  2400              MOVS     r4,#0
000034  9000              STR      r0,[sp,#0]            ;218
000036  f88d4006          STRB     r4,[sp,#6]
;;;220         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003a  f88d5005          STRB     r5,[sp,#5]
;;;221         GPIO_Init(GPIOD, &GPIO_InitStructure);
00003e  4669              MOV      r1,sp
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       GPIO_Init
;;;222       ////
;;;223    
;;;224       //     // Rx
;;;225         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
000046  2040              MOVS     r0,#0x40
;;;226         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; //GPIO_Mode_IN;
000048  9000              STR      r0,[sp,#0]
00004a  f88d5004          STRB     r5,[sp,#4]
;;;227         GPIO_Init(GPIOD, &GPIO_InitStructure);
00004e  4669              MOV      r1,sp
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       GPIO_Init
;;;228       //
;;;229         USART_InitStructure.USART_BaudRate = 9600;
000056  f44f5016          MOV      r0,#0x2580
;;;230         USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00005a  f8ad400c          STRH     r4,[sp,#0xc]
00005e  9002              STR      r0,[sp,#8]
;;;231         USART_InitStructure.USART_StopBits = USART_StopBits_1;
000060  f8ad400e          STRH     r4,[sp,#0xe]
;;;232         USART_InitStructure.USART_Parity = USART_Parity_No;
000064  f8ad4010          STRH     r4,[sp,#0x10]
;;;233         USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000068  f8ad4014          STRH     r4,[sp,#0x14]
;;;234         USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00006c  200c              MOVS     r0,#0xc
;;;235    
;;;236       USART_Init(USART2, &USART_InitStructure);
00006e  4c07              LDR      r4,|L3.140|
000070  f8ad0012          STRH     r0,[sp,#0x12]         ;234
000074  a902              ADD      r1,sp,#8
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       USART_Init
;;;237    	 
;;;238    	 // enable interrupt on sended data
;;;239    	//	USART_ITConfig(USART2, USART_IT_TC, ENABLE);
;;;240    		// enable interrupt on received data
;;;241    //	  USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//?????????? ?????????? ?? ?????
;;;242    
;;;243    //RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;   //???????????? GPIO
;;;244    //RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;   //???????????? ?????????????? ??????? GPIO
;;;245    //RCC->APB2ENR |= RCC_APB2ENR_USART1EN; //???????????? ?????? USART1
;;;246    
;;;247       USART_Cmd(USART2, ENABLE); // enable USART2
00007c  2101              MOVS     r1,#1
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       USART_Cmd
;;;248    
;;;249    }
000084  b006              ADD      sp,sp,#0x18
000086  bd70              POP      {r4-r6,pc}
;;;250    
                          ENDP

                  |L3.136|
                          DCD      0x40020c00
                  |L3.140|
                          DCD      0x40004400

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;71     
;;;72     void USART2_IRQHandler(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;73     { 
;;;74     
;;;75         	
;;;76     				if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)		  // приняли
000004  4d27              LDR      r5,|L4.164|
000006  f2405825          MOV      r8,#0x525
00000a  4641              MOV      r1,r8
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       USART_GetITStatus
;;;77     					{		u8 tmp=0;
;;;78     						USART_ClearITPendingBit(USART2, USART_IT_RXNE);
;;;79     				
;;;80     						tmp=USART_ReceiveData (USART2);
;;;81     						if (tmp==0x3A)
;;;82     								tekpr=0;
000012  4c25              LDR      r4,|L4.168|
000014  2600              MOVS     r6,#0                 ;76
000016  b1b8              CBZ      r0,|L4.72|
000018  4641              MOV      r1,r8                 ;78
00001a  4628              MOV      r0,r5                 ;78
00001c  f7fffffe          BL       USART_ClearITPendingBit
000020  4628              MOV      r0,r5                 ;80
000022  f7fffffe          BL       USART_ReceiveData
000026  b2c1              UXTB     r1,r0                 ;80
000028  293a              CMP      r1,#0x3a              ;81
00002a  d002              BEQ      |L4.50|
;;;83     	/*
;;;84     						if (tekpr==1)
;;;85     								if (tmp!=address)
;;;86     								{
;;;87     									tekpr=0;
;;;88     									rxsize=0;
;;;89     								}
;;;90     		*/				
;;;91     						if (tmp==0x0D)
00002c  290d              CMP      r1,#0xd
00002e  d002              BEQ      |L4.54|
000030  e005              B        |L4.62|
                  |L4.50|
000032  81e6              STRH     r6,[r4,#0xe]          ;82
000034  e003              B        |L4.62|
                  |L4.54|
;;;92     						{
;;;93     							rxsize=tekpr;
000036  89e0              LDRH     r0,[r4,#0xe]  ; tekpr
000038  8160              STRH     r0,[r4,#0xa]
;;;94     				//			USART_ITConfig(USART2, USART_IT_RXNE, DISABLE);
;;;95     							new_komand=1;
00003a  2001              MOVS     r0,#1
00003c  70a0              STRB     r0,[r4,#2]
                  |L4.62|
;;;96     						}
;;;97     						RxBuffer[tekpr]=tmp;
00003e  4a1b              LDR      r2,|L4.172|
000040  89e0              LDRH     r0,[r4,#0xe]  ; tekpr
000042  5411              STRB     r1,[r2,r0]
;;;98     						tekpr++;
000044  1c40              ADDS     r0,r0,#1
000046  81e0              STRH     r0,[r4,#0xe]
                  |L4.72|
;;;99     				//		GPIOD->ODR ^= tx_pin_en;
;;;100    				//		GPIOD->ODR ^= rx_pin_en;
;;;101    						
;;;102    
;;;103    					}
;;;104    //Transmission complete interrupt								 // чтото передали
;;;105            if(USART_GetITStatus(USART2, USART_IT_TC) != RESET)
000048  f2406726          MOV      r7,#0x626
00004c  4639              MOV      r1,r7
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       USART_GetITStatus
000054  2800              CMP      r0,#0
000056  d023              BEQ      |L4.160|
;;;106            {
;;;107    		
;;;108    					USART_ClearITPendingBit(USART2, USART_IT_TC);//очищаем признак прерывания
000058  4639              MOV      r1,r7
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       USART_ClearITPendingBit
;;;109    					
;;;110    					if (txsize>tekper)
000060  8920              LDRH     r0,[r4,#8]  ; txsize
000062  89a1              LDRH     r1,[r4,#0xc]  ; tekper
000064  4288              CMP      r0,r1
000066  d902              BLS      |L4.110|
;;;111    						USART_SendData(USART2,TxBuffer[tekper]);
000068  4811              LDR      r0,|L4.176|
00006a  5c41              LDRB     r1,[r0,r1]
00006c  e002              B        |L4.116|
                  |L4.110|
;;;112    					else
;;;113    					{
;;;114    						if (txsize==tekper)
00006e  d105              BNE      |L4.124|
;;;115    								USART_SendData(USART2, 0x0D);
000070  f04f010d          MOV      r1,#0xd
                  |L4.116|
000074  4628              MOV      r0,r5
000076  f7fffffe          BL       USART_SendData
00007a  e009              B        |L4.144|
                  |L4.124|
;;;116    						else
;;;117    						{
;;;118    							GPIO_WriteBit(GPIOD, rx_pin_en, Bit_RESET); 
00007c  2200              MOVS     r2,#0
00007e  2108              MOVS     r1,#8
000080  480c              LDR      r0,|L4.180|
000082  f7fffffe          BL       GPIO_WriteBit
;;;119    							USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
000086  2201              MOVS     r2,#1
000088  4641              MOV      r1,r8
00008a  4628              MOV      r0,r5
00008c  f7fffffe          BL       USART_ITConfig
                  |L4.144|
;;;120    						}
;;;121    						//
;;;122    //						GPIOD->ODR ^= tx_pin_en;
;;;123    		//					GPIOD->ODR ^= rx_pin_en;
;;;124    					}
;;;125    					if (tekper>TxBufferSize-1)
000090  89a0              LDRH     r0,[r4,#0xc]  ; tekper
000092  f5b07ffa          CMP      r0,#0x1f4
000096  d300              BCC      |L4.154|
;;;126    						tekper=0;
000098  81a6              STRH     r6,[r4,#0xc]
                  |L4.154|
;;;127    					tekper++;
00009a  89a0              LDRH     r0,[r4,#0xc]  ; tekper
00009c  1c40              ADDS     r0,r0,#1
00009e  81a0              STRH     r0,[r4,#0xc]
                  |L4.160|
;;;128    					
;;;129    			 
;;;130    					//					GPIOA->BSRR=GPIO_BSRR_BR11|GPIO_BSRR_BR12; // настроиться на прием
;;;131            }
;;;132    
;;;133    
;;;134    
;;;135    }
0000a0  e8bd81f0          POP      {r4-r8,pc}
;;;136    
                          ENDP

                  |L4.164|
                          DCD      0x40004400
                  |L4.168|
                          DCD      ||area_number.34||
                  |L4.172|
                          DCD      ||.bss||+0x544
                  |L4.176|
                          DCD      ||.bss||+0x738
                  |L4.180|
                          DCD      0x40020c00

                          AREA ||i.delay_spi||, CODE, READONLY, ALIGN=1

                  delay_spi PROC
;;;467    
;;;468    void delay_spi(u32 kol)
000000  2100              MOVS     r1,#0
;;;469    {
000002  e001              B        |L5.8|
                  |L5.4|
;;;470    	u32 i=0;
;;;471    
;;;472    
;;;473    	for (i=0;i<kol;i++)
;;;474    				__ASM volatile ("nop");
000004  bf00              NOP      
000006  1c49              ADDS     r1,r1,#1              ;473
                  |L5.8|
000008  4281              CMP      r1,r0                 ;473
00000a  d3fb              BCC      |L5.4|
;;;475    }
00000c  4770              BX       lr
;;;476    
                          ENDP


                          AREA ||i.indicate||, CODE, READONLY, ALIGN=2

                  indicate PROC
;;;1195   
;;;1196   void indicate(u8 numb_ind,u16 chislo_new)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1197   {
000004  460a              MOV      r2,r1
000006  4604              MOV      r4,r0
;;;1198   		 	uint16_t  pin=0;
;;;1199   			u16 chislo=chislo_new; //indicators[numb_ind].chislo;
;;;1200   			u8 i=0, zn[6], null=1, simb=0;
000008  f04f0801          MOV      r8,#1
;;;1201   			u32   maximum=0;
;;;1202   			
;;;1203   
;;;1204   			/*
;;;1205   			switch (numb_ind)
;;;1206   			{
;;;1207   				case 0x00:  // CS0
;;;1208   					pin=GPIO_Pin_0;
;;;1209   					break;
;;;1210   
;;;1211   				case 0x01:  // CS1
;;;1212   					pin=GPIO_Pin_1;
;;;1213   					break;
;;;1214   
;;;1215   				case 0x02:  // CS2
;;;1216   					pin=GPIO_Pin_2;
;;;1217   					break;
;;;1218   
;;;1219   				case 0x03:  // CS3
;;;1220   					pin=GPIO_Pin_3;
;;;1221   					break;
;;;1222   
;;;1223   				case 0x04:  // CS4
;;;1224   					pin=GPIO_Pin_4;
;;;1225   					break;								
;;;1226   			}
;;;1227   			*/
;;;1228   			pin=pin_ind(numb_ind);
00000c  f7fffffe          BL       pin_ind
000010  ea5f0b00          MOVS     r11,r0
;;;1229   		if (pin==0)
000014  d063              BEQ      |L6.222|
;;;1230   				return ;
;;;1231   		
;;;1232   			switch (conf.indicators[numb_ind-1].kol_cifr)
000016  485a              LDR      r0,|L6.384|
000018  eb040144          ADD      r1,r4,r4,LSL #1
00001c  eb000581          ADD      r5,r0,r1,LSL #2
;;;1233   			{
;;;1234   				case 0x00:  // CS0
;;;1235   					return;
;;;1236   					break;
;;;1237   				case 0x01:  // CS0
;;;1238   					maximum=10;
;;;1239   					break;			
;;;1240   				case 0x02:  // CS0
;;;1241   					maximum=100;
;;;1242   					break;
;;;1243   				case 0x03:  // CS0
;;;1244   					maximum=1000;
;;;1245   					break;
;;;1246   				case 0x04:  // CS0
;;;1247   					maximum=10000;
;;;1248   					break;
;;;1249   				case 0x05:  // CS0
;;;1250   					maximum=100000;
;;;1251   					break;	
;;;1252   				case 0x06:  // CS0
;;;1253   					maximum=1000000;
;;;1254   					break;	
;;;1255   				case 0x07:  // CS0
;;;1256   					maximum=10000000;
;;;1257   					break;	
;;;1258   				case 0x08:  // CS0
;;;1259   					maximum=100000000;
000020  4858              LDR      r0,|L6.388|
000022  7a69              LDRB     r1,[r5,#9]            ;1232
000024  2908              CMP      r1,#8                 ;1232
000026  d214              BCS      |L6.82|
000028  e8dff001          TBB      [pc,r1]               ;1232
00002c  59040608          DCB      0x59,0x04,0x06,0x08
000030  0b0e1012          DCB      0x0b,0x0e,0x10,0x12
000034  200a              MOVS     r0,#0xa               ;1238
000036  e00c              B        |L6.82|
000038  2064              MOVS     r0,#0x64              ;1241
00003a  e00a              B        |L6.82|
00003c  f44f707a          MOV      r0,#0x3e8             ;1244
000040  e007              B        |L6.82|
000042  f2427010          MOV      r0,#0x2710            ;1247
000046  e004              B        |L6.82|
000048  484f              LDR      r0,|L6.392|
00004a  e002              B        |L6.82|
00004c  484f              LDR      r0,|L6.396|
00004e  e000              B        |L6.82|
000050  484f              LDR      r0,|L6.400|
                  |L6.82|
;;;1260   					break;					
;;;1261   				default:  // CS0
;;;1262   					maximum=100000000;
;;;1263   					break;					
;;;1264   			}
;;;1265   	
;;;1266   			if (chislo>=maximum)   // reflow
;;;1267   			{			
;;;1268   				GPIO_WriteBit(GPIOA, pin, Bit_RESET);      
000052  f8df9140          LDR      r9,|L6.404|
;;;1269   				delay_spi(zad_spi);
000056  4e50              LDR      r6,|L6.408|
000058  4282              CMP      r2,r0                 ;1266
00005a  d342              BCC      |L6.226|
00005c  2200              MOVS     r2,#0                 ;1268
00005e  4659              MOV      r1,r11                ;1268
000060  464f              MOV      r7,r9                 ;1268
000062  4648              MOV      r0,r9                 ;1268
000064  f7fffffe          BL       GPIO_WriteBit
000068  6970              LDR      r0,[r6,#0x14]  ; zad_spi
00006a  f7fffffe          BL       delay_spi
;;;1270   				spi_send(1);delay_spi(zad_spi);
00006e  2001              MOVS     r0,#1
000070  f7fffffe          BL       spi_send
000074  6970              LDR      r0,[r6,#0x14]  ; zad_spi
000076  f7fffffe          BL       delay_spi
;;;1271   				spi_send(0x4F); delay_spi(zad_spi);		
00007a  204f              MOVS     r0,#0x4f
00007c  f7fffffe          BL       spi_send
000080  6970              LDR      r0,[r6,#0x14]  ; zad_spi
000082  f7fffffe          BL       delay_spi
;;;1272   				GPIO_WriteBit(GPIOA, pin, Bit_SET);      
000086  2201              MOVS     r2,#1
000088  4659              MOV      r1,r11
00008a  4638              MOV      r0,r7
00008c  f7fffffe          BL       GPIO_WriteBit
;;;1273   			  delay_spi(zad_spi2);	
000090  69b0              LDR      r0,[r6,#0x18]  ; zad_spi2
000092  f7fffffe          BL       delay_spi
;;;1274   				
;;;1275   				for (i=2;i<conf.indicators[numb_ind-1].kol_cifr+1;i++)  {
000096  2402              MOVS     r4,#2
000098  e01d              B        |L6.214|
                  |L6.154|
;;;1276   				GPIO_WriteBit(GPIOA, pin, Bit_RESET);      
00009a  2200              MOVS     r2,#0
00009c  4659              MOV      r1,r11
00009e  4638              MOV      r0,r7
0000a0  f7fffffe          BL       GPIO_WriteBit
;;;1277   				delay_spi(zad_spi);
0000a4  6970              LDR      r0,[r6,#0x14]  ; zad_spi
0000a6  f7fffffe          BL       delay_spi
;;;1278   				spi_send((u8) i);delay_spi(zad_spi);
0000aa  4620              MOV      r0,r4
0000ac  f7fffffe          BL       spi_send
0000b0  6970              LDR      r0,[r6,#0x14]  ; zad_spi
0000b2  f7fffffe          BL       delay_spi
;;;1279   				spi_send(0); delay_spi(zad_spi);		
0000b6  2000              MOVS     r0,#0
0000b8  f7fffffe          BL       spi_send
0000bc  6970              LDR      r0,[r6,#0x14]  ; zad_spi
0000be  f7fffffe          BL       delay_spi
;;;1280   				GPIO_WriteBit(GPIOA, pin, Bit_SET);      
0000c2  2201              MOVS     r2,#1
0000c4  4659              MOV      r1,r11
0000c6  4638              MOV      r0,r7
0000c8  f7fffffe          BL       GPIO_WriteBit
;;;1281   			  delay_spi(zad_spi2);			}					
0000cc  69b0              LDR      r0,[r6,#0x18]  ; zad_spi2
0000ce  f7fffffe          BL       delay_spi
0000d2  1c64              ADDS     r4,r4,#1              ;1275
0000d4  b2e4              UXTB     r4,r4                 ;1275
                  |L6.214|
0000d6  7a68              LDRB     r0,[r5,#9]            ;1275
0000d8  1c40              ADDS     r0,r0,#1              ;1275
0000da  42a0              CMP      r0,r4                 ;1275
0000dc  d8dd              BHI      |L6.154|
                  |L6.222|
;;;1282   				return ;
;;;1283   			}	
;;;1284   
;;;1285   			for (i=conf.indicators[numb_ind-1].kol_cifr;i>0;i--)
;;;1286   			{	
;;;1287   					zn[i]=(u8) (chislo%10);
;;;1288   					chislo=chislo/10;
;;;1289   			}
;;;1290   
;;;1291   			for (i=1;i<conf.indicators[numb_ind-1].kol_cifr+1;i++)
;;;1292   			{	
;;;1293   						simb=symb_code[zn[i]];
;;;1294   				
;;;1295   						if ((conf.indicators[numb_ind-1].kol_cifr-i)==conf.indicators[numb_ind-1].pol_zap)
;;;1296   							simb+=0x80;
;;;1297   				
;;;1298   						if ((simb==0x7E)&(null))
;;;1299   							simb=0;
;;;1300   						else
;;;1301   							null=0;
;;;1302   						
;;;1303   						if (i==conf.indicators[numb_ind-1].kol_cifr)
;;;1304   							simb&=0x7F;
;;;1305   	
;;;1306   						GPIO_WriteBit(GPIOA, pin, Bit_RESET);     	delay_spi(zad_spi);
;;;1307   						spi_send((u8) i);delay_spi(zad_spi);
;;;1308   						spi_send(simb); delay_spi(zad_spi);			
;;;1309   						GPIO_WriteBit(GPIOA, pin, Bit_SET);    			delay_spi(zad_spi2);				
;;;1310   			}
;;;1311   }
0000de  e8bd9ffc          POP      {r2-r12,pc}
                  |L6.226|
0000e2  200a              MOVS     r0,#0xa               ;1238
0000e4  46ea              MOV      r10,sp                ;1200
0000e6  e008              B        |L6.250|
                  |L6.232|
0000e8  4613              MOV      r3,r2                 ;1287
0000ea  fbb2f2f0          UDIV     r2,r2,r0              ;1287
0000ee  fb003412          MLS      r4,r0,r2,r3           ;1287
0000f2  f80a4001          STRB     r4,[r10,r1]           ;1287
0000f6  1e49              SUBS     r1,r1,#1              ;1285
0000f8  b2c9              UXTB     r1,r1                 ;1285
                  |L6.250|
0000fa  2900              CMP      r1,#0                 ;1285
0000fc  d1f4              BNE      |L6.232|
0000fe  2701              MOVS     r7,#1                 ;1291
000100  e038              B        |L6.372|
                  |L6.258|
000102  4a25              LDR      r2,|L6.408|
000104  f81a1007          LDRB     r1,[r10,r7]           ;1293
000108  321c              ADDS     r2,r2,#0x1c           ;1293
00010a  5c54              LDRB     r4,[r2,r1]            ;1293
00010c  7b6a              LDRB     r2,[r5,#0xd]          ;1295
00010e  1bc1              SUBS     r1,r0,r7              ;1295
000110  4291              CMP      r1,r2                 ;1295
000112  d101              BNE      |L6.280|
000114  3480              ADDS     r4,r4,#0x80           ;1296
000116  b2e4              UXTB     r4,r4                 ;1296
                  |L6.280|
000118  2c7e              CMP      r4,#0x7e              ;1298
00011a  d005              BEQ      |L6.296|
00011c  2100              MOVS     r1,#0                 ;1298
                  |L6.286|
00011e  ea110f08          TST      r1,r8                 ;1298
000122  d003              BEQ      |L6.300|
000124  2400              MOVS     r4,#0                 ;1299
000126  e003              B        |L6.304|
                  |L6.296|
000128  2101              MOVS     r1,#1                 ;1298
00012a  e7f8              B        |L6.286|
                  |L6.300|
00012c  f04f0800          MOV      r8,#0                 ;1301
                  |L6.304|
000130  42b8              CMP      r0,r7                 ;1303
000132  d101              BNE      |L6.312|
000134  f004047f          AND      r4,r4,#0x7f           ;1304
                  |L6.312|
000138  2200              MOVS     r2,#0                 ;1306
00013a  4659              MOV      r1,r11                ;1306
00013c  4648              MOV      r0,r9                 ;1306
00013e  f7fffffe          BL       GPIO_WriteBit
000142  6970              LDR      r0,[r6,#0x14]         ;1306  ; zad_spi
000144  f7fffffe          BL       delay_spi
000148  4638              MOV      r0,r7                 ;1307
00014a  f7fffffe          BL       spi_send
00014e  6970              LDR      r0,[r6,#0x14]         ;1307  ; zad_spi
000150  f7fffffe          BL       delay_spi
000154  4620              MOV      r0,r4                 ;1308
000156  f7fffffe          BL       spi_send
00015a  6970              LDR      r0,[r6,#0x14]         ;1308  ; zad_spi
00015c  f7fffffe          BL       delay_spi
000160  2201              MOVS     r2,#1                 ;1309
000162  4659              MOV      r1,r11                ;1309
000164  4648              MOV      r0,r9                 ;1309
000166  f7fffffe          BL       GPIO_WriteBit
00016a  69b0              LDR      r0,[r6,#0x18]         ;1309  ; zad_spi2
00016c  f7fffffe          BL       delay_spi
000170  1c7f              ADDS     r7,r7,#1              ;1291
000172  b2ff              UXTB     r7,r7                 ;1291
                  |L6.372|
000174  7a68              LDRB     r0,[r5,#9]            ;1291
000176  1c41              ADDS     r1,r0,#1              ;1291
000178  42b9              CMP      r1,r7                 ;1291
00017a  d8c2              BHI      |L6.258|
00017c  e7af              B        |L6.222|
;;;1312   
                          ENDP

00017e  0000              DCW      0x0000
                  |L6.384|
                          DCD      ||.bss||+0x92c
                  |L6.388|
                          DCD      0x05f5e100
                  |L6.392|
                          DCD      0x000186a0
                  |L6.396|
                          DCD      0x000f4240
                  |L6.400|
                          DCD      0x00989680
                  |L6.404|
                          DCD      0x40020000
                  |L6.408|
                          DCD      ||area_number.34||

                          AREA ||i.indicate_lin||, CODE, READONLY, ALIGN=2

                  indicate_lin PROC
;;;529    }
;;;530    void indicate_lin(u8 numb_ind,u16 zn, u16 maks, u16 max_kol_st)
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;531    {
000004  461d              MOV      r5,r3
;;;532    		uint16_t  pin=0;
;;;533    		const u8 tabl[9]={0,1,3,7,0xf,0x1f,0x3f,0x7f,0xff};
000006  a398              ADR      r3,|L7.616|
;;;534    		u8 viv=0;
;;;535    //		u16  zad_spi=1000,zad_spi2=10000;
;;;536    
;;;537    	 tmp=(u32) (max_kol_st*zn);
000008  4f9a              LDR      r7,|L7.628|
00000a  e9d34600          LDRD     r4,r6,[r3,#0]         ;533
00000e  689b              LDR      r3,[r3,#8]            ;533
000010  9400              STR      r4,[sp,#0]            ;533
000012  e9cd6301          STRD     r6,r3,[sp,#4]         ;533
000016  fb05f301          MUL      r3,r5,r1
;;;538    	 kol=(u8) (tmp/maks);
00001a  fbb3f1f2          UDIV     r1,r3,r2
00001e  613b              STR      r3,[r7,#0x10]  ; tmp
000020  7039              STRB     r1,[r7,#0]
;;;539    
;;;540    	
;;;541    /*
;;;542    		  switch (numb_ind)
;;;543    			{
;;;544    				case 0x00:  // CS0
;;;545    					pin=GPIO_Pin_0;
;;;546    					break;
;;;547    
;;;548    				case 0x01:  // CS1
;;;549    					pin=GPIO_Pin_1;
;;;550    					break;
;;;551    
;;;552    				case 0x02:  // CS2
;;;553    					pin=GPIO_Pin_2;
;;;554    					break;
;;;555    
;;;556    				case 0x03:  // CS3
;;;557    					pin=GPIO_Pin_3;
;;;558    					break;
;;;559    
;;;560    				case 0x04:  // CS4
;;;561    					pin=GPIO_Pin_4;
;;;562    					break;								
;;;563    			}
;;;564    	*/
;;;565    	  pin=pin_ind(numb_ind);
000022  f7fffffe          BL       pin_ind
000026  0004              MOVS     r4,r0
;;;566    		if (pin==0)
000028  d070              BEQ      |L7.268|
;;;567    				return ;
;;;568    		if (kol>max_kol_st)
00002a  7838              LDRB     r0,[r7,#0]  ; kol
;;;569    		{
;;;570    			if (max_kol_st=28)
;;;571    			{
;;;572    				GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
00002c  f8df8248          LDR      r8,|L7.632|
000030  42a8              CMP      r0,r5                 ;568
000032  d96d              BLS      |L7.272|
000034  2200              MOVS     r2,#0
000036  4621              MOV      r1,r4
000038  4640              MOV      r0,r8
00003a  f7fffffe          BL       GPIO_WriteBit
00003e  6978              LDR      r0,[r7,#0x14]  ; zad_spi
000040  f7fffffe          BL       delay_spi
;;;573    				spi_send((u8)0x01);											delay_spi(zad_spi);
000044  2001              MOVS     r0,#1
000046  f7fffffe          BL       spi_send
00004a  6978              LDR      r0,[r7,#0x14]  ; zad_spi
00004c  f7fffffe          BL       delay_spi
;;;574    				spi_send((u8) 0); 										delay_spi(zad_spi);	
000050  2000              MOVS     r0,#0
000052  f7fffffe          BL       spi_send
000056  6978              LDR      r0,[r7,#0x14]  ; zad_spi
000058  f7fffffe          BL       delay_spi
;;;575    				GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);
00005c  2201              MOVS     r2,#1
00005e  4621              MOV      r1,r4
000060  4640              MOV      r0,r8
000062  f7fffffe          BL       GPIO_WriteBit
000066  69b8              LDR      r0,[r7,#0x18]  ; zad_spi2
000068  f7fffffe          BL       delay_spi
;;;576    
;;;577    				GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
00006c  2200              MOVS     r2,#0
00006e  4621              MOV      r1,r4
000070  4640              MOV      r0,r8
000072  f7fffffe          BL       GPIO_WriteBit
000076  6978              LDR      r0,[r7,#0x14]  ; zad_spi
000078  f7fffffe          BL       delay_spi
;;;578    				spi_send((u8)0x02);											delay_spi(zad_spi);
00007c  2002              MOVS     r0,#2
00007e  f7fffffe          BL       spi_send
000082  6978              LDR      r0,[r7,#0x14]  ; zad_spi
000084  f7fffffe          BL       delay_spi
;;;579    				spi_send((u8) 0); 										delay_spi(zad_spi);	
000088  2000              MOVS     r0,#0
00008a  f7fffffe          BL       spi_send
00008e  6978              LDR      r0,[r7,#0x14]  ; zad_spi
000090  f7fffffe          BL       delay_spi
;;;580    				GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);
000094  2201              MOVS     r2,#1
000096  4621              MOV      r1,r4
000098  4640              MOV      r0,r8
00009a  f7fffffe          BL       GPIO_WriteBit
00009e  69b8              LDR      r0,[r7,#0x18]  ; zad_spi2
0000a0  f7fffffe          BL       delay_spi
;;;581    
;;;582    				GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
0000a4  2200              MOVS     r2,#0
0000a6  4621              MOV      r1,r4
0000a8  4640              MOV      r0,r8
0000aa  f7fffffe          BL       GPIO_WriteBit
0000ae  6978              LDR      r0,[r7,#0x14]  ; zad_spi
0000b0  f7fffffe          BL       delay_spi
;;;583    				spi_send((u8)0x03);											delay_spi(zad_spi);
0000b4  2003              MOVS     r0,#3
0000b6  f7fffffe          BL       spi_send
0000ba  6978              LDR      r0,[r7,#0x14]  ; zad_spi
0000bc  f7fffffe          BL       delay_spi
;;;584    				spi_send((u8) 0); 										delay_spi(zad_spi);	
0000c0  2000              MOVS     r0,#0
0000c2  f7fffffe          BL       spi_send
0000c6  6978              LDR      r0,[r7,#0x14]  ; zad_spi
0000c8  f7fffffe          BL       delay_spi
;;;585    				GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);				
0000cc  2201              MOVS     r2,#1
0000ce  4621              MOV      r1,r4
0000d0  4640              MOV      r0,r8
0000d2  f7fffffe          BL       GPIO_WriteBit
0000d6  69b8              LDR      r0,[r7,#0x18]  ; zad_spi2
0000d8  f7fffffe          BL       delay_spi
;;;586    				
;;;587    				GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
0000dc  2200              MOVS     r2,#0
0000de  4621              MOV      r1,r4
0000e0  4640              MOV      r0,r8
0000e2  f7fffffe          BL       GPIO_WriteBit
0000e6  6978              LDR      r0,[r7,#0x14]  ; zad_spi
0000e8  f7fffffe          BL       delay_spi
;;;588    				spi_send((u8)0x04);											delay_spi(zad_spi);
0000ec  2004              MOVS     r0,#4
0000ee  f7fffffe          BL       spi_send
0000f2  6978              LDR      r0,[r7,#0x14]  ; zad_spi
0000f4  f7fffffe          BL       delay_spi
;;;589    				spi_send((u8) 0x08); 										delay_spi(zad_spi);	
0000f8  2008              MOVS     r0,#8
0000fa  f7fffffe          BL       spi_send
0000fe  6978              LDR      r0,[r7,#0x14]  ; zad_spi
000100  f7fffffe          BL       delay_spi
;;;590    				GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);
000104  2201              MOVS     r2,#1
000106  4621              MOV      r1,r4
000108  4640              MOV      r0,r8
00010a  e0a6              B        |L7.602|
                  |L7.268|
00010c  e0aa              B        |L7.612|
00010e  e7ff              B        |L7.272|
                  |L7.272|
000110  466e              MOV      r6,sp                 ;533
;;;591    			}
;;;592    			return ;
;;;593    		}
;;;594    		if (kol>7)
000112  2807              CMP      r0,#7
000114  d902              BLS      |L7.284|
;;;595    			viv=tabl[8];
000116  f89d5008          LDRB     r5,[sp,#8]
00011a  e002              B        |L7.290|
                  |L7.284|
;;;596    		else
;;;597    			viv=tabl[kol%8];
00011c  f0000007          AND      r0,r0,#7
000120  5c35              LDRB     r5,[r6,r0]
                  |L7.290|
;;;598    		
;;;599    		GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
000122  2200              MOVS     r2,#0
000124  4621              MOV      r1,r4
000126  4640              MOV      r0,r8
000128  f7fffffe          BL       GPIO_WriteBit
00012c  6978              LDR      r0,[r7,#0x14]  ; zad_spi
00012e  f7fffffe          BL       delay_spi
;;;600    		spi_send((u8)0x01);											delay_spi(zad_spi);
000132  2001              MOVS     r0,#1
000134  f7fffffe          BL       spi_send
000138  6978              LDR      r0,[r7,#0x14]  ; zad_spi
00013a  f7fffffe          BL       delay_spi
;;;601    		spi_send((u8) viv); 										delay_spi(zad_spi);	
00013e  4628              MOV      r0,r5
000140  f7fffffe          BL       spi_send
000144  6978              LDR      r0,[r7,#0x14]  ; zad_spi
000146  f7fffffe          BL       delay_spi
;;;602    		GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);
00014a  2201              MOVS     r2,#1
00014c  4621              MOV      r1,r4
00014e  4640              MOV      r0,r8
000150  f7fffffe          BL       GPIO_WriteBit
000154  69b8              LDR      r0,[r7,#0x18]  ; zad_spi2
000156  f7fffffe          BL       delay_spi
;;;603    		
;;;604    		if (kol<8)
00015a  7838              LDRB     r0,[r7,#0]  ; kol
00015c  2808              CMP      r0,#8
00015e  d201              BCS      |L7.356|
;;;605    			viv=0;
000160  2500              MOVS     r5,#0
000162  e00a              B        |L7.378|
                  |L7.356|
;;;606    		else
;;;607    		{
;;;608    			kol=kol-8;
000164  3808              SUBS     r0,r0,#8
000166  b2c0              UXTB     r0,r0
000168  7038              STRB     r0,[r7,#0]
;;;609    			if (kol>7)
00016a  2807              CMP      r0,#7
00016c  d902              BLS      |L7.372|
;;;610    				viv=tabl[8];
00016e  f89d5008          LDRB     r5,[sp,#8]
000172  e002              B        |L7.378|
                  |L7.372|
;;;611    			else
;;;612    				viv=tabl[kol%8];
000174  f0000007          AND      r0,r0,#7
000178  5c35              LDRB     r5,[r6,r0]
                  |L7.378|
;;;613    		}
;;;614    		
;;;615    		GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
00017a  2200              MOVS     r2,#0
00017c  4621              MOV      r1,r4
00017e  4640              MOV      r0,r8
000180  f7fffffe          BL       GPIO_WriteBit
000184  6978              LDR      r0,[r7,#0x14]  ; zad_spi
000186  f7fffffe          BL       delay_spi
;;;616    		spi_send((u8)0x02);											delay_spi(zad_spi);
00018a  2002              MOVS     r0,#2
00018c  f7fffffe          BL       spi_send
000190  6978              LDR      r0,[r7,#0x14]  ; zad_spi
000192  f7fffffe          BL       delay_spi
;;;617    		spi_send((u8)viv); 											delay_spi(zad_spi);	
000196  4628              MOV      r0,r5
000198  f7fffffe          BL       spi_send
00019c  6978              LDR      r0,[r7,#0x14]  ; zad_spi
00019e  f7fffffe          BL       delay_spi
;;;618    		GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);
0001a2  2201              MOVS     r2,#1
0001a4  4621              MOV      r1,r4
0001a6  4640              MOV      r0,r8
0001a8  f7fffffe          BL       GPIO_WriteBit
0001ac  69b8              LDR      r0,[r7,#0x18]  ; zad_spi2
0001ae  f7fffffe          BL       delay_spi
;;;619    	
;;;620    		if (kol<8)
0001b2  7838              LDRB     r0,[r7,#0]  ; kol
0001b4  2808              CMP      r0,#8
0001b6  d201              BCS      |L7.444|
;;;621    			viv=0;
0001b8  2500              MOVS     r5,#0
0001ba  e00a              B        |L7.466|
                  |L7.444|
;;;622    		else
;;;623    		{
;;;624    			kol=kol-8;
0001bc  3808              SUBS     r0,r0,#8
0001be  b2c0              UXTB     r0,r0
0001c0  7038              STRB     r0,[r7,#0]
;;;625    			if (kol>7)
0001c2  2807              CMP      r0,#7
0001c4  d902              BLS      |L7.460|
;;;626    				viv=tabl[8];
0001c6  f89d5008          LDRB     r5,[sp,#8]
0001ca  e002              B        |L7.466|
                  |L7.460|
;;;627    			else
;;;628    				viv=tabl[kol%8];
0001cc  f0000007          AND      r0,r0,#7
0001d0  5c35              LDRB     r5,[r6,r0]
                  |L7.466|
;;;629    		}
;;;630    		
;;;631    		GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
0001d2  2200              MOVS     r2,#0
0001d4  4621              MOV      r1,r4
0001d6  4640              MOV      r0,r8
0001d8  f7fffffe          BL       GPIO_WriteBit
0001dc  6978              LDR      r0,[r7,#0x14]  ; zad_spi
0001de  f7fffffe          BL       delay_spi
;;;632    		spi_send((u8)0x03);delay_spi(zad_spi);
0001e2  2003              MOVS     r0,#3
0001e4  f7fffffe          BL       spi_send
0001e8  6978              LDR      r0,[r7,#0x14]  ; zad_spi
0001ea  f7fffffe          BL       delay_spi
;;;633    		spi_send((u8)viv); delay_spi(zad_spi);	
0001ee  4628              MOV      r0,r5
0001f0  f7fffffe          BL       spi_send
0001f4  6978              LDR      r0,[r7,#0x14]  ; zad_spi
0001f6  f7fffffe          BL       delay_spi
;;;634    		GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);
0001fa  2201              MOVS     r2,#1
0001fc  4621              MOV      r1,r4
0001fe  4640              MOV      r0,r8
000200  f7fffffe          BL       GPIO_WriteBit
000204  69b8              LDR      r0,[r7,#0x18]  ; zad_spi2
000206  f7fffffe          BL       delay_spi
;;;635    
;;;636    		if (kol<8)
00020a  7838              LDRB     r0,[r7,#0]  ; kol
00020c  2808              CMP      r0,#8
00020e  d201              BCS      |L7.532|
;;;637    			viv=0;
000210  2500              MOVS     r5,#0
000212  e00a              B        |L7.554|
                  |L7.532|
;;;638    		else
;;;639    		{
;;;640    			kol=kol-8;
000214  3808              SUBS     r0,r0,#8
000216  b2c0              UXTB     r0,r0
000218  7038              STRB     r0,[r7,#0]
;;;641    			if (kol>7)
00021a  2807              CMP      r0,#7
00021c  d902              BLS      |L7.548|
;;;642    				viv=tabl[8];
00021e  f89d5008          LDRB     r5,[sp,#8]
000222  e002              B        |L7.554|
                  |L7.548|
;;;643    			else
;;;644    				viv=tabl[kol%8];
000224  f0000007          AND      r0,r0,#7
000228  5c35              LDRB     r5,[r6,r0]
                  |L7.554|
;;;645    		}
;;;646    		
;;;647    		GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
00022a  2200              MOVS     r2,#0
00022c  4621              MOV      r1,r4
00022e  4646              MOV      r6,r8
000230  4640              MOV      r0,r8
000232  f7fffffe          BL       GPIO_WriteBit
000236  6978              LDR      r0,[r7,#0x14]  ; zad_spi
000238  f7fffffe          BL       delay_spi
;;;648    		spi_send((u8)0x04);delay_spi(zad_spi);
00023c  2004              MOVS     r0,#4
00023e  f7fffffe          BL       spi_send
000242  6978              LDR      r0,[r7,#0x14]  ; zad_spi
000244  f7fffffe          BL       delay_spi
;;;649    		spi_send((u8)viv); delay_spi(zad_spi);	
000248  4628              MOV      r0,r5
00024a  f7fffffe          BL       spi_send
00024e  6978              LDR      r0,[r7,#0x14]  ; zad_spi
000250  f7fffffe          BL       delay_spi
;;;650    		GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);
000254  2201              MOVS     r2,#1
000256  4621              MOV      r1,r4
000258  4630              MOV      r0,r6
                  |L7.602|
00025a  f7fffffe          BL       GPIO_WriteBit
00025e  69b8              LDR      r0,[r7,#0x18]         ;590  ; zad_spi2
000260  f7fffffe          BL       delay_spi
                  |L7.612|
;;;651    	//	kol=kol%8;			
;;;652    
;;;653    	
;;;654    }
000264  e8bd83fe          POP      {r1-r9,pc}
;;;655    /*
                          ENDP

                  |L7.616|
000268  00                DCB      0
000269  0103070f          DCB      1,3,"\a",15,31,"?",127,255,0
00026d  1f3f7fff
000271  00      
000272  00                DCB      0
000273  00                DCB      0
                  |L7.628|
                          DCD      ||area_number.34||
                  |L7.632|
                          DCD      0x40020000

                          AREA ||i.indicate_time||, CODE, READONLY, ALIGN=2

                  indicate_time PROC
;;;1313   
;;;1314   void indicate_time(u8 numb_ind, u8 hh, u8 mm, u8 en)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1315   {
000004  461f              MOV      r7,r3
000006  4691              MOV      r9,r2
000008  460c              MOV      r4,r1
;;;1316   		 	uint16_t  pin=0;
;;;1317   
;;;1318   /*
;;;1319   			switch (numb_ind)
;;;1320   			{
;;;1321   				case 0x00:  // CS0
;;;1322   					pin=GPIO_Pin_0;
;;;1323   					break;
;;;1324   
;;;1325   				case 0x01:  // CS1
;;;1326   					pin=GPIO_Pin_1;
;;;1327   					break;
;;;1328   
;;;1329   				case 0x02:  // CS2
;;;1330   					pin=GPIO_Pin_2;
;;;1331   					break;
;;;1332   
;;;1333   				case 0x03:  // CS3
;;;1334   					pin=GPIO_Pin_3;
;;;1335   					break;
;;;1336   
;;;1337   				case 0x04:  // CS4
;;;1338   					pin=GPIO_Pin_4;
;;;1339   					break;						
;;;1340   			}
;;;1341   	*/
;;;1342   			  pin=pin_ind(numb_ind);
00000a  f7fffffe          BL       pin_ind
00000e  0006              MOVS     r6,r0
;;;1343   		if (pin==0)
000010  d07e              BEQ      |L8.272|
;;;1344   				return ;
;;;1345   				GPIO_WriteBit(GPIOA, pin, Bit_RESET);      //   
000012  f8df8164          LDR      r8,|L8.376|
000016  4601              MOV      r1,r0
000018  2200              MOVS     r2,#0
00001a  4645              MOV      r5,r8
00001c  4640              MOV      r0,r8
00001e  f7fffffe          BL       GPIO_WriteBit
;;;1346   				delay_spi(100);
000022  2064              MOVS     r0,#0x64
000024  f7fffffe          BL       delay_spi
;;;1347   				spi_send(0x0f);delay_spi(100);
000028  200f              MOVS     r0,#0xf
00002a  f7fffffe          BL       spi_send
00002e  2064              MOVS     r0,#0x64
000030  f7fffffe          BL       delay_spi
;;;1348   				spi_send(0x00); delay_spi(100);
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       spi_send
00003a  2064              MOVS     r0,#0x64
00003c  f7fffffe          BL       delay_spi
;;;1349   				GPIO_WriteBit(GPIOA, pin, Bit_SET);      //  
000040  2201              MOVS     r2,#1
000042  4631              MOV      r1,r6
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       GPIO_WriteBit
;;;1350   				delay_spi(1000);
00004a  f44f707a          MOV      r0,#0x3e8
00004e  f7fffffe          BL       delay_spi
;;;1351   
;;;1352   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);      //   
000052  2200              MOVS     r2,#0
000054  4631              MOV      r1,r6
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       GPIO_WriteBit
;;;1353   			delay_spi(100);
00005c  2064              MOVS     r0,#0x64
00005e  f7fffffe          BL       delay_spi
;;;1354   			spi_send(1);delay_spi(100);
000062  2001              MOVS     r0,#1
000064  f7fffffe          BL       spi_send
000068  2064              MOVS     r0,#0x64
00006a  f7fffffe          BL       delay_spi
;;;1355   			if (hh/10==0)
;;;1356   				spi_send(0); 
;;;1357   			else
;;;1358   				spi_send(symb_code[hh/10]); 
00006e  f04f0a0a          MOV      r10,#0xa
000072  fbb4f5fa          UDIV     r5,r4,r10
000076  f8dfb104          LDR      r11,|L8.380|
00007a  2c0a              CMP      r4,#0xa               ;1355
00007c  d201              BCS      |L8.130|
00007e  2000              MOVS     r0,#0                 ;1356
000080  e001              B        |L8.134|
                  |L8.130|
000082  f81b0005          LDRB     r0,[r11,r5]
                  |L8.134|
000086  f7fffffe          BL       spi_send
;;;1359   			delay_spi(100);	
00008a  2064              MOVS     r0,#0x64
00008c  f7fffffe          BL       delay_spi
;;;1360   			GPIO_WriteBit(GPIOA, pin, Bit_SET);     
000090  2201              MOVS     r2,#1
000092  4631              MOV      r1,r6
000094  4838              LDR      r0,|L8.376|
000096  f7fffffe          BL       GPIO_WriteBit
;;;1361   			delay_spi(1000);	
00009a  f44f707a          MOV      r0,#0x3e8
00009e  f7fffffe          BL       delay_spi
;;;1362   	
;;;1363   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);      //   
0000a2  2200              MOVS     r2,#0
0000a4  4631              MOV      r1,r6
0000a6  4834              LDR      r0,|L8.376|
0000a8  f7fffffe          BL       GPIO_WriteBit
;;;1364   			delay_spi(100);
0000ac  2064              MOVS     r0,#0x64
0000ae  f7fffffe          BL       delay_spi
;;;1365   			spi_send(2);delay_spi(100);
0000b2  2002              MOVS     r0,#2
0000b4  f7fffffe          BL       spi_send
0000b8  2064              MOVS     r0,#0x64
0000ba  f7fffffe          BL       delay_spi
;;;1366   			spi_send(0x80*en+symb_code[hh%10]); delay_spi(100);	
0000be  fb0a4115          MLS      r1,r10,r5,r4
0000c2  46d0              MOV      r8,r10
0000c4  f81b0001          LDRB     r0,[r11,r1]
0000c8  eb0010c7          ADD      r0,r0,r7,LSL #7
0000cc  f7fffffe          BL       spi_send
0000d0  2064              MOVS     r0,#0x64
0000d2  f7fffffe          BL       delay_spi
;;;1367   			GPIO_WriteBit(GPIOA, pin, Bit_SET);     
0000d6  2201              MOVS     r2,#1
0000d8  4631              MOV      r1,r6
0000da  4827              LDR      r0,|L8.376|
0000dc  f7fffffe          BL       GPIO_WriteBit
;;;1368   			delay_spi(1000);				
0000e0  f44f707a          MOV      r0,#0x3e8
0000e4  f7fffffe          BL       delay_spi
;;;1369   			
;;;1370   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);      //   
0000e8  2200              MOVS     r2,#0
0000ea  4631              MOV      r1,r6
0000ec  4822              LDR      r0,|L8.376|
0000ee  f7fffffe          BL       GPIO_WriteBit
;;;1371   			delay_spi(100);
0000f2  2064              MOVS     r0,#0x64
0000f4  f7fffffe          BL       delay_spi
;;;1372   			spi_send(3);delay_spi(100);
0000f8  2003              MOVS     r0,#3
0000fa  f7fffffe          BL       spi_send
0000fe  2064              MOVS     r0,#0x64
000100  f7fffffe          BL       delay_spi
;;;1373   			spi_send(1*en+symb_code_min[mm/10]); delay_spi(100);	
000104  fbb9f4f8          UDIV     r4,r9,r8
000108  4d1c              LDR      r5,|L8.380|
00010a  350d              ADDS     r5,r5,#0xd
00010c  5d28              LDRB     r0,[r5,r4]
00010e  e000              B        |L8.274|
                  |L8.272|
000110  e02f              B        |L8.370|
                  |L8.274|
000112  4438              ADD      r0,r0,r7
000114  f7fffffe          BL       spi_send
000118  2064              MOVS     r0,#0x64
00011a  f7fffffe          BL       delay_spi
;;;1374   			GPIO_WriteBit(GPIOA, pin, Bit_SET);     
00011e  2201              MOVS     r2,#1
000120  4631              MOV      r1,r6
000122  4815              LDR      r0,|L8.376|
000124  f7fffffe          BL       GPIO_WriteBit
;;;1375   			delay_spi(1000);	
000128  f44f707a          MOV      r0,#0x3e8
00012c  f7fffffe          BL       delay_spi
;;;1376   
;;;1377   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);      //   
000130  2200              MOVS     r2,#0
000132  4631              MOV      r1,r6
000134  4810              LDR      r0,|L8.376|
000136  f7fffffe          BL       GPIO_WriteBit
;;;1378   			delay_spi(100);
00013a  2064              MOVS     r0,#0x64
00013c  f7fffffe          BL       delay_spi
;;;1379   			spi_send(4);delay_spi(100);
000140  2004              MOVS     r0,#4
000142  f7fffffe          BL       spi_send
000146  2064              MOVS     r0,#0x64
000148  f7fffffe          BL       delay_spi
;;;1380   			spi_send(symb_code_min[mm%10]); delay_spi(100);	
00014c  fb089114          MLS      r1,r8,r4,r9
000150  5c68              LDRB     r0,[r5,r1]
000152  f7fffffe          BL       spi_send
000156  2064              MOVS     r0,#0x64
000158  f7fffffe          BL       delay_spi
;;;1381   			GPIO_WriteBit(GPIOA, pin, Bit_SET);     
00015c  2201              MOVS     r2,#1
00015e  4631              MOV      r1,r6
000160  4805              LDR      r0,|L8.376|
000162  f7fffffe          BL       GPIO_WriteBit
;;;1382   			delay_spi(1000);	
000166  e8bd5ff0          POP      {r4-r12,lr}
00016a  f44f707a          MOV      r0,#0x3e8
00016e  f7ffbffe          B.W      delay_spi
                  |L8.370|
;;;1383   	
;;;1384   }
000172  e8bd9ff0          POP      {r4-r12,pc}
;;;1385   
                          ENDP

000176  0000              DCW      0x0000
                  |L8.376|
                          DCD      0x40020000
                  |L8.380|
                          DCD      ||area_number.34||+0x1c

                          AREA ||i.init_ind||, CODE, READONLY, ALIGN=2

                  init_ind PROC
;;;929    
;;;930    void init_ind(u8 numb_ind, u8 kol_ind, u8 type_ind)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;931    {
000004  4688              MOV      r8,r1
;;;932    			uint16_t  pin=0;
;;;933    			u8 i=0;
;;;934    //			u16  zad_spi=1000,zad_spi2=10000;
;;;935    
;;;936    			/*
;;;937    		  switch (numb_ind)
;;;938    			{
;;;939    				case 0x00:  // CS0
;;;940    					pin=GPIO_Pin_0;
;;;941    					break;
;;;942    
;;;943    				case 0x01:  // CS1
;;;944    					pin=GPIO_Pin_1;
;;;945    					break;
;;;946    
;;;947    				case 0x02:  // CS2
;;;948    					pin=GPIO_Pin_2;
;;;949    					break;
;;;950    
;;;951    				case 0x03:  // CS3
;;;952    					pin=GPIO_Pin_3;
;;;953    					break;
;;;954    
;;;955    				case 0x04:  // CS4
;;;956    					pin=GPIO_Pin_4;
;;;957    					break;								
;;;958    			}
;;;959    			*/
;;;960    			pin=pin_ind(numb_ind);
000006  f7fffffe          BL       pin_ind
00000a  0007              MOVS     r7,r0
;;;961    			if (pin==0)
00000c  d07e              BEQ      |L9.268|
;;;962    				return;
;;;963    			
;;;964    			// shutdown off
;;;965    			GPIO_WriteBit(GPIOA, pin, Bit_RESET);  delay_spi(zad_spi);		
00000e  4e5e              LDR      r6,|L9.392|
000010  4601              MOV      r1,r0
000012  2200              MOVS     r2,#0
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       GPIO_WriteBit
00001a  4d5c              LDR      r5,|L9.396|
00001c  6968              LDR      r0,[r5,#0x14]  ; zad_spi
00001e  f7fffffe          BL       delay_spi
;;;966    			spi_send(0x0C);			delay_spi(zad_spi);
000022  200c              MOVS     r0,#0xc
000024  f7fffffe          BL       spi_send
000028  6968              LDR      r0,[r5,#0x14]  ; zad_spi
00002a  f7fffffe          BL       delay_spi
;;;967    			spi_send(0x01);			delay_spi(zad_spi);			
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       spi_send
000034  6968              LDR      r0,[r5,#0x14]  ; zad_spi
000036  f7fffffe          BL       delay_spi
;;;968    			GPIO_WriteBit(GPIOA, pin, Bit_SET);      		delay_spi(zad_spi2);
00003a  2201              MOVS     r2,#1
00003c  4639              MOV      r1,r7
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       GPIO_WriteBit
000044  69a8              LDR      r0,[r5,#0x18]  ; zad_spi2
000046  f7fffffe          BL       delay_spi
;;;969    
;;;970    		for (i=1;i<9;i++)
00004a  2401              MOVS     r4,#1
                  |L9.76|
;;;971    		{
;;;972    			// blank all
;;;973    			GPIO_WriteBit(GPIOA, pin, Bit_RESET);      delay_spi(zad_spi);
00004c  2200              MOVS     r2,#0
00004e  4639              MOV      r1,r7
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       GPIO_WriteBit
000056  6968              LDR      r0,[r5,#0x14]  ; zad_spi
000058  f7fffffe          BL       delay_spi
;;;974    			spi_send((u8) i);					delay_spi(zad_spi);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       spi_send
000062  6968              LDR      r0,[r5,#0x14]  ; zad_spi
000064  f7fffffe          BL       delay_spi
;;;975    			spi_send(0x00);					  delay_spi(zad_spi);			
000068  2000              MOVS     r0,#0
00006a  f7fffffe          BL       spi_send
00006e  6968              LDR      r0,[r5,#0x14]  ; zad_spi
000070  f7fffffe          BL       delay_spi
;;;976    			GPIO_WriteBit(GPIOA, pin, Bit_SET);      		delay_spi(zad_spi2);
000074  2201              MOVS     r2,#1
000076  4639              MOV      r1,r7
000078  4630              MOV      r0,r6
00007a  f7fffffe          BL       GPIO_WriteBit
00007e  69a8              LDR      r0,[r5,#0x18]  ; zad_spi2
000080  f7fffffe          BL       delay_spi
000084  1c64              ADDS     r4,r4,#1              ;970
000086  b2e4              UXTB     r4,r4                 ;970
000088  2c09              CMP      r4,#9                 ;970
00008a  d3df              BCC      |L9.76|
;;;977    		}
;;;978    		
;;;979    			// scan limit
;;;980    			GPIO_WriteBit(GPIOA, pin, Bit_RESET);   			delay_spi(zad_spi);
00008c  2200              MOVS     r2,#0
00008e  4639              MOV      r1,r7
000090  4630              MOV      r0,r6
000092  f7fffffe          BL       GPIO_WriteBit
000096  6968              LDR      r0,[r5,#0x14]  ; zad_spi
000098  f7fffffe          BL       delay_spi
;;;981    			spi_send(0x0B);				delay_spi(zad_spi);
00009c  200b              MOVS     r0,#0xb
00009e  f7fffffe          BL       spi_send
0000a2  6968              LDR      r0,[r5,#0x14]  ; zad_spi
0000a4  f7fffffe          BL       delay_spi
;;;982    			spi_send(kol_ind-1);	delay_spi(zad_spi);			
0000a8  f1a80001          SUB      r0,r8,#1
0000ac  b280              UXTH     r0,r0
0000ae  f7fffffe          BL       spi_send
0000b2  6968              LDR      r0,[r5,#0x14]  ; zad_spi
0000b4  f7fffffe          BL       delay_spi
;;;983    			GPIO_WriteBit(GPIOA, pin, Bit_SET);      			delay_spi(zad_spi2);
0000b8  2201              MOVS     r2,#1
0000ba  4639              MOV      r1,r7
0000bc  4630              MOV      r0,r6
0000be  f7fffffe          BL       GPIO_WriteBit
0000c2  69a8              LDR      r0,[r5,#0x18]  ; zad_spi2
0000c4  f7fffffe          BL       delay_spi
;;;984    			
;;;985    			// registr intensivnost
;;;986    			GPIO_WriteBit(GPIOA, pin, Bit_RESET);      delay_spi(zad_spi);
0000c8  2200              MOVS     r2,#0
0000ca  4639              MOV      r1,r7
0000cc  4630              MOV      r0,r6
0000ce  f7fffffe          BL       GPIO_WriteBit
0000d2  6968              LDR      r0,[r5,#0x14]  ; zad_spi
0000d4  f7fffffe          BL       delay_spi
;;;987    			spi_send(0x0A);					delay_spi(zad_spi);
0000d8  200a              MOVS     r0,#0xa
0000da  f7fffffe          BL       spi_send
0000de  6968              LDR      r0,[r5,#0x14]  ; zad_spi
0000e0  f7fffffe          BL       delay_spi
;;;988    			spi_send(0x0F);					delay_spi(zad_spi);			
0000e4  200f              MOVS     r0,#0xf
0000e6  f7fffffe          BL       spi_send
0000ea  6968              LDR      r0,[r5,#0x14]  ; zad_spi
0000ec  f7fffffe          BL       delay_spi
;;;989    			GPIO_WriteBit(GPIOA, pin, Bit_SET);     delay_spi(zad_spi2);
0000f0  2201              MOVS     r2,#1
0000f2  4639              MOV      r1,r7
0000f4  4630              MOV      r0,r6
0000f6  f7fffffe          BL       GPIO_WriteBit
0000fa  69a8              LDR      r0,[r5,#0x18]  ; zad_spi2
0000fc  f7fffffe          BL       delay_spi
;;;990    
;;;991    	
;;;992    		// test
;;;993    			GPIO_WriteBit(GPIOA, pin, Bit_RESET);      delay_spi(zad_spi);
000100  2200              MOVS     r2,#0
000102  4639              MOV      r1,r7
000104  4630              MOV      r0,r6
000106  f7fffffe          BL       GPIO_WriteBit
00010a  e000              B        |L9.270|
                  |L9.268|
00010c  e039              B        |L9.386|
                  |L9.270|
00010e  6968              LDR      r0,[r5,#0x14]  ; zad_spi
000110  f7fffffe          BL       delay_spi
;;;994    			spi_send((u8) 0x0f);					delay_spi(zad_spi);
000114  200f              MOVS     r0,#0xf
000116  f7fffffe          BL       spi_send
00011a  6968              LDR      r0,[r5,#0x14]  ; zad_spi
00011c  f7fffffe          BL       delay_spi
;;;995    			spi_send(0x01);					delay_spi(zad_spi);			
000120  2001              MOVS     r0,#1
000122  f7fffffe          BL       spi_send
000126  6968              LDR      r0,[r5,#0x14]  ; zad_spi
000128  f7fffffe          BL       delay_spi
;;;996    			GPIO_WriteBit(GPIOA, pin, Bit_SET);      delay_spi(zad_spi2);
00012c  2201              MOVS     r2,#1
00012e  4639              MOV      r1,r7
000130  4630              MOV      r0,r6
000132  f7fffffe          BL       GPIO_WriteBit
000136  69a8              LDR      r0,[r5,#0x18]  ; zad_spi2
000138  f7fffffe          BL       delay_spi
;;;997    
;;;998    		  delay_spi(zad_spi2*50);	
00013c  69a8              LDR      r0,[r5,#0x18]  ; zad_spi2
00013e  2132              MOVS     r1,#0x32
000140  4348              MULS     r0,r1,r0
000142  f7fffffe          BL       delay_spi
;;;999    		
;;;1000   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);      delay_spi(zad_spi);
000146  2200              MOVS     r2,#0
000148  4639              MOV      r1,r7
00014a  4630              MOV      r0,r6
00014c  f7fffffe          BL       GPIO_WriteBit
000150  6968              LDR      r0,[r5,#0x14]  ; zad_spi
000152  f7fffffe          BL       delay_spi
;;;1001   			spi_send((u8) 0x0f);					delay_spi(zad_spi);
000156  200f              MOVS     r0,#0xf
000158  f7fffffe          BL       spi_send
00015c  6968              LDR      r0,[r5,#0x14]  ; zad_spi
00015e  f7fffffe          BL       delay_spi
;;;1002   			spi_send(0x00);					delay_spi(zad_spi);			
000162  2000              MOVS     r0,#0
000164  f7fffffe          BL       spi_send
000168  6968              LDR      r0,[r5,#0x14]  ; zad_spi
00016a  f7fffffe          BL       delay_spi
;;;1003   			GPIO_WriteBit(GPIOA, pin, Bit_SET);     delay_spi(zad_spi2);					
00016e  2201              MOVS     r2,#1
000170  4639              MOV      r1,r7
000172  4630              MOV      r0,r6
000174  f7fffffe          BL       GPIO_WriteBit
000178  69a8              LDR      r0,[r5,#0x18]  ; zad_spi2
00017a  e8bd41f0          POP      {r4-r8,lr}
00017e  f7ffbffe          B.W      delay_spi
                  |L9.386|
;;;1004   	//		test_ind_all();
;;;1005   	//	test_lin();
;;;1006   }
000182  e8bd81f0          POP      {r4-r8,pc}
;;;1007   
                          ENDP

000186  0000              DCW      0x0000
                  |L9.392|
                          DCD      0x40020000
                  |L9.396|
                          DCD      ||area_number.34||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1391   */
;;;1392   int main(void)
000000  b088              SUB      sp,sp,#0x20
;;;1393   { 
;;;1394   	u8 i=0;
;;;1395   	GPIO_InitTypeDef GPIO_InitStructure;
;;;1396     NVIC_InitTypeDef NVIC_InitStructure;
;;;1397     RCC_ClocksTypeDef RCC_ClockFreq;
;;;1398   	
;;;1399   	uint16_t data[32];
;;;1400   	
;;;1401   	TDateTime DT;
;;;1402   
;;;1403   
;;;1404     /* Initialize LEDS */
;;;1405     STM_EVAL_LEDInit(LED3);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       STM_EVAL_LEDInit
;;;1406     STM_EVAL_LEDInit(LED4);
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       STM_EVAL_LEDInit
;;;1407     STM_EVAL_LEDInit(LED5);
00000e  2002              MOVS     r0,#2
000010  f7fffffe          BL       STM_EVAL_LEDInit
;;;1408     STM_EVAL_LEDInit(LED6);
000014  2003              MOVS     r0,#3
000016  f7fffffe          BL       STM_EVAL_LEDInit
;;;1409    
;;;1410     /* Green Led On: start of application */
;;;1411   	STM_EVAL_LEDOn(LED3);
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       STM_EVAL_LEDOn
;;;1412   	STM_EVAL_LEDOn(LED4);
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       STM_EVAL_LEDOn
;;;1413   	STM_EVAL_LEDOn(LED5);
000026  2002              MOVS     r0,#2
000028  f7fffffe          BL       STM_EVAL_LEDOn
;;;1414   	STM_EVAL_LEDOn(LED6);	
00002c  2003              MOVS     r0,#3
00002e  f7fffffe          BL       STM_EVAL_LEDOn
;;;1415   	 
;;;1416     /* This function fills the RCC_ClockFreq structure with the current
;;;1417     frequencies of different on chip clocks (for debug purpose) **************/
;;;1418     RCC_GetClocksFreq(&RCC_ClockFreq);
000032  a804              ADD      r0,sp,#0x10
000034  f7fffffe          BL       RCC_GetClocksFreq
;;;1419     
;;;1420     /* Enable Clock Security System(CSS): this will generate an NMI exception
;;;1421     when HSE clock fails *****************************************************/
;;;1422     RCC_ClockSecuritySystemCmd(ENABLE);
000038  2001              MOVS     r0,#1
00003a  f7fffffe          BL       RCC_ClockSecuritySystemCmd
;;;1423     
;;;1424     /* Enable and configure RCC global IRQ channel, will be used to manage HSE ready 
;;;1425        and PLL ready interrupts. 
;;;1426        These interrupts are enabled in stm32f4xx_it.c file **********************/
;;;1427     NVIC_InitStructure.NVIC_IRQChannel = RCC_IRQn;
00003e  2005              MOVS     r0,#5
000040  f88d000c          STRB     r0,[sp,#0xc]
;;;1428     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000044  f04f0900          MOV      r9,#0
000048  f88d900d          STRB     r9,[sp,#0xd]
;;;1429     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;  
00004c  f88d900e          STRB     r9,[sp,#0xe]
;;;1430     NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000050  2501              MOVS     r5,#1
000052  f88d500f          STRB     r5,[sp,#0xf]
;;;1431     NVIC_Init(&NVIC_InitStructure);
000056  a803              ADD      r0,sp,#0xc
000058  f7fffffe          BL       NVIC_Init
;;;1432   
;;;1433     /* Output clock on MCO2 pin(PC9) ****************************************/ 
;;;1434     /* Enable the GPIOC peripheral */ 
;;;1435     RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
00005c  2101              MOVS     r1,#1
00005e  2004              MOVS     r0,#4
000060  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;1436     
;;;1437     /* Configure MCO2 pin(PC9) in alternate function */
;;;1438     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000064  0268              LSLS     r0,r5,#9
;;;1439     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000066  2603              MOVS     r6,#3
000068  9001              STR      r0,[sp,#4]
00006a  f88d6009          STRB     r6,[sp,#9]
;;;1440     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00006e  2702              MOVS     r7,#2
000070  f88d7008          STRB     r7,[sp,#8]
;;;1441     GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000074  2000              MOVS     r0,#0
000076  f88d000a          STRB     r0,[sp,#0xa]
;;;1442     GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;  
00007a  f88d500b          STRB     r5,[sp,#0xb]
;;;1443     GPIO_Init(GPIOC, &GPIO_InitStructure);
00007e  a901              ADD      r1,sp,#4
000080  4879              LDR      r0,|L10.616|
000082  f7fffffe          BL       GPIO_Init
;;;1444       
;;;1445     /* System clock selected to output on MCO2 pin(PC9)*/
;;;1446     RCC_MCO2Config(RCC_MCO2Source_SYSCLK, RCC_MCO2Div_2);
000086  0769              LSLS     r1,r5,#29
000088  2000              MOVS     r0,#0
00008a  f7fffffe          BL       RCC_MCO2Config
;;;1447   
;;;1448   
;;;1449   
;;;1450       // ???????? RTC
;;;1451       rtc_Reset();
00008e  f7fffffe          BL       rtc_Reset
;;;1452       rtc_Init();
000092  f7fffffe          BL       rtc_Init
;;;1453    		
;;;1454   	
;;;1455   //	ADC_InitTypeDef  ADC_InitStructure;
;;;1456   	
;;;1457          
;;;1458     
;;;1459     /* Configure TIM4 Peripheral to manage LEDs lighting */
;;;1460     TIM_LED_Config();
000096  f7fffffe          BL       TIM_LED_Config
;;;1461     
;;;1462     /* Initialize the repeat status */
;;;1463     RepeatState = 0;
00009a  4974              LDR      r1,|L10.620|
00009c  2000              MOVS     r0,#0
00009e  7048              STRB     r0,[r1,#1]
;;;1464     LED_Toggle = 7;
0000a0  4973              LDR      r1,|L10.624|
0000a2  f04f0807          MOV      r8,#7
0000a6  f8818000          STRB     r8,[r1,#0]
;;;1465     
;;;1466   	// PC pin2
;;;1467     ADC3_CH12_DMA_Config();
0000aa  f7fffffe          BL       ADC3_CH12_DMA_Config
;;;1468     // Start ADC3 Software Conversion 
;;;1469     ADC_SoftwareStartConv(ADC3);
0000ae  4871              LDR      r0,|L10.628|
0000b0  f7fffffe          BL       ADC_SoftwareStartConv
;;;1470   	
;;;1471   	
;;;1472     
;;;1473   #if defined MEDIA_USB_KEY
;;;1474     
;;;1475     /* Initialize User Button */
;;;1476     STM_EVAL_PBInit(BUTTON_USER, BUTTON_MODE_EXTI);
0000b4  2101              MOVS     r1,#1
0000b6  2000              MOVS     r0,#0
0000b8  f7fffffe          BL       STM_EVAL_PBInit
;;;1477      
;;;1478     /* Init Host Library */
;;;1479     USBH_Init(&USB_OTG_Core, USB_OTG_FS_CORE_ID, &USB_Host, &USBH_MSC_cb, &USR_Callbacks);
0000bc  486e              LDR      r0,|L10.632|
0000be  4a70              LDR      r2,|L10.640|
0000c0  9000              STR      r0,[sp,#0]
0000c2  4b6e              LDR      r3,|L10.636|
0000c4  2101              MOVS     r1,#1
0000c6  f5a26096          SUB      r0,r2,#0x4b0
0000ca  f7fffffe          BL       USBH_Init
;;;1480    
;;;1481   
;;;1482   
;;;1483   /*
;;;1484   SPI 1:
;;;1485   
;;;1486    nss - pa4
;;;1487    
;;;1488    sck - pa5
;;;1489    mosi - pa7
;;;1490    
;;;1491    miso - pa6
;;;1492   SPI 2:
;;;1493   
;;;1494    miso - pb14
;;;1495    mosi - pb15
;;;1496    sck - pb13
;;;1497    nss - pb12
;;;1498    
;;;1499   */
;;;1500   		spi1_init();
0000ce  f7fffffe          BL       spi1_init
;;;1501       spi2_init();
0000d2  f7fffffe          BL       spi2_init
;;;1502    
;;;1503   		
;;;1504   	
;;;1505   		RCC_APB2PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE); 	//port A
0000d6  2101              MOVS     r1,#1
0000d8  4608              MOV      r0,r1
0000da  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1506   		GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_1|GPIO_Pin_0;  //  vivod for CS
;;;1507   		GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;     			// rezim vivoda
0000de  f88d5008          STRB     r5,[sp,#8]
;;;1508   		GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;          //  PP GPIO_OType_PP
0000e2  f88d500a          STRB     r5,[sp,#0xa]
;;;1509   		// gpio.GPIO_PuPd = GPIO_PuPd_DOWN;
;;;1510   		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;     //speed
0000e6  2000              MOVS     r0,#0
0000e8  f88d0009          STRB     r0,[sp,#9]
0000ec  9601              STR      r6,[sp,#4]            ;1507
;;;1511   		GPIO_Init(GPIOA, &GPIO_InitStructure); 
0000ee  a901              ADD      r1,sp,#4
0000f0  4864              LDR      r0,|L10.644|
0000f2  f7fffffe          BL       GPIO_Init
;;;1512   
;;;1513   
;;;1514   	conf.indicators[0].numb=1;
0000f6  4c64              LDR      r4,|L10.648|
;;;1515   	conf.indicators[0].kol_cifr=8;
0000f8  2108              MOVS     r1,#8
;;;1516   	conf.indicators[0].type_ind=0;
0000fa  2000              MOVS     r0,#0
0000fc  7525              STRB     r5,[r4,#0x14]         ;1514
0000fe  7561              STRB     r1,[r4,#0x15]         ;1515
000100  75a0              STRB     r0,[r4,#0x16]
;;;1517   	conf.indicators[0].yark=0x0f;
000102  200f              MOVS     r0,#0xf
000104  75e0              STRB     r0,[r4,#0x17]
;;;1518   	conf.indicators[0].rez_viv=0;   //   
000106  2200              MOVS     r2,#0
000108  7622              STRB     r2,[r4,#0x18]
;;;1519   	conf.indicators[0].chislo=0;
00010a  83a2              STRH     r2,[r4,#0x1c]
;;;1520   	conf.indicators[0].pol_zap=0;
00010c  7662              STRB     r2,[r4,#0x19]
;;;1521   	conf.indicators[0].porog=0xffff;	
00010e  f64f72ff          MOV      r2,#0xffff
000112  f8242f1e          STRH     r2,[r4,#0x1e]!
;;;1522   
;;;1523   // lineika
;;;1524   	conf.indicators[1].numb=2;
;;;1525   	conf.indicators[1].kol_cifr=4;
000116  2304              MOVS     r3,#4
000118  70a7              STRB     r7,[r4,#2]            ;1524
00011a  70e3              STRB     r3,[r4,#3]
;;;1526   	conf.indicators[1].type_ind=0;
00011c  f04f0c00          MOV      r12,#0
000120  f884c004          STRB     r12,[r4,#4]
;;;1527   	conf.indicators[1].yark=0x0f;
000124  7160              STRB     r0,[r4,#5]
;;;1528   	conf.indicators[1].rez_viv=0;   //   
000126  f884c006          STRB     r12,[r4,#6]
;;;1529   	conf.indicators[1].chislo=0;
00012a  f8a4c00a          STRH     r12,[r4,#0xa]
;;;1530   	conf.indicators[1].pol_zap=0;
00012e  f884c007          STRB     r12,[r4,#7]
;;;1531   	conf.indicators[1].porog=0xffff;	
000132  81a2              STRH     r2,[r4,#0xc]
;;;1532   
;;;1533   	conf.indicators[2].numb=3;
000134  73a6              STRB     r6,[r4,#0xe]
;;;1534   	conf.indicators[2].kol_cifr=8;
000136  73e1              STRB     r1,[r4,#0xf]
;;;1535   	conf.indicators[2].type_ind=0;
000138  f884c010          STRB     r12,[r4,#0x10]
;;;1536   	conf.indicators[2].yark=0x0f;
00013c  7460              STRB     r0,[r4,#0x11]
;;;1537   	conf.indicators[2].rez_viv=0;   //   
00013e  f884c012          STRB     r12,[r4,#0x12]
;;;1538   	conf.indicators[2].chislo=0;
000142  f8a4c016          STRH     r12,[r4,#0x16]
;;;1539   	conf.indicators[2].pol_zap=0;
000146  f884c013          STRB     r12,[r4,#0x13]
;;;1540   	conf.indicators[2].porog=0xffff;	
00014a  8322              STRH     r2,[r4,#0x18]
;;;1541   
;;;1542   // time
;;;1543   	conf.indicators[3].numb=4;
00014c  76a3              STRB     r3,[r4,#0x1a]
;;;1544   	conf.indicators[3].kol_cifr=4;
00014e  76e3              STRB     r3,[r4,#0x1b]
;;;1545   	conf.indicators[3].type_ind=0;
000150  2300              MOVS     r3,#0
000152  7723              STRB     r3,[r4,#0x1c]
;;;1546   	conf.indicators[3].yark=0x0f;
000154  7760              STRB     r0,[r4,#0x1d]
;;;1547   	conf.indicators[3].rez_viv=0;   //   
000156  77a3              STRB     r3,[r4,#0x1e]
;;;1548   	conf.indicators[3].chislo=0;
000158  8463              STRH     r3,[r4,#0x22]
;;;1549   	conf.indicators[3].pol_zap=0;
00015a  77e3              STRB     r3,[r4,#0x1f]
;;;1550   	conf.indicators[3].porog=0xffff;	
00015c  84a2              STRH     r2,[r4,#0x24]
;;;1551   //test_lin2();
;;;1552    
;;;1553   //	init_ind(indicators[0].numb, indicators[0].kol_cifr, indicators[0].type_ind);
;;;1554   //  init_ind(indicators[1].numb, indicators[1].kol_cifr, indicators[1].type_ind);
;;;1555   
;;;1556   	init_ind(conf.indicators[0].numb, conf.indicators[0].kol_cifr, conf.indicators[0].type_ind);
00015e  461a              MOV      r2,r3
000160  4628              MOV      r0,r5
000162  f7fffffe          BL       init_ind
;;;1557     init_ind(conf.indicators[1].numb, conf.indicators[1].kol_cifr, conf.indicators[1].type_ind);
000166  7922              LDRB     r2,[r4,#4]  ; conf
000168  78e1              LDRB     r1,[r4,#3]  ; conf
00016a  78a0              LDRB     r0,[r4,#2]  ; conf
00016c  f7fffffe          BL       init_ind
;;;1558   	init_ind(conf.indicators[2].numb, conf.indicators[2].kol_cifr, conf.indicators[2].type_ind);
000170  7c22              LDRB     r2,[r4,#0x10]  ; conf
000172  7be1              LDRB     r1,[r4,#0xf]  ; conf
000174  7ba0              LDRB     r0,[r4,#0xe]  ; conf
000176  f7fffffe          BL       init_ind
;;;1559     init_ind(conf.indicators[3].numb, conf.indicators[3].kol_cifr, conf.indicators[3].type_ind);
00017a  7f22              LDRB     r2,[r4,#0x1c]  ; conf
00017c  7ee1              LDRB     r1,[r4,#0x1b]  ; conf
00017e  7ea0              LDRB     r0,[r4,#0x1a]  ; conf
000180  f7fffffe          BL       init_ind
;;;1560   
;;;1561   // nastroika gpio
;;;1562   
;;;1563   //	GPIO_InitTypeDef  GPIO_InitStructure;                 
;;;1564   	RCC_APB2PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE); //port D
000184  2101              MOVS     r1,#1
000186  2008              MOVS     r0,#8
000188  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1565   	GPIO_InitStructure.GPIO_Pin   = tx_pin_en|rx_pin_en;      //  vivod for control mod-rs485
00018c  2018              MOVS     r0,#0x18
;;;1566   	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;     // rezim vivoda
00018e  f88d5008          STRB     r5,[sp,#8]
;;;1567   	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;1568   	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;     //speed
;;;1569   	GPIO_Init(GPIOD, &GPIO_InitStructure);              
000192  4c3e              LDR      r4,|L10.652|
000194  9001              STR      r0,[sp,#4]            ;1566
000196  f88d500a          STRB     r5,[sp,#0xa]          ;1567
00019a  f88d7009          STRB     r7,[sp,#9]            ;1568
00019e  a901              ADD      r1,sp,#4
0001a0  4620              MOV      r0,r4
0001a2  f7fffffe          BL       GPIO_Init
;;;1570   
;;;1571   	UART2Init();
0001a6  f7fffffe          BL       UART2Init
;;;1572   	
;;;1573   	/*
;;;1574   	// nastroika na pereda4y
;;;1575   	GPIO_WriteBit(GPIOD, tx_pin_en, Bit_SET);      // GPIOD 4
;;;1576   	GPIO_WriteBit(GPIOD, rx_pin_en, Bit_SET);    //   GPIOD 3
;;;1577   	GPIOD->ODR ^= tx_pin_en;
;;;1578   */
;;;1579   	// nastroika na priem
;;;1580   	GPIO_WriteBit(GPIOD, tx_pin_en, Bit_SET);      // GPIOD 4
0001aa  2201              MOVS     r2,#1
0001ac  2110              MOVS     r1,#0x10
0001ae  4620              MOV      r0,r4
0001b0  f7fffffe          BL       GPIO_WriteBit
;;;1581   	GPIO_WriteBit(GPIOD, rx_pin_en, Bit_SET);    //   GPIOD 3
0001b4  2201              MOVS     r2,#1
0001b6  2108              MOVS     r1,#8
0001b8  4620              MOV      r0,r4
0001ba  f7fffffe          BL       GPIO_WriteBit
;;;1582   	GPIOD->ODR ^= rx_pin_en;
0001be  4833              LDR      r0,|L10.652|
0001c0  3014              ADDS     r0,r0,#0x14
0001c2  6801              LDR      r1,[r0,#0]
0001c4  f0810108          EOR      r1,r1,#8
0001c8  6001              STR      r1,[r0,#0]
;;;1583   
;;;1584   							GPIO_WriteBit(GPIOD, rx_pin_en, Bit_RESET); 
0001ca  2200              MOVS     r2,#0
0001cc  2108              MOVS     r1,#8
0001ce  4620              MOV      r0,r4
0001d0  f7fffffe          BL       GPIO_WriteBit
;;;1585   			//				USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
;;;1586   
;;;1587   NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn; //?????
0001d4  2026              MOVS     r0,#0x26
0001d6  f88d000c          STRB     r0,[sp,#0xc]
;;;1588   NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //?????????
0001da  2000              MOVS     r0,#0
0001dc  f88d000d          STRB     r0,[sp,#0xd]
;;;1589   NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;//????????? ?????????
0001e0  f88d000e          STRB     r0,[sp,#0xe]
;;;1590   NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //???????? ?????
0001e4  f88d500f          STRB     r5,[sp,#0xf]
;;;1591   NVIC_Init(&NVIC_InitStructure); //??????????????
0001e8  a803              ADD      r0,sp,#0xc
0001ea  f7fffffe          BL       NVIC_Init
;;;1592   
;;;1593   USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);  //???????? ?????? ?????????? ??? ??? ?????
0001ee  4c28              LDR      r4,|L10.656|
0001f0  2201              MOVS     r2,#1
0001f2  f2405125          MOV      r1,#0x525
0001f6  4620              MOV      r0,r4
0001f8  f7fffffe          BL       USART_ITConfig
;;;1594   USART_ITConfig(USART2, USART_IT_TC, ENABLE);  //???????? ?????? ?????????? ??? ??? ?????
0001fc  2201              MOVS     r2,#1
0001fe  f2406126          MOV      r1,#0x626
000202  4620              MOV      r0,r4
000204  f7fffffe          BL       USART_ITConfig
000208  4922              LDR      r1,|L10.660|
00020a  2040              MOVS     r0,#0x40
00020c  f04f24e0          MOV      r4,#0xe000e000
000210  6008              STR      r0,[r1,#0]
;;;1595   
;;;1596   
;;;1597   	NVIC_EnableIRQ (USART2_IRQn); // ????????? ?????????? ?? USART1
;;;1598   	/*
;;;1599     NVIC_EnableIRQ (ADC1_IRQn); // ????????? ?????????? ?? ???
;;;1600     NVIC_DisableIRQ (USART1_IRQn); // ????????? ???????
;;;1601     NVIC_DisableIRQ (ADC1_IRQn); // ??? ??? ????????? ?????????? ????
;;;1602   */
;;;1603   //	SendStringUSART2("start ver 1.0 /0"); 
;;;1604   /*
;;;1605   	txsize=10;
;;;1606   	tekper=0;
;;;1607   	for (i = 0; i < txsize ; i++)
;;;1608     {
;;;1609   		TxBuffer[i]=0x30+i;
;;;1610   	}
;;;1611   	USART_SendData(USART2, 0x3A);
;;;1612   */	
;;;1613   
;;;1614   	STM_EVAL_LEDOff(LED3);
000212  2001              MOVS     r0,#1
000214  f7fffffe          BL       STM_EVAL_LEDOff
;;;1615   	STM_EVAL_LEDOff(LED4);
000218  2000              MOVS     r0,#0
00021a  f7fffffe          BL       STM_EVAL_LEDOff
;;;1616   	STM_EVAL_LEDOff(LED5);
00021e  2002              MOVS     r0,#2
000220  f7fffffe          BL       STM_EVAL_LEDOff
;;;1617   	STM_EVAL_LEDOff(LED6);
000224  2003              MOVS     r0,#3
000226  f7fffffe          BL       STM_EVAL_LEDOff
;;;1618   	
;;;1619     /* SysTick end of count event each 10ms */
;;;1620     RCC_GetClocksFreq(&RCC_Clocks);
00022a  4815              LDR      r0,|L10.640|
00022c  3084              ADDS     r0,r0,#0x84
00022e  f7fffffe          BL       RCC_GetClocksFreq
;;;1621     SysTick_Config(RCC_Clocks.HCLK_Frequency / 100);
000232  4813              LDR      r0,|L10.640|
000234  2164              MOVS     r1,#0x64
000236  3084              ADDS     r0,r0,#0x84
000238  6840              LDR      r0,[r0,#4]  ; RCC_Clocks
00023a  fbb0f0f1          UDIV     r0,r0,r1
00023e  f1b07f80          CMP      r0,#0x1000000
000242  d20a              BCS      |L10.602|
000244  f020407f          BIC      r0,r0,#0xff000000
000248  1e40              SUBS     r0,r0,#1
00024a  6160              STR      r0,[r4,#0x14]
00024c  4912              LDR      r1,|L10.664|
00024e  20f0              MOVS     r0,#0xf0
000250  7008              STRB     r0,[r1,#0]
000252  f8c49018          STR      r9,[r4,#0x18]
000256  f8c48010          STR      r8,[r4,#0x10]
                  |L10.602|
;;;1622   	
;;;1623       while (1)
;;;1624     {
;;;1625       /* Host Task handler */
;;;1626       USBH_Process(&USB_OTG_Core, &USB_Host);
00025a  4909              LDR      r1,|L10.640|
00025c  f5a16096          SUB      r0,r1,#0x4b0
000260  f7fffffe          BL       USBH_Process
000264  e7f9              B        |L10.602|
;;;1627     }
;;;1628     
;;;1629   #endif
;;;1630   	
;;;1631   
;;;1632     
;;;1633   }
;;;1634   
                          ENDP

000266  0000              DCW      0x0000
                  |L10.616|
                          DCD      0x40020800
                  |L10.620|
                          DCD      ||area_number.34||
                  |L10.624|
                          DCD      LED_Toggle
                  |L10.628|
                          DCD      0x40012200
                  |L10.632|
                          DCD      USR_Callbacks
                  |L10.636|
                          DCD      USBH_MSC_cb
                  |L10.640|
                          DCD      ||.bss||+0x4b0
                  |L10.644|
                          DCD      0x40020000
                  |L10.648|
                          DCD      ||.bss||+0x92c
                  |L10.652|
                          DCD      0x40020c00
                  |L10.656|
                          DCD      0x40004400
                  |L10.660|
                          DCD      0xe000e104
                  |L10.664|
                          DCD      0xe000ed23

                          AREA ||i.pin_ind||, CODE, READONLY, ALIGN=1

                  pin_ind PROC
;;;496    
;;;497    uint16_t pin_ind(u8 numb_ind)
000000  4601              MOV      r1,r0
;;;498    {
;;;499    	uint16_t  pin=0;
000002  2000              MOVS     r0,#0
;;;500    
;;;501    			switch (numb_ind-1)
000004  1e49              SUBS     r1,r1,#1
000006  2905              CMP      r1,#5
000008  d205              BCS      |L11.22|
00000a  e8dff001          TBB      [pc,r1]
00000e  0305              DCB      0x03,0x05
000010  07090b00          DCB      0x07,0x09,0x0b,0x00
;;;502    			{
;;;503    				case 0x00:  // CS0
;;;504    					pin=GPIO_Pin_0;
000014  2001              MOVS     r0,#1
                  |L11.22|
;;;505    					break;
;;;506    
;;;507    				case 0x01:  // CS1
;;;508    					pin=GPIO_Pin_1;
;;;509    					break;
;;;510    
;;;511    				case 0x02:  // CS2
;;;512    					pin=GPIO_Pin_2;
;;;513    					break;
;;;514    
;;;515    				case 0x03:  // CS3
;;;516    					pin=GPIO_Pin_3;
;;;517    					break;
;;;518    
;;;519    				case 0x04:  // CS4
;;;520    					pin=GPIO_Pin_4;
;;;521    					break;	
;;;522    				default:
;;;523    					pin=0;
;;;524    					break;
;;;525    			}
;;;526    			
;;;527    			return pin;
;;;528    
;;;529    }
000016  4770              BX       lr
000018  2002              MOVS     r0,#2                 ;508
00001a  4770              BX       lr
00001c  2004              MOVS     r0,#4                 ;512
00001e  4770              BX       lr
000020  2008              MOVS     r0,#8                 ;516
000022  4770              BX       lr
000024  2010              MOVS     r0,#0x10              ;520
000026  4770              BX       lr
;;;530    void indicate_lin(u8 numb_ind,u16 zn, u16 maks, u16 max_kol_st)
                          ENDP


                          AREA ||i.settime||, CODE, READONLY, ALIGN=2

                  settime PROC
;;;262    
;;;263    void settime(void)
000000  480e              LDR      r0,|L12.60|
;;;264    {
;;;265    
;;;266    		RTC->ISR |= RTC_ISR_INIT;
000002  6801              LDR      r1,[r0,#0]
000004  f0410180          ORR      r1,r1,#0x80
000008  6001              STR      r1,[r0,#0]
                  |L12.10|
;;;267        while(!(RTC->ISR & RTC_ISR_INITF)) {}
00000a  6801              LDR      r1,[r0,#0]
00000c  0649              LSLS     r1,r1,#25
00000e  d5fc              BPL      |L12.10|
;;;268    			
;;;269    	//	rtc_SetDate(2, 6, 13, 7);
;;;270    		{
;;;271        uint32_t Tens, Units;
;;;272        uint32_t TempReg = 0;
;;;273    		uint8_t	Day=2,  Month=6,  Year=13,  DayOfWeek=7;
;;;274        
;;;275    
;;;276        TempReg = 0;
;;;277        {
;;;278            Tens  = (Year / 10) & 0x0f;          // ??????? ???
;;;279            Units = (Year - (Tens * 10)) & 0x0f; // ??????? ???
;;;280            
;;;281            TempReg |= (Tens  << 20); // YT, 20
;;;282            TempReg |= (Units << 16); // YU, 16
;;;283        }
;;;284    
;;;285        {
;;;286            Tens  = (Month / 10) & 0x01;          // ??????? ???????
;;;287            Units = (Month - (Tens * 10)) & 0x0f; // ??????? ???????
;;;288            
;;;289            TempReg |= (Tens  << 12); // MT, 12
;;;290            TempReg |= (Units << 8);  // MU, 8
;;;291        }
;;;292    
;;;293        {
;;;294            Tens  = (Day / 10) & 0x03;          // ??????? ????
;;;295            Units = (Day - (Tens * 10)) & 0x0f; // ??????? ????
;;;296            
;;;297            TempReg |= (Tens  << 4); // DT, 4
;;;298            TempReg |= (Units << 0);  // DU, 0
;;;299        }
;;;300    
;;;301        {
;;;302            TempReg |= ((DayOfWeek & 0x07) << 13); // WDU, 13
;;;303        }
;;;304        RTC->DR = TempReg;
000010  4b0a              LDR      r3,|L12.60|
000012  2200              MOVS     r2,#0                 ;286
000014  3b08              SUBS     r3,r3,#8
000016  490a              LDR      r1,|L12.64|
000018  6019              STR      r1,[r3,#0]
;;;305    		}
;;;306    			
;;;307    			
;;;308    //    rtc_SetTime(0, 0, 00);
;;;309    		
;;;310    		{
;;;311    			uint32_t Tens, Units;
;;;312    			uint32_t TempReg = 0;
;;;313    			uint8_t Hours=0,  Minutes=0,  Seconds=0;
;;;314        
;;;315        // ??????? ???? ????
;;;316        TempReg = 0;
;;;317        
;;;318        // ??????? ????
;;;319        {
;;;320            Tens  = (Hours / 10) & 0x03;          // ??????? ?????
;;;321            Units = (Hours - (Tens * 10)) & 0x0f; // ??????? ?????
;;;322            
;;;323            TempReg |= (Tens  << 20); // HT, 20
;;;324            TempReg |= (Units << 16); // HU, 16
;;;325        }
;;;326        // ??????? ??????
;;;327        {
;;;328            Tens  = (Minutes / 10) & 0x07;          // ??????? ?????
;;;329            Units = (Minutes - (Tens * 10)) & 0x0f; // ??????? ?????
;;;330            
;;;331            TempReg |= (Tens  << 12); // MNT, 12
;;;332            TempReg |= (Units << 8);  // MNU, 8
;;;333        }
;;;334        // ??????? ???????
;;;335        {
;;;336            Tens  = (Seconds / 10) & 0x07;          // ??????? ??????
;;;337            Units = (Seconds - (Tens * 10)) & 0x0f; // ??????? ??????
;;;338            
;;;339            TempReg |= (Tens  << 4); // ST, 4
;;;340            TempReg |= (Units << 0);  // SU, 0
;;;341        }
;;;342        
;;;343        // ?????????? ???? ??? ?????
;;;344        RTC->TR = TempReg;
00001a  1f19              SUBS     r1,r3,#4
00001c  600a              STR      r2,[r1,#0]
;;;345    		
;;;346    		}
;;;347            
;;;348        RTC->CR |= RTC_CR_FMT;
00001e  1d19              ADDS     r1,r3,#4
000020  680a              LDR      r2,[r1,#0]
000022  f0420240          ORR      r2,r2,#0x40
000026  600a              STR      r2,[r1,#0]
;;;349        RTC->ISR &= ~RTC_ISR_INIT;
000028  6801              LDR      r1,[r0,#0]
00002a  f0210180          BIC      r1,r1,#0x80
00002e  6001              STR      r1,[r0,#0]
;;;350    		RTC->WPR = 0xFF;
000030  4902              LDR      r1,|L12.60|
000032  20ff              MOVS     r0,#0xff
000034  3118              ADDS     r1,r1,#0x18
000036  6008              STR      r0,[r1,#0]
;;;351    	
;;;352    }
000038  4770              BX       lr
;;;353    
                          ENDP

00003a  0000              DCW      0x0000
                  |L12.60|
                          DCD      0x4000280c
                  |L12.64|
                          DCD      0x0013e602

                          AREA ||i.sohr_backup||, CODE, READONLY, ALIGN=1

                  sohr_backup PROC
;;;353    
;;;354    void sohr_backup(u16 kol_byte,uint8_t* buf)
000000  4770              BX       lr
;;;355    {
;;;356    
;;;357    }
;;;358    
                          ENDP


                          AREA ||i.spi1_init||, CODE, READONLY, ALIGN=2

                  spi1_init PROC
;;;395    
;;;396    void spi1_init() {
000000  b530              PUSH     {r4,r5,lr}
;;;397    	SPI_InitTypeDef spi1;
;;;398    	 GPIO_InitTypeDef gpio;
;;;399    	
;;;400        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);  // ???????????? ?????
000002  2101              MOVS     r1,#1
000004  b087              SUB      sp,sp,#0x1c           ;396
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;401        RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);  // ???????????? SPI1 
00000c  2101              MOVS     r1,#1
00000e  0308              LSLS     r0,r1,#12
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;402       
;;;403        GPIO_StructInit(&gpio);
000014  a805              ADD      r0,sp,#0x14
000016  f7fffffe          BL       GPIO_StructInit
;;;404        gpio.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
00001a  20e0              MOVS     r0,#0xe0
;;;405        gpio.GPIO_Mode = GPIO_Mode_AF;
00001c  9005              STR      r0,[sp,#0x14]
00001e  2002              MOVS     r0,#2
000020  f88d0018          STRB     r0,[sp,#0x18]
;;;406        gpio.GPIO_Speed = GPIO_Speed_2MHz;
000024  2400              MOVS     r4,#0
000026  f88d4019          STRB     r4,[sp,#0x19]
;;;407        gpio.GPIO_OType = GPIO_OType_PP;
00002a  f88d401a          STRB     r4,[sp,#0x1a]
;;;408        gpio.GPIO_PuPd = GPIO_PuPd_DOWN;
;;;409        GPIO_Init(GPIOA,&gpio);
00002e  4d1a              LDR      r5,|L14.152|
000030  f88d001b          STRB     r0,[sp,#0x1b]         ;408
000034  a905              ADD      r1,sp,#0x14
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       GPIO_Init
;;;410        GPIO_PinAFConfig(GPIOA,GPIO_PinSource5,GPIO_AF_SPI1);
00003c  2205              MOVS     r2,#5
00003e  4611              MOV      r1,r2
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       GPIO_PinAFConfig
;;;411        GPIO_PinAFConfig(GPIOA,GPIO_PinSource6,GPIO_AF_SPI1);
000046  2205              MOVS     r2,#5
000048  2106              MOVS     r1,#6
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       GPIO_PinAFConfig
;;;412        GPIO_PinAFConfig(GPIOA,GPIO_PinSource7,GPIO_AF_SPI1);
000050  2205              MOVS     r2,#5
000052  2107              MOVS     r1,#7
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       GPIO_PinAFConfig
;;;413        SPI_I2S_DeInit(SPI1);
00005a  4d10              LDR      r5,|L14.156|
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       SPI_I2S_DeInit
;;;414        
;;;415        SPI_StructInit(&spi1);
000062  4668              MOV      r0,sp
000064  f7fffffe          BL       SPI_StructInit
;;;416        spi1.SPI_Mode = SPI_Mode_Master;
000068  f44f7082          MOV      r0,#0x104
00006c  f8ad0002          STRH     r0,[sp,#2]
;;;417        spi1.SPI_DataSize = SPI_DataSize_8b; //SPI_DataSize_16b;		
;;;418        spi1.SPI_NSS = SPI_NSS_Soft;
000070  1568              ASRS     r0,r5,#21
000072  f8ad000a          STRH     r0,[sp,#0xa]
;;;419    
;;;420      spi1.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;
000076  2038              MOVS     r0,#0x38
000078  f8ad000c          STRH     r0,[sp,#0xc]
00007c  f8ad4004          STRH     r4,[sp,#4]            ;417
;;;421      spi1.SPI_FirstBit = SPI_FirstBit_MSB;
000080  f8ad400e          STRH     r4,[sp,#0xe]
;;;422    	
;;;423        SPI_Init(SPI1,&spi1);
000084  4669              MOV      r1,sp
000086  4628              MOV      r0,r5
000088  f7fffffe          BL       SPI_Init
;;;424        SPI_Cmd(SPI1,ENABLE);
00008c  2101              MOVS     r1,#1
00008e  4628              MOV      r0,r5
000090  f7fffffe          BL       SPI_Cmd
;;;425    }
000094  b007              ADD      sp,sp,#0x1c
000096  bd30              POP      {r4,r5,pc}
;;;426    
                          ENDP

                  |L14.152|
                          DCD      0x40020000
                  |L14.156|
                          DCD      0x40013000

                          AREA ||i.spi2_init||, CODE, READONLY, ALIGN=2

                  spi2_init PROC
;;;427    
;;;428    void spi2_init() {
000000  b530              PUSH     {r4,r5,lr}
000002  b087              SUB      sp,sp,#0x1c
;;;429    	SPI_InitTypeDef spi2;
;;;430    	 GPIO_InitTypeDef gpio;
;;;431    	
;;;432        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB,ENABLE);
000004  2101              MOVS     r1,#1
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;433        RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;434       
;;;435        GPIO_StructInit(&gpio);
000014  a805              ADD      r0,sp,#0x14
000016  f7fffffe          BL       GPIO_StructInit
;;;436        gpio.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
00001a  f44f4060          MOV      r0,#0xe000
;;;437        gpio.GPIO_Mode = GPIO_Mode_AF;
00001e  9005              STR      r0,[sp,#0x14]
000020  2002              MOVS     r0,#2
000022  f88d0018          STRB     r0,[sp,#0x18]
;;;438        gpio.GPIO_Speed = GPIO_Speed_50MHz;
000026  f88d0019          STRB     r0,[sp,#0x19]
;;;439        gpio.GPIO_OType = GPIO_OType_PP;
00002a  2400              MOVS     r4,#0
00002c  f88d401a          STRB     r4,[sp,#0x1a]
;;;440        gpio.GPIO_PuPd = GPIO_PuPd_DOWN;
;;;441        GPIO_Init(GPIOB,&gpio);
000030  4d17              LDR      r5,|L15.144|
000032  f88d001b          STRB     r0,[sp,#0x1b]         ;440
000036  a905              ADD      r1,sp,#0x14
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       GPIO_Init
;;;442        GPIO_PinAFConfig(GPIOB,GPIO_PinSource13,GPIO_AF_SPI2);
00003e  2205              MOVS     r2,#5
000040  210d              MOVS     r1,#0xd
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       GPIO_PinAFConfig
;;;443        GPIO_PinAFConfig(GPIOB,GPIO_PinSource14,GPIO_AF_SPI2);
000048  2205              MOVS     r2,#5
00004a  210e              MOVS     r1,#0xe
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       GPIO_PinAFConfig
;;;444        GPIO_PinAFConfig(GPIOB,GPIO_PinSource15,GPIO_AF_SPI2);
000052  2205              MOVS     r2,#5
000054  210f              MOVS     r1,#0xf
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       GPIO_PinAFConfig
;;;445        SPI_I2S_DeInit(SPI2);
00005c  4d0d              LDR      r5,|L15.148|
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       SPI_I2S_DeInit
;;;446        
;;;447        SPI_StructInit(&spi2);
000064  4668              MOV      r0,sp
000066  f7fffffe          BL       SPI_StructInit
;;;448        spi2.SPI_Mode = SPI_Mode_Slave;
;;;449        spi2.SPI_DataSize = SPI_DataSize_16b;
00006a  14e9              ASRS     r1,r5,#19
;;;450        spi2.SPI_NSS = SPI_NSS_Soft;
00006c  1088              ASRS     r0,r1,#2
00006e  f8ad1004          STRH     r1,[sp,#4]            ;449
000072  f8ad000a          STRH     r0,[sp,#0xa]
000076  f8ad4002          STRH     r4,[sp,#2]            ;448
;;;451        SPI_Init(SPI2,&spi2);
00007a  4669              MOV      r1,sp
00007c  4628              MOV      r0,r5
00007e  f7fffffe          BL       SPI_Init
;;;452        SPI_Cmd(SPI2,ENABLE);
000082  2101              MOVS     r1,#1
000084  4628              MOV      r0,r5
000086  f7fffffe          BL       SPI_Cmd
;;;453    }
00008a  b007              ADD      sp,sp,#0x1c
00008c  bd30              POP      {r4,r5,pc}
;;;454    
                          ENDP

00008e  0000              DCW      0x0000
                  |L15.144|
                          DCD      0x40020400
                  |L15.148|
                          DCD      0x40003800

                          AREA ||i.spi_init||, CODE, READONLY, ALIGN=2

                  spi_init PROC
;;;358    
;;;359    void spi_init(){
000000  b570              PUSH     {r4-r6,lr}
;;;360    
;;;361    		GPIO_InitTypeDef GPIO_InitStructure;
;;;362        GPIO_InitTypeDef gpio;
;;;363    	  SPI_InitTypeDef spi1;
;;;364    	
;;;365        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);  // ???????????? ?????
000002  2101              MOVS     r1,#1
000004  b08a              SUB      sp,sp,#0x28           ;359
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;366        RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);  // ???????????? SPI1
00000c  2101              MOVS     r1,#1
00000e  0308              LSLS     r0,r1,#12
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;367    
;;;368        GPIO_StructInit(&gpio);
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       GPIO_StructInit
;;;369    
;;;370         gpio.GPIO_Pin   = GPIO_Pin_4;   // NSS
00001a  2010              MOVS     r0,#0x10
;;;371         gpio.GPIO_Mode  = GPIO_Mode_OUT;
00001c  9000              STR      r0,[sp,#0]
00001e  2001              MOVS     r0,#1
000020  f88d0004          STRB     r0,[sp,#4]
;;;372         gpio.GPIO_Speed = GPIO_Speed_50MHz;
000024  2402              MOVS     r4,#2
000026  f88d4005          STRB     r4,[sp,#5]
;;;373         gpio.GPIO_OType = GPIO_OType_PP;
00002a  2500              MOVS     r5,#0
;;;374         gpio.GPIO_PuPd  = GPIO_PuPd_NOPULL;
;;;375         GPIO_Init(GPIOA, &GPIO_InitStructure);
00002c  4e20              LDR      r6,|L16.176|
00002e  f88d5006          STRB     r5,[sp,#6]            ;373
000032  f88d5007          STRB     r5,[sp,#7]            ;374
000036  a907              ADD      r1,sp,#0x1c
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       GPIO_Init
;;;376    
;;;377        gpio.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
;;;378        gpio.GPIO_Mode = GPIO_Mode_AF;
00003e  f88d4004          STRB     r4,[sp,#4]
000042  20e0              MOVS     r0,#0xe0              ;377
;;;379        gpio.GPIO_Speed = GPIO_Speed_50MHz;
000044  f88d4005          STRB     r4,[sp,#5]
000048  9000              STR      r0,[sp,#0]            ;378
;;;380        gpio.GPIO_OType = GPIO_OType_PP;
00004a  f88d5006          STRB     r5,[sp,#6]
;;;381        gpio.GPIO_PuPd = GPIO_PuPd_DOWN;
00004e  f88d4007          STRB     r4,[sp,#7]
;;;382        GPIO_Init(GPIOA,&gpio);
000052  4669              MOV      r1,sp
000054  4630              MOV      r0,r6
000056  f7fffffe          BL       GPIO_Init
;;;383        GPIO_PinAFConfig(GPIOA,GPIO_PinSource5,GPIO_AF_SPI1);   
00005a  2205              MOVS     r2,#5
00005c  4611              MOV      r1,r2
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       GPIO_PinAFConfig
;;;384        GPIO_PinAFConfig(GPIOA,GPIO_PinSource6,GPIO_AF_SPI1);
000064  2205              MOVS     r2,#5
000066  2106              MOVS     r1,#6
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       GPIO_PinAFConfig
;;;385        GPIO_PinAFConfig(GPIOA,GPIO_PinSource7,GPIO_AF_SPI1);
00006e  2205              MOVS     r2,#5
000070  2107              MOVS     r1,#7
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       GPIO_PinAFConfig
;;;386        SPI_I2S_DeInit(SPI1);
000078  4c0e              LDR      r4,|L16.180|
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       SPI_I2S_DeInit
;;;387    
;;;388        SPI_StructInit(&spi1);
000080  a802              ADD      r0,sp,#8
000082  f7fffffe          BL       SPI_StructInit
;;;389        spi1.SPI_Mode = SPI_Mode_Master;
000086  f44f7182          MOV      r1,#0x104
00008a  f8ad100a          STRH     r1,[sp,#0xa]
;;;390        spi1.SPI_DataSize = SPI_DataSize_16b;
00008e  14e1              ASRS     r1,r4,#19
000090  f8ad100c          STRH     r1,[sp,#0xc]
;;;391        spi1.SPI_NSS = SPI_NSS_Soft;
000094  1089              ASRS     r1,r1,#2
000096  f8ad1012          STRH     r1,[sp,#0x12]
;;;392        SPI_Init(SPI1,&spi1);
00009a  a902              ADD      r1,sp,#8
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       SPI_Init
;;;393        SPI_Cmd(SPI1,ENABLE);
0000a2  2101              MOVS     r1,#1
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       SPI_Cmd
;;;394    }
0000aa  b00a              ADD      sp,sp,#0x28
0000ac  bd70              POP      {r4-r6,pc}
;;;395    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L16.176|
                          DCD      0x40020000
                  |L16.180|
                          DCD      0x40013000

                          AREA ||i.spi_receve||, CODE, READONLY, ALIGN=2

                  spi_receve PROC
;;;459    }
;;;460    uint16_t spi_receve() {
000000  b510              PUSH     {r4,lr}
;;;461    		uint16_t received;
;;;462        while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET);  // ???? ???? ?????? ???????
000002  4c06              LDR      r4,|L17.28|
                  |L17.4|
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L17.4|
;;;463        received = SPI_I2S_ReceiveData(SPI2);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      SPI_I2S_ReceiveData
;;;464        return received;
;;;465    }
;;;466    
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      0x40003800

                          AREA ||i.spi_send||, CODE, READONLY, ALIGN=2

                  spi_send PROC
;;;455    
;;;456    void spi_send(uint16_t data) {
000000  b510              PUSH     {r4,lr}
;;;457    	SPI_I2S_SendData(SPI1,data);
000002  4c06              LDR      r4,|L18.28|
000004  4601              MOV      r1,r0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       SPI_I2S_SendData
                  |L18.12|
;;;458        while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE) == RESET);  // ???? ???? ?????? ?????
00000c  2102              MOVS     r1,#2
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       SPI_I2S_GetFlagStatus
000014  2800              CMP      r0,#0
000016  d0f9              BEQ      |L18.12|
;;;459    }
000018  bd10              POP      {r4,pc}
;;;460    uint16_t spi_receve() {
                          ENDP

00001a  0000              DCW      0x0000
                  |L18.28|
                          DCD      0x40013000

                          AREA ||i.test_ind||, CODE, READONLY, ALIGN=2

                  test_ind PROC
;;;1007   
;;;1008   void test_ind(u8 numb_ind)
000000  b570              PUSH     {r4-r6,lr}
;;;1009   {
;;;1010   	uint16_t  pin=0;
;;;1011   	 /*
;;;1012   			switch (numb_ind)
;;;1013   			{
;;;1014   				case 0x00:  // CS0
;;;1015   					pin=GPIO_Pin_0;
;;;1016   					break;
;;;1017   
;;;1018   				case 0x01:  // CS1
;;;1019   					pin=GPIO_Pin_1;
;;;1020   					break;
;;;1021   
;;;1022   				case 0x02:  // CS2
;;;1023   					pin=GPIO_Pin_2;
;;;1024   					break;
;;;1025   
;;;1026   				case 0x03:  // CS3
;;;1027   					pin=GPIO_Pin_3;
;;;1028   					break;
;;;1029   
;;;1030   				case 0x04:  // CS4
;;;1031   					pin=GPIO_Pin_4;
;;;1032   					break;								
;;;1033   			}
;;;1034   			*/
;;;1035   			
;;;1036   			pin=pin_ind(numb_ind);
000002  f7fffffe          BL       pin_ind
000006  0004              MOVS     r4,r0
;;;1037   		if (pin==0)
000008  d01f              BEQ      |L19.74|
;;;1038   				return ;			
;;;1039   
;;;1040   				GPIO_WriteBit(GPIOA, pin, Bit_RESET);      //   GPIOB.2
00000a  4d10              LDR      r5,|L19.76|
00000c  4601              MOV      r1,r0
00000e  2200              MOVS     r2,#0
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       GPIO_WriteBit
;;;1041   				delay_spi(100);
000016  2064              MOVS     r0,#0x64
000018  f7fffffe          BL       delay_spi
;;;1042   				spi_send(0x0f);delay_spi(100);
00001c  200f              MOVS     r0,#0xf
00001e  f7fffffe          BL       spi_send
000022  2064              MOVS     r0,#0x64
000024  f7fffffe          BL       delay_spi
;;;1043   				spi_send(0x01); delay_spi(100);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       spi_send
00002e  2064              MOVS     r0,#0x64
000030  f7fffffe          BL       delay_spi
;;;1044   				GPIO_WriteBit(GPIOA, pin, Bit_SET);      //   GPIOB.2
000034  2201              MOVS     r2,#1
000036  4621              MOV      r1,r4
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       GPIO_WriteBit
;;;1045   				delay_spi(1000);
00003e  e8bd4070          POP      {r4-r6,lr}
000042  f44f707a          MOV      r0,#0x3e8
000046  f7ffbffe          B.W      delay_spi
                  |L19.74|
;;;1046   }
00004a  bd70              POP      {r4-r6,pc}
;;;1047   
                          ENDP

                  |L19.76|
                          DCD      0x40020000

                          AREA ||i.test_ind_all||, CODE, READONLY, ALIGN=2

                  test_ind_all PROC
;;;478    
;;;479    void test_ind_all(void)
000000  b510              PUSH     {r4,lr}
;;;480    {
;;;481    				GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET); 			
000002  4c24              LDR      r4,|L20.148|
000004  2200              MOVS     r2,#0
000006  2101              MOVS     r1,#1
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       GPIO_WriteBit
;;;482    				GPIO_WriteBit(GPIOA, GPIO_Pin_1, Bit_RESET); 
00000e  2200              MOVS     r2,#0
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       GPIO_WriteBit
;;;483    				GPIO_WriteBit(GPIOA, GPIO_Pin_2, Bit_RESET);  			
000018  2200              MOVS     r2,#0
00001a  2104              MOVS     r1,#4
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       GPIO_WriteBit
;;;484    				GPIO_WriteBit(GPIOA, GPIO_Pin_3, Bit_RESET); 
000022  2200              MOVS     r2,#0
000024  2108              MOVS     r1,#8
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       GPIO_WriteBit
;;;485    				GPIO_WriteBit(GPIOA, GPIO_Pin_4, Bit_RESET);     
00002c  2200              MOVS     r2,#0
00002e  2110              MOVS     r1,#0x10
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       GPIO_WriteBit
;;;486    				delay_spi(100);
000036  2064              MOVS     r0,#0x64
000038  f7fffffe          BL       delay_spi
;;;487    				spi_send(0x0f);delay_spi(100);
00003c  200f              MOVS     r0,#0xf
00003e  f7fffffe          BL       spi_send
000042  2064              MOVS     r0,#0x64
000044  f7fffffe          BL       delay_spi
;;;488    				spi_send(0x01); delay_spi(100);
000048  2001              MOVS     r0,#1
00004a  f7fffffe          BL       spi_send
00004e  2064              MOVS     r0,#0x64
000050  f7fffffe          BL       delay_spi
;;;489    				GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET); 			
000054  2201              MOVS     r2,#1
000056  4611              MOV      r1,r2
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       GPIO_WriteBit
;;;490    				GPIO_WriteBit(GPIOA, GPIO_Pin_1, Bit_SET); 
00005e  2201              MOVS     r2,#1
000060  2102              MOVS     r1,#2
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       GPIO_WriteBit
;;;491    				GPIO_WriteBit(GPIOA, GPIO_Pin_2, Bit_SET);  			
000068  2201              MOVS     r2,#1
00006a  2104              MOVS     r1,#4
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       GPIO_WriteBit
;;;492    				GPIO_WriteBit(GPIOA, GPIO_Pin_3, Bit_SET); 
000072  2201              MOVS     r2,#1
000074  2108              MOVS     r1,#8
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       GPIO_WriteBit
;;;493    				GPIO_WriteBit(GPIOA, GPIO_Pin_4, Bit_SET);   
00007c  2201              MOVS     r2,#1
00007e  2110              MOVS     r1,#0x10
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       GPIO_WriteBit
;;;494    				delay_spi(1000);
000086  e8bd4010          POP      {r4,lr}
00008a  f44f707a          MOV      r0,#0x3e8
00008e  f7ffbffe          B.W      delay_spi
;;;495    }
;;;496    
                          ENDP

000092  0000              DCW      0x0000
                  |L20.148|
                          DCD      0x40020000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USB_OTG_Core
                          %        1200
                  USB_Host
                          %        132
                  RCC_Clocks
                          %        16
                  RxBuffer
                          %        500
                  TxBuffer
                          %        500
                  conf
                          %        228

                          AREA ||area_number.23||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.23||, ||.bss||
                  Buf_adc_zap1
                          %        2000

                          AREA ||area_number.24||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.24||, ||.bss||
                  Buf_adc_zap2
                          %        2000

                          AREA ||area_number.25||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.25||, ||.bss||
                  Buf_zap
                          %        6000

                          AREA ||area_number.26||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.26||, ||.bss||
                  average
                          %        20

                          AREA ||area_number.27||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.27||, ||.bss||
                  summa
                          %        20

                          AREA ||area_number.28||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.28||, ||.bss||
                  ||fz||
                          %        20

                          AREA ||area_number.29||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.29||, ||.bss||
                  fz_average
                          %        20

                          AREA ||area_number.30||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.30||, ||.bss||
                  max
                          %        20

                          AREA ||.data||, DATA, ALIGN=0

                  ||in||
000000  00                DCB      0x00

                          AREA ||area_number.33||, DATA, ALIGN=0

                          EXPORTAS ||area_number.33||, ||.data||
                  poz
000000  00                DCB      0x00

                          AREA ||area_number.34||, DATA, ALIGN=2

                          EXPORTAS ||area_number.34||, ||.data||
                  kol
000000  00                DCB      0x00
                  RepeatState
000001  00                DCB      0x00
                  new_komand
000002  0000              DCB      0x00,0x00
                  CCR_Val
000004  41ba              DCW      0x41ba
                  ADC3ConvertedValue
000006  0000              DCW      0x0000
                  txsize
000008  0000              DCB      0x00,0x00
                  rxsize
00000a  0000              DCB      0x00,0x00
                  tekper
00000c  0000              DCB      0x00,0x00
                  tekpr
00000e  0000              DCB      0x00,0x00
                  tmp
                          DCD      0x00000000
                  zad_spi
                          DCD      0x00002710
                  zad_spi2
                          DCD      0x000186a0
                  symb_code
00001c  7e306d79          DCB      0x7e,0x30,0x6d,0x79
000020  335b5f70          DCB      0x33,0x5b,0x5f,0x70
000024  7f7b4f79          DCB      0x7f,0x7b,0x4f,0x79
000028  80                DCB      0x80
                  symb_code_min
000029  7e30ec            DCB      0x7e,0x30,0xec
00002c  f8b2dade          DCB      0xf8,0xb2,0xda,0xde
000030  70feface          DCB      0x70,0xfe,0xfa,0xce
000034  f801              DCB      0xf8,0x01

                          AREA ||area_number.35||, DATA, ALIGN=2

                          EXPORTAS ||area_number.35||, ||.data||
                  tick
                          DCD      0x00000000

                          AREA ||area_number.36||, DATA, ALIGN=0

                          EXPORTAS ||area_number.36||, ||.data||
                  number_buff
000000  00                DCB      0x00

                          AREA ||area_number.37||, DATA, ALIGN=1

                          EXPORTAS ||area_number.37||, ||.data||
                  time_label
000000  0000              DCW      0x0000

                          AREA ||area_number.38||, DATA, ALIGN=1

                          EXPORTAS ||area_number.38||, ||.data||
                  por
000000  0000              DCW      0x0000

                          AREA ||area_number.39||, DATA, ALIGN=0

                          EXPORTAS ||area_number.39||, ||.data||
                  counter
000000  00                DCB      0x00

                          AREA ||area_number.40||, DATA, ALIGN=0

                          EXPORTAS ||area_number.40||, ||.data||
                  tmp1
000000  00                DCB      0x00

                          AREA ||area_number.41||, DATA, ALIGN=0

                          EXPORTAS ||area_number.41||, ||.data||
                  tmp2
000000  00                DCB      0x00

                          AREA ||area_number.42||, DATA, ALIGN=0

                          EXPORTAS ||area_number.42||, ||.data||
                  tmp3
000000  00                DCB      0x00

                          AREA ||area_number.43||, DATA, ALIGN=0

                          EXPORTAS ||area_number.43||, ||.data||
                  tmp4
000000  00                DCB      0x00

                          AREA ||area_number.44||, DATA, ALIGN=0

                          EXPORTAS ||area_number.44||, ||.data||
                  ||sm||
000000  00                DCB      0x00

                          AREA ||area_number.45||, DATA, ALIGN=1

                          EXPORTAS ||area_number.45||, ||.data||
                  ||cnt||
000000  0000              DCW      0x0000

                          AREA ||area_number.46||, DATA, ALIGN=1

                          EXPORTAS ||area_number.46||, ||.data||
                  kol_zap
000000  0000              DCW      0x0000

                          AREA ||area_number.47||, DATA, ALIGN=0

                          EXPORTAS ||area_number.47||, ||.data||
                  file_cr
000000  00                DCB      0x00

                          AREA ||area_number.48||, DATA, ALIGN=0

                          EXPORTAS ||area_number.48||, ||.data||
                  buffering
000000  00                DCB      0x00

                          AREA ||area_number.49||, DATA, ALIGN=1

                          EXPORTAS ||area_number.49||, ||.data||
                  ||del||
000000  0000              DCW      0x0000

                          AREA ||area_number.50||, DATA, ALIGN=1

                          EXPORTAS ||area_number.50||, ||.data||
                  minute
000000  0000              DCW      0x0000

                          AREA ||area_number.51||, DATA, ALIGN=1

                          EXPORTAS ||area_number.51||, ||.data||
                  pred_minute
000000  0000              DCW      0x0000

                          AREA ||area_number.52||, DATA, ALIGN=0

                          EXPORTAS ||area_number.52||, ||.data||
                  sost_pribl
000000  00                DCB      0x00

                          AREA ||area_number.53||, DATA, ALIGN=0

                          EXPORTAS ||area_number.53||, ||.data||
                  kol_average
000000  00                DCB      0x00

                          AREA ||area_number.54||, DATA, ALIGN=0

                          EXPORTAS ||area_number.54||, ||.data||
                  address
000000  01                DCB      0x01

                          AREA ||area_number.55||, DATA, ALIGN=1

                          EXPORTAS ||area_number.55||, ||.data||
                  SPI1_Buffer_Tx
000000  01020304          DCW      0x0102,0x0304
000004  05060708          DCW      0x0506,0x0708
000008  090a0b0c          DCW      0x090a,0x0b0c
00000c  0d0e0f10          DCW      0x0d0e,0x0f10
000010  11121314          DCW      0x1112,0x1314
000014  15161718          DCW      0x1516,0x1718
000018  191a1b1c          DCW      0x191a,0x1b1c
00001c  1d1e1f20          DCW      0x1d1e,0x1f20
000020  21222324          DCW      0x2122,0x2324
000024  25262728          DCW      0x2526,0x2728
000028  292a2b2c          DCW      0x292a,0x2b2c
00002c  2d2e2f30          DCW      0x2d2e,0x2f30
000030  31323334          DCW      0x3132,0x3334
000034  35363738          DCW      0x3536,0x3738
000038  393a3b3c          DCW      0x393a,0x3b3c
00003c  3d3e3f40          DCW      0x3d3e,0x3f40

                          AREA ||area_number.56||, DATA, ALIGN=0

                          EXPORTAS ||area_number.56||, ||.data||
                  smes
000000  00                DCB      0x00

                          AREA ||area_number.57||, DATA, ALIGN=2

                          EXPORTAS ||area_number.57||, ||.data||
                  pr_tick
                          DCD      0x00000000

                          AREA ||area_number.58||, DATA, ALIGN=0

                          EXPORTAS ||area_number.58||, ||.data||
                  DT_zap
                          DCDU     0x00000000
000004  000000            DCB      0x00,0x00,0x00

                          AREA ||area_number.59||, DATA, ALIGN=1

                          EXPORTAS ||area_number.59||, ||.data||
                  bytesWritten
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.60||, DATA, ALIGN=1

                          EXPORTAS ||area_number.60||, ||.data||
                  zad
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.61||, DATA, ALIGN=1

                          EXPORTAS ||area_number.61||, ||.data||
                  ||ms||
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.62||, DATA, ALIGN=1

                          EXPORTAS ||area_number.62||, ||.data||
                  kolkor
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.63||, DATA, ALIGN=1

                          EXPORTAS ||area_number.63||, ||.data||
                  tekkor
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.64||, DATA, ALIGN=1

                          EXPORTAS ||area_number.64||, ||.data||
                  flper
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.65||, DATA, ALIGN=1

                          EXPORTAS ||area_number.65||, ||.data||
                  tmo
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.66||, DATA, ALIGN=1

                          EXPORTAS ||area_number.66||, ||.data||
                  pertmo
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "src\\main.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_main_c_in____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___6_main_c_in____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_main_c_in____REVSH|
#line 128
|__asm___6_main_c_in____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
