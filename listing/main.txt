; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\MEDIA_USB_KEY\main.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\MEDIA_USB_KEY\main.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\MEDIA_USB_KEY\main.crf src\main.c]
                          THUMB

                          AREA ||i.ADC3_CH12_DMA_Config||, CODE, READONLY, ALIGN=2

                  ADC3_CH12_DMA_Config PROC
;;;131    
;;;132    void ADC3_CH12_DMA_Config(void)
000000  b570              PUSH     {r4-r6,lr}
;;;133    {
000002  b09c              SUB      sp,sp,#0x70
;;;134      ADC_InitTypeDef       ADC_InitStructure;
;;;135      ADC_CommonInitTypeDef ADC_CommonInitStructure;
;;;136      DMA_InitTypeDef       DMA_InitStructure;
;;;137      GPIO_InitTypeDef      GPIO_InitStructure;
;;;138    
;;;139      // Enable ADC3, DMA2 and GPIO clocks **************************************
;;;140      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2 | RCC_AHB1Periph_GPIOC, ENABLE);
000004  2101              MOVS     r1,#1
000006  482e              LDR      r0,|L1.192|
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;141      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0288              LSLS     r0,r1,#10
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;142    
;;;143      // DMA2 Stream0 channel0 configuration ************************************
;;;144      DMA_InitStructure.DMA_Channel = DMA_Channel_2;  
000014  f04f6080          MOV      r0,#0x4000000
;;;145      DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC3_DR_ADDRESS;
000018  9000              STR      r0,[sp,#0]
00001a  482a              LDR      r0,|L1.196|
;;;146      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&ADC3ConvertedValue;
00001c  9001              STR      r0,[sp,#4]
00001e  482a              LDR      r0,|L1.200|
;;;147      DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
;;;148      DMA_InitStructure.DMA_BufferSize = 1;
000020  a902              ADD      r1,sp,#8
000022  2400              MOVS     r4,#0                 ;147
000024  2501              MOVS     r5,#1
000026  c131              STM      r1!,{r0,r4,r5}
;;;149      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
;;;150      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;
;;;151      DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
000028  02e8              LSLS     r0,r5,#11
00002a  e9cd4006          STRD     r4,r0,[sp,#0x18]
;;;152      DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
00002e  0080              LSLS     r0,r0,#2
;;;153      DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
000030  9008              STR      r0,[sp,#0x20]
000032  1140              ASRS     r0,r0,#5
;;;154      DMA_InitStructure.DMA_Priority = DMA_Priority_High;
000034  9009              STR      r0,[sp,#0x24]
000036  a90a              ADD      r1,sp,#0x28
000038  9405              STR      r4,[sp,#0x14]         ;151
00003a  0240              LSLS     r0,r0,#9
00003c  c131              STM      r1!,{r0,r4,r5}
;;;155      DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;         
;;;156      DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
;;;157      DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
;;;158      DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
;;;159      DMA_Init(DMA2_Stream0, &DMA_InitStructure);
00003e  4e23              LDR      r6,|L1.204|
000040  940d              STR      r4,[sp,#0x34]         ;158
000042  4669              MOV      r1,sp
000044  4630              MOV      r0,r6
000046  940e              STR      r4,[sp,#0x38]
000048  f7fffffe          BL       DMA_Init
;;;160      DMA_Cmd(DMA2_Stream0, ENABLE);
00004c  2101              MOVS     r1,#1
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       DMA_Cmd
;;;161    
;;;162     // Configure ADC3 Channel12 pin as analog input ****************************
;;;163      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000054  2004              MOVS     r0,#4
;;;164      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
000056  9019              STR      r0,[sp,#0x64]
000058  2003              MOVS     r0,#3
00005a  f88d0068          STRB     r0,[sp,#0x68]
;;;165      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
00005e  f88d406b          STRB     r4,[sp,#0x6b]
;;;166      GPIO_Init(GPIOC, &GPIO_InitStructure);
000062  a919              ADD      r1,sp,#0x64
000064  481a              LDR      r0,|L1.208|
000066  f7fffffe          BL       GPIO_Init
;;;167    
;;;168      // ADC Common Init *********************************************************
;;;169      ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
;;;170      ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
00006a  9415              STR      r4,[sp,#0x54]
;;;171      ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
00006c  9416              STR      r4,[sp,#0x58]
;;;172      ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
00006e  9417              STR      r4,[sp,#0x5c]
;;;173      ADC_CommonInit(&ADC_CommonInitStructure);
000070  a815              ADD      r0,sp,#0x54
000072  9418              STR      r4,[sp,#0x60]
000074  f7fffffe          BL       ADC_CommonInit
;;;174    
;;;175     // ADC3 Init ***************************************************************
;;;176      ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
;;;177      ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000078  940f              STR      r4,[sp,#0x3c]
00007a  f88d4040          STRB     r4,[sp,#0x40]
;;;178      ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
;;;179      ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
;;;180      ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
00007e  9411              STR      r4,[sp,#0x44]
;;;181      ADC_InitStructure.ADC_NbrOfConversion = 1;
000080  9413              STR      r4,[sp,#0x4c]
;;;182      ADC_Init(ADC3, &ADC_InitStructure);
000082  4c10              LDR      r4,|L1.196|
000084  f88d5041          STRB     r5,[sp,#0x41]         ;178
000088  3c4c              SUBS     r4,r4,#0x4c
00008a  f88d5050          STRB     r5,[sp,#0x50]         ;181
00008e  a90f              ADD      r1,sp,#0x3c
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       ADC_Init
;;;183    
;;;184      // ADC3 regular channel12 configuration ***********************************
;;;185      ADC_RegularChannelConfig(ADC3, ADC_Channel_12, 1, ADC_SampleTime_3Cycles);
000096  2300              MOVS     r3,#0
000098  2201              MOVS     r2,#1
00009a  210c              MOVS     r1,#0xc
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       ADC_RegularChannelConfig
;;;186    
;;;187     // Enable DMA request after last transfer (Single-ADC mode)
;;;188      ADC_DMARequestAfterLastTransferCmd(ADC3, ENABLE);
0000a2  2101              MOVS     r1,#1
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       ADC_DMARequestAfterLastTransferCmd
;;;189    
;;;190      // Enable ADC3 DMA 
;;;191      ADC_DMACmd(ADC3, ENABLE);
0000aa  2101              MOVS     r1,#1
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       ADC_DMACmd
;;;192    
;;;193      // Enable ADC3 
;;;194      ADC_Cmd(ADC3, ENABLE);
0000b2  2101              MOVS     r1,#1
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       ADC_Cmd
;;;195    }
0000ba  b01c              ADD      sp,sp,#0x70
0000bc  bd70              POP      {r4-r6,pc}
;;;196    
                          ENDP

0000be  0000              DCW      0x0000
                  |L1.192|
                          DCD      0x00400004
                  |L1.196|
                          DCD      0x4001224c
                  |L1.200|
                          DCD      ||.data||+0xa
                  |L1.204|
                          DCD      0x40026410
                  |L1.208|
                          DCD      0x40020800

                          AREA ||i.TIM_LED_Config||, CODE, READONLY, ALIGN=2

                  TIM_LED_Config PROC
;;;416      */
;;;417    static void TIM_LED_Config(void)
000000  b570              PUSH     {r4-r6,lr}
;;;418    {
000002  b08a              SUB      sp,sp,#0x28
;;;419      TIM_OCInitTypeDef  TIM_OCInitStructure;
;;;420      TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;421      NVIC_InitTypeDef NVIC_InitStructure;
;;;422      uint16_t prescalervalue = 0;
;;;423      
;;;424      /* TIM4 clock enable */
;;;425      RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;426      
;;;427      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
00000c  f44f60a0          MOV      r0,#0x500
000010  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;428      
;;;429      /* Enable the TIM3 gloabal Interrupt */
;;;430      NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;
000014  201e              MOVS     r0,#0x1e
000016  f88d0020          STRB     r0,[sp,#0x20]
;;;431      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00001a  2400              MOVS     r4,#0
00001c  f88d4021          STRB     r4,[sp,#0x21]
;;;432      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000020  f88d4022          STRB     r4,[sp,#0x22]
;;;433      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000024  2501              MOVS     r5,#1
000026  f88d5023          STRB     r5,[sp,#0x23]
;;;434      NVIC_Init(&NVIC_InitStructure);
00002a  a808              ADD      r0,sp,#0x20
00002c  f7fffffe          BL       NVIC_Init
;;;435    
;;;436      /* Initialize Leds mounted on STM324F4-EVAL board */
;;;437      STM_EVAL_LEDInit(LED3);
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       STM_EVAL_LEDInit
;;;438      STM_EVAL_LEDInit(LED4);
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       STM_EVAL_LEDInit
;;;439      STM_EVAL_LEDInit(LED6);
00003c  2003              MOVS     r0,#3
00003e  f7fffffe          BL       STM_EVAL_LEDInit
;;;440      
;;;441      /* Compute the prescaler value */
;;;442      prescalervalue = (uint16_t) ((SystemCoreClock ) / 550000) - 1;
000042  481a              LDR      r0,|L2.172|
000044  491a              LDR      r1,|L2.176|
;;;443      
;;;444      /* Time base configuration */
;;;445      TIM_TimeBaseStructure.TIM_Period = 65535;
;;;446      TIM_TimeBaseStructure.TIM_Prescaler = prescalervalue;
;;;447      TIM_TimeBaseStructure.TIM_ClockDivision = 0;
;;;448      TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
;;;449      TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
000046  4e1b              LDR      r6,|L2.180|
000048  6800              LDR      r0,[r0,#0]            ;442  ; SystemCoreClock
00004a  f8ad401c          STRH     r4,[sp,#0x1c]         ;447
00004e  fbb0f0f1          UDIV     r0,r0,r1              ;442
000052  1e40              SUBS     r0,r0,#1              ;442
000054  f64f71ff          MOV      r1,#0xffff            ;445
000058  f8ad0014          STRH     r0,[sp,#0x14]         ;446
00005c  9106              STR      r1,[sp,#0x18]         ;446
00005e  f8ad4016          STRH     r4,[sp,#0x16]         ;448
000062  a905              ADD      r1,sp,#0x14
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       TIM_TimeBaseInit
;;;450      
;;;451      /* Enable TIM4 Preload register on ARR */
;;;452      TIM_ARRPreloadConfig(TIM4, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  4630              MOV      r0,r6
00006e  f7fffffe          BL       TIM_ARRPreloadConfig
;;;453      
;;;454      /* TIM PWM1 Mode configuration: Channel */
;;;455      TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Timing;
;;;456      TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
;;;457      TIM_OCInitStructure.TIM_Pulse = CCR_Val;
000072  4811              LDR      r0,|L2.184|
000074  f8ad4000          STRH     r4,[sp,#0]            ;455
000078  f8ad5002          STRH     r5,[sp,#2]            ;456
00007c  8900              LDRH     r0,[r0,#8]  ; CCR_Val
;;;458      TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
00007e  9002              STR      r0,[sp,#8]
000080  f8ad400c          STRH     r4,[sp,#0xc]
;;;459      
;;;460      /* Output Compare PWM1 Mode configuration: Channel2 */
;;;461      TIM_OC1Init(TIM4, &TIM_OCInitStructure);
000084  4669              MOV      r1,sp
000086  4630              MOV      r0,r6
000088  f7fffffe          BL       TIM_OC1Init
;;;462      TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Disable);
00008c  2100              MOVS     r1,#0
00008e  4630              MOV      r0,r6
000090  f7fffffe          BL       TIM_OC1PreloadConfig
;;;463        
;;;464      /* TIM Interrupts enable */
;;;465      TIM_ITConfig(TIM4, TIM_IT_CC1 , ENABLE);
000094  2201              MOVS     r2,#1
000096  2102              MOVS     r1,#2
000098  4630              MOV      r0,r6
00009a  f7fffffe          BL       TIM_ITConfig
;;;466      
;;;467      /* TIM4 enable counter */
;;;468      TIM_Cmd(TIM4, ENABLE);
00009e  2101              MOVS     r1,#1
0000a0  4630              MOV      r0,r6
0000a2  f7fffffe          BL       TIM_Cmd
;;;469    }
0000a6  b00a              ADD      sp,sp,#0x28
0000a8  bd70              POP      {r4-r6,pc}
;;;470    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L2.172|
                          DCD      SystemCoreClock
                  |L2.176|
                          DCD      0x00086470
                  |L2.180|
                          DCD      0x40000800
                  |L2.184|
                          DCD      ||.data||

                          AREA ||i.UART2Init||, CODE, READONLY, ALIGN=2

                  UART2Init PROC
;;;197    
;;;198    void UART2Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;199    {
;;;200    
;;;201       GPIO_InitTypeDef GPIO_InitStructure;
;;;202       USART_InitTypeDef USART_InitStructure;
;;;203    
;;;204       RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);    	// 1.
000002  2101              MOVS     r1,#1
000004  b086              SUB      sp,sp,#0x18           ;199
000006  0448              LSLS     r0,r1,#17
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;205       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD,ENABLE); 			// 2.
00000c  2101              MOVS     r1,#1
00000e  2008              MOVS     r0,#8
000010  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;206    
;;;207       GPIO_PinAFConfig  ( GPIOD, GPIO_PinSource5 , GPIO_AF_USART2) ;
000014  4e1c              LDR      r6,|L3.136|
000016  2207              MOVS     r2,#7
000018  2105              MOVS     r1,#5
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       GPIO_PinAFConfig
;;;208       GPIO_PinAFConfig  ( GPIOD, GPIO_PinSource6 , GPIO_AF_USART2) ;   
000020  2207              MOVS     r2,#7
000022  2106              MOVS     r1,#6
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       GPIO_PinAFConfig
;;;209       // 
;;;210       //     //  Tx
;;;211         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
;;;212         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; // alternate function!
00002a  2502              MOVS     r5,#2
00002c  2020              MOVS     r0,#0x20              ;211
00002e  f88d5004          STRB     r5,[sp,#4]
;;;213       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP ;
000032  2400              MOVS     r4,#0
000034  9000              STR      r0,[sp,#0]            ;212
000036  f88d4006          STRB     r4,[sp,#6]
;;;214         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003a  f88d5005          STRB     r5,[sp,#5]
;;;215         GPIO_Init(GPIOD, &GPIO_InitStructure);
00003e  4669              MOV      r1,sp
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       GPIO_Init
;;;216       ////
;;;217    
;;;218       //     // Rx
;;;219         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
000046  2040              MOVS     r0,#0x40
;;;220         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; //GPIO_Mode_IN;
000048  9000              STR      r0,[sp,#0]
00004a  f88d5004          STRB     r5,[sp,#4]
;;;221         GPIO_Init(GPIOD, &GPIO_InitStructure);
00004e  4669              MOV      r1,sp
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       GPIO_Init
;;;222       //
;;;223         USART_InitStructure.USART_BaudRate = 9600;
000056  f44f5016          MOV      r0,#0x2580
;;;224         USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00005a  f8ad400c          STRH     r4,[sp,#0xc]
00005e  9002              STR      r0,[sp,#8]
;;;225         USART_InitStructure.USART_StopBits = USART_StopBits_1;
000060  f8ad400e          STRH     r4,[sp,#0xe]
;;;226         USART_InitStructure.USART_Parity = USART_Parity_No;
000064  f8ad4010          STRH     r4,[sp,#0x10]
;;;227         USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000068  f8ad4014          STRH     r4,[sp,#0x14]
;;;228         USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00006c  200c              MOVS     r0,#0xc
;;;229    
;;;230       USART_Init(USART2, &USART_InitStructure);
00006e  4c07              LDR      r4,|L3.140|
000070  f8ad0012          STRH     r0,[sp,#0x12]         ;228
000074  a902              ADD      r1,sp,#8
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       USART_Init
;;;231    	 
;;;232    	 // enable interrupt on sended data
;;;233    	//	USART_ITConfig(USART2, USART_IT_TC, ENABLE);
;;;234    		// enable interrupt on received data
;;;235    //	  USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//?????????? ?????????? ?? ?????
;;;236    
;;;237    //RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;   //???????????? GPIO
;;;238    //RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;   //???????????? ?????????????? ??????? GPIO
;;;239    //RCC->APB2ENR |= RCC_APB2ENR_USART1EN; //???????????? ?????? USART1
;;;240    
;;;241       USART_Cmd(USART2, ENABLE); // enable USART2
00007c  2101              MOVS     r1,#1
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       USART_Cmd
;;;242    
;;;243    }
000084  b006              ADD      sp,sp,#0x18
000086  bd70              POP      {r4-r6,pc}
;;;244    
                          ENDP

                  |L3.136|
                          DCD      0x40020c00
                  |L3.140|
                          DCD      0x40004400

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;65     
;;;66     void USART2_IRQHandler(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;67     { 
;;;68     
;;;69         	
;;;70     				if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)		  // приняли
000004  4f2e              LDR      r7,|L4.192|
000006  f2405825          MOV      r8,#0x525
00000a  4641              MOV      r1,r8
00000c  4638              MOV      r0,r7
00000e  f7fffffe          BL       USART_GetITStatus
;;;71     					{		u8 tmp=0;
;;;72     						USART_ClearITPendingBit(USART2, USART_IT_RXNE);
;;;73     				
;;;74     						tmp=USART_ReceiveData (USART2);
;;;75     						if (tmp==0x3A)
;;;76     								tekpr=0;
000012  4d2c              LDR      r5,|L4.196|
000014  2600              MOVS     r6,#0                 ;70
000016  b320              CBZ      r0,|L4.98|
000018  4641              MOV      r1,r8                 ;72
00001a  4638              MOV      r0,r7                 ;72
00001c  f7fffffe          BL       USART_ClearITPendingBit
000020  4638              MOV      r0,r7                 ;74
000022  f7fffffe          BL       USART_ReceiveData
000026  b2c4              UXTB     r4,r0                 ;74
000028  2c3a              CMP      r4,#0x3a              ;75
00002a  d003              BEQ      |L4.52|
;;;77     	
;;;78     						if (tekpr==1)
00002c  79a8              LDRB     r0,[r5,#6]  ; tekpr
00002e  2801              CMP      r0,#1
000030  d002              BEQ      |L4.56|
000032  e006              B        |L4.66|
                  |L4.52|
000034  71ae              STRB     r6,[r5,#6]            ;76
000036  e00f              B        |L4.88|
                  |L4.56|
;;;79     								if (tmp!=address)
000038  78a8              LDRB     r0,[r5,#2]  ; address
00003a  4284              CMP      r4,r0
00003c  d001              BEQ      |L4.66|
;;;80     								{
;;;81     									tekpr=0;
00003e  71ae              STRB     r6,[r5,#6]
;;;82     									rxsize=0;
000040  712e              STRB     r6,[r5,#4]
                  |L4.66|
;;;83     								}
;;;84     						
;;;85     						if (tmp==0x0D)
000042  2c0d              CMP      r4,#0xd
000044  d108              BNE      |L4.88|
;;;86     						{
;;;87     							rxsize=tekpr;
000046  79a8              LDRB     r0,[r5,#6]  ; tekpr
000048  7128              STRB     r0,[r5,#4]
;;;88     							USART_ITConfig(USART2, USART_IT_RXNE, DISABLE);
00004a  2200              MOVS     r2,#0
00004c  4641              MOV      r1,r8
00004e  4638              MOV      r0,r7
000050  f7fffffe          BL       USART_ITConfig
;;;89     							new_komand=1;
000054  2001              MOVS     r0,#1
000056  7068              STRB     r0,[r5,#1]
                  |L4.88|
;;;90     						}
;;;91     						RxBuffer[tekpr]=tmp;
000058  491b              LDR      r1,|L4.200|
00005a  79a8              LDRB     r0,[r5,#6]  ; tekpr
00005c  540c              STRB     r4,[r1,r0]
;;;92     						tekpr++;
00005e  1c40              ADDS     r0,r0,#1
000060  71a8              STRB     r0,[r5,#6]
                  |L4.98|
;;;93     				//		GPIOD->ODR ^= tx_pin_en;
;;;94     				//		GPIOD->ODR ^= rx_pin_en;
;;;95     						
;;;96     
;;;97     					}
;;;98     //Transmission complete interrupt								 // чтото передали
;;;99             if(USART_GetITStatus(USART2, USART_IT_TC) != RESET)
000062  f2406426          MOV      r4,#0x626
000066  4621              MOV      r1,r4
000068  4638              MOV      r0,r7
00006a  f7fffffe          BL       USART_GetITStatus
00006e  2800              CMP      r0,#0
000070  d024              BEQ      |L4.188|
;;;100            {
;;;101    		
;;;102    					USART_ClearITPendingBit(USART2, USART_IT_TC);//очищаем признак прерывания
000072  4621              MOV      r1,r4
000074  4638              MOV      r0,r7
000076  f7fffffe          BL       USART_ClearITPendingBit
;;;103    					
;;;104    					if (txsize>tekper)
00007a  78e8              LDRB     r0,[r5,#3]  ; txsize
00007c  7969              LDRB     r1,[r5,#5]  ; tekper
00007e  4288              CMP      r0,r1
000080  d904              BLS      |L4.140|
;;;105    						USART_SendData(USART2,TxBuffer[tekper]);
000082  4811              LDR      r0,|L4.200|
000084  f10000ff          ADD      r0,r0,#0xff
000088  5c41              LDRB     r1,[r0,r1]
00008a  e002              B        |L4.146|
                  |L4.140|
;;;106    					else
;;;107    					{
;;;108    						if (txsize==tekper)
00008c  d105              BNE      |L4.154|
;;;109    								USART_SendData(USART2, 0x0D);
00008e  f04f010d          MOV      r1,#0xd
                  |L4.146|
000092  4638              MOV      r0,r7
000094  f7fffffe          BL       USART_SendData
000098  e009              B        |L4.174|
                  |L4.154|
;;;110    						else
;;;111    						{
;;;112    							GPIO_WriteBit(GPIOD, rx_pin_en, Bit_RESET); 
00009a  2200              MOVS     r2,#0
00009c  2108              MOVS     r1,#8
00009e  480b              LDR      r0,|L4.204|
0000a0  f7fffffe          BL       GPIO_WriteBit
;;;113    							USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
0000a4  2201              MOVS     r2,#1
0000a6  4641              MOV      r1,r8
0000a8  4638              MOV      r0,r7
0000aa  f7fffffe          BL       USART_ITConfig
                  |L4.174|
;;;114    						}
;;;115    						//
;;;116    //						GPIOD->ODR ^= tx_pin_en;
;;;117    		//					GPIOD->ODR ^= rx_pin_en;
;;;118    					}
;;;119    					if (tekper>TxBufferSize-1)
0000ae  7968              LDRB     r0,[r5,#5]  ; tekper
0000b0  28fe              CMP      r0,#0xfe
0000b2  d900              BLS      |L4.182|
;;;120    						tekper=0;
0000b4  716e              STRB     r6,[r5,#5]
                  |L4.182|
;;;121    					tekper++;
0000b6  7968              LDRB     r0,[r5,#5]  ; tekper
0000b8  1c40              ADDS     r0,r0,#1
0000ba  7168              STRB     r0,[r5,#5]
                  |L4.188|
;;;122    					
;;;123    			 
;;;124    					//					GPIOA->BSRR=GPIO_BSRR_BR11|GPIO_BSRR_BR12; // настроиться на прием
;;;125            }
;;;126    
;;;127    
;;;128    
;;;129    }
0000bc  e8bd81f0          POP      {r4-r8,pc}
;;;130    
                          ENDP

                  |L4.192|
                          DCD      0x40004400
                  |L4.196|
                          DCD      ||.data||
                  |L4.200|
                          DCD      ||.bss||+0x544
                  |L4.204|
                          DCD      0x40020c00

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;260    */
;;;261    int main(void)
000000  b088              SUB      sp,sp,#0x20
;;;262    { 
;;;263    	u8 i=0;
;;;264    	GPIO_InitTypeDef GPIO_InitStructure;
;;;265      NVIC_InitTypeDef NVIC_InitStructure;
;;;266      RCC_ClocksTypeDef RCC_ClockFreq;
;;;267    	
;;;268    	TDateTime DT;
;;;269        
;;;270    	 
;;;271      /* This function fills the RCC_ClockFreq structure with the current
;;;272      frequencies of different on chip clocks (for debug purpose) **************/
;;;273      RCC_GetClocksFreq(&RCC_ClockFreq);
000002  a804              ADD      r0,sp,#0x10
000004  f7fffffe          BL       RCC_GetClocksFreq
;;;274      
;;;275      /* Enable Clock Security System(CSS): this will generate an NMI exception
;;;276      when HSE clock fails *****************************************************/
;;;277      RCC_ClockSecuritySystemCmd(ENABLE);
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       RCC_ClockSecuritySystemCmd
;;;278      
;;;279      /* Enable and configure RCC global IRQ channel, will be used to manage HSE ready 
;;;280         and PLL ready interrupts. 
;;;281         These interrupts are enabled in stm32f4xx_it.c file **********************/
;;;282      NVIC_InitStructure.NVIC_IRQChannel = RCC_IRQn;
00000e  2005              MOVS     r0,#5
000010  f88d000c          STRB     r0,[sp,#0xc]
;;;283      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000014  2400              MOVS     r4,#0
000016  f88d400d          STRB     r4,[sp,#0xd]
;;;284      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;  
00001a  f88d400e          STRB     r4,[sp,#0xe]
;;;285      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001e  2501              MOVS     r5,#1
000020  f88d500f          STRB     r5,[sp,#0xf]
;;;286      NVIC_Init(&NVIC_InitStructure);
000024  a803              ADD      r0,sp,#0xc
000026  f7fffffe          BL       NVIC_Init
;;;287    
;;;288      /* Output clock on MCO2 pin(PC9) ****************************************/ 
;;;289      /* Enable the GPIOC peripheral */ 
;;;290      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
00002a  2101              MOVS     r1,#1
00002c  2004              MOVS     r0,#4
00002e  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;291      
;;;292      /* Configure MCO2 pin(PC9) in alternate function */
;;;293      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000032  0268              LSLS     r0,r5,#9
;;;294      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000034  9001              STR      r0,[sp,#4]
000036  2003              MOVS     r0,#3
000038  f88d0009          STRB     r0,[sp,#9]
;;;295      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00003c  2602              MOVS     r6,#2
00003e  f88d6008          STRB     r6,[sp,#8]
;;;296      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000042  f88d400a          STRB     r4,[sp,#0xa]
;;;297      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;  
000046  f88d500b          STRB     r5,[sp,#0xb]
;;;298      GPIO_Init(GPIOC, &GPIO_InitStructure);
00004a  a901              ADD      r1,sp,#4
00004c  4852              LDR      r0,|L5.408|
00004e  f7fffffe          BL       GPIO_Init
;;;299        
;;;300      /* System clock selected to output on MCO2 pin(PC9)*/
;;;301      RCC_MCO2Config(RCC_MCO2Source_SYSCLK, RCC_MCO2Div_2);
000052  0769              LSLS     r1,r5,#29
000054  2000              MOVS     r0,#0
000056  f7fffffe          BL       RCC_MCO2Config
;;;302    
;;;303    
;;;304    
;;;305        // ???????? RTC
;;;306        rtc_Reset();
00005a  f7fffffe          BL       rtc_Reset
;;;307       rtc_Init();
00005e  f7fffffe          BL       rtc_Init
;;;308      //rtc_Init2();
;;;309     		
;;;310    	
;;;311    //	ADC_InitTypeDef  ADC_InitStructure;
;;;312    	
;;;313      /* Initialize LEDS */
;;;314      STM_EVAL_LEDInit(LED3);
000062  2001              MOVS     r0,#1
000064  f7fffffe          BL       STM_EVAL_LEDInit
;;;315      STM_EVAL_LEDInit(LED4);
000068  2000              MOVS     r0,#0
00006a  f7fffffe          BL       STM_EVAL_LEDInit
;;;316      STM_EVAL_LEDInit(LED5);
00006e  2002              MOVS     r0,#2
000070  f7fffffe          BL       STM_EVAL_LEDInit
;;;317      STM_EVAL_LEDInit(LED6);
000074  2003              MOVS     r0,#3
000076  f7fffffe          BL       STM_EVAL_LEDInit
;;;318     
;;;319      /* Green Led On: start of application */
;;;320    	STM_EVAL_LEDOn(LED3);
00007a  2001              MOVS     r0,#1
00007c  f7fffffe          BL       STM_EVAL_LEDOn
;;;321    	STM_EVAL_LEDOn(LED4);
000080  2000              MOVS     r0,#0
000082  f7fffffe          BL       STM_EVAL_LEDOn
;;;322    	STM_EVAL_LEDOn(LED5);
000086  2002              MOVS     r0,#2
000088  f7fffffe          BL       STM_EVAL_LEDOn
;;;323    	STM_EVAL_LEDOn(LED6);
00008c  2003              MOVS     r0,#3
00008e  f7fffffe          BL       STM_EVAL_LEDOn
;;;324           
;;;325      /* SysTick end of count event each 10ms */
;;;326      RCC_GetClocksFreq(&RCC_Clocks);
000092  4842              LDR      r0,|L5.412|
000094  f7fffffe          BL       RCC_GetClocksFreq
;;;327      SysTick_Config(RCC_Clocks.HCLK_Frequency / 100);
000098  4840              LDR      r0,|L5.412|
00009a  2164              MOVS     r1,#0x64
00009c  2707              MOVS     r7,#7
00009e  6840              LDR      r0,[r0,#4]  ; RCC_Clocks
0000a0  fbb0f0f1          UDIV     r0,r0,r1
0000a4  f04f21e0          MOV      r1,#0xe000e000
0000a8  f1b07f80          CMP      r0,#0x1000000
0000ac  d208              BCS      |L5.192|
0000ae  f020407f          BIC      r0,r0,#0xff000000
0000b2  1e40              SUBS     r0,r0,#1
0000b4  6148              STR      r0,[r1,#0x14]
0000b6  4a3a              LDR      r2,|L5.416|
0000b8  20f0              MOVS     r0,#0xf0
0000ba  7010              STRB     r0,[r2,#0]
0000bc  618c              STR      r4,[r1,#0x18]
0000be  610f              STR      r7,[r1,#0x10]
                  |L5.192|
;;;328      
;;;329      /* Configure TIM4 Peripheral to manage LEDs lighting */
;;;330      TIM_LED_Config();
0000c0  f7fffffe          BL       TIM_LED_Config
;;;331      
;;;332      /* Initialize the repeat status */
;;;333      RepeatState = 0;
0000c4  4837              LDR      r0,|L5.420|
0000c6  7004              STRB     r4,[r0,#0]
;;;334      LED_Toggle = 7;
0000c8  4837              LDR      r0,|L5.424|
0000ca  7007              STRB     r7,[r0,#0]
;;;335      
;;;336    	// PC pin2
;;;337      ADC3_CH12_DMA_Config();
0000cc  f7fffffe          BL       ADC3_CH12_DMA_Config
;;;338      // Start ADC3 Software Conversion 
;;;339      ADC_SoftwareStartConv(ADC3);
0000d0  4836              LDR      r0,|L5.428|
0000d2  f7fffffe          BL       ADC_SoftwareStartConv
;;;340    	
;;;341    	
;;;342      
;;;343    #if defined MEDIA_USB_KEY
;;;344      
;;;345      /* Initialize User Button */
;;;346      STM_EVAL_PBInit(BUTTON_USER, BUTTON_MODE_EXTI);
0000d6  2101              MOVS     r1,#1
0000d8  2000              MOVS     r0,#0
0000da  f7fffffe          BL       STM_EVAL_PBInit
;;;347       
;;;348      /* Init Host Library */
;;;349      USBH_Init(&USB_OTG_Core, USB_OTG_FS_CORE_ID, &USB_Host, &USBH_MSC_cb, &USR_Callbacks);
0000de  4a2f              LDR      r2,|L5.412|
0000e0  4833              LDR      r0,|L5.432|
0000e2  3a84              SUBS     r2,r2,#0x84
0000e4  9000              STR      r0,[sp,#0]
0000e6  4b33              LDR      r3,|L5.436|
0000e8  2101              MOVS     r1,#1
0000ea  f5a26096          SUB      r0,r2,#0x4b0
0000ee  f7fffffe          BL       USBH_Init
;;;350      
;;;351    	STM_EVAL_LEDOff(LED3);
0000f2  2001              MOVS     r0,#1
0000f4  f7fffffe          BL       STM_EVAL_LEDOff
;;;352    	STM_EVAL_LEDOff(LED4);
0000f8  2000              MOVS     r0,#0
0000fa  f7fffffe          BL       STM_EVAL_LEDOff
;;;353    	STM_EVAL_LEDOff(LED5);
0000fe  2002              MOVS     r0,#2
000100  f7fffffe          BL       STM_EVAL_LEDOff
;;;354    	STM_EVAL_LEDOff(LED6);
000104  2003              MOVS     r0,#3
000106  f7fffffe          BL       STM_EVAL_LEDOff
;;;355    
;;;356    
;;;357    // nastroika gpio
;;;358    
;;;359    //	GPIO_InitTypeDef  GPIO_InitStructure;                 
;;;360    	RCC_APB2PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE); //port D
00010a  2101              MOVS     r1,#1
00010c  2008              MOVS     r0,#8
00010e  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;361    	GPIO_InitStructure.GPIO_Pin   = tx_pin_en|rx_pin_en;      //  vivod for control mod-rs485
;;;362    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;     // rezim vivoda
000112  f88d5008          STRB     r5,[sp,#8]
;;;363    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
000116  f88d500a          STRB     r5,[sp,#0xa]
;;;364    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;     //speed
00011a  f88d6009          STRB     r6,[sp,#9]
00011e  2018              MOVS     r0,#0x18              ;361
;;;365    	GPIO_Init(GPIOD, &GPIO_InitStructure);              
000120  4e25              LDR      r6,|L5.440|
000122  9001              STR      r0,[sp,#4]            ;362
000124  a901              ADD      r1,sp,#4
000126  4630              MOV      r0,r6
000128  f7fffffe          BL       GPIO_Init
;;;366    
;;;367    	UART2Init();
00012c  f7fffffe          BL       UART2Init
;;;368    	
;;;369    	GPIO_WriteBit(GPIOD, tx_pin_en, Bit_SET);      // GPIOD 4
000130  2201              MOVS     r2,#1
000132  2110              MOVS     r1,#0x10
000134  4630              MOV      r0,r6
000136  f7fffffe          BL       GPIO_WriteBit
;;;370    	GPIO_WriteBit(GPIOD, rx_pin_en, Bit_SET);    //   GPIOD 3
00013a  2201              MOVS     r2,#1
00013c  2108              MOVS     r1,#8
00013e  4630              MOV      r0,r6
000140  f7fffffe          BL       GPIO_WriteBit
;;;371    	GPIOD->ODR ^= tx_pin_en;
000144  481c              LDR      r0,|L5.440|
000146  3014              ADDS     r0,r0,#0x14
000148  6801              LDR      r1,[r0,#0]
00014a  f0810110          EOR      r1,r1,#0x10
00014e  6001              STR      r1,[r0,#0]
;;;372    
;;;373    	
;;;374    
;;;375    NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn; //?????
000150  2026              MOVS     r0,#0x26
000152  f88d000c          STRB     r0,[sp,#0xc]
;;;376    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //?????????
000156  f88d400d          STRB     r4,[sp,#0xd]
;;;377    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;//????????? ?????????
00015a  f88d400e          STRB     r4,[sp,#0xe]
;;;378    NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //???????? ?????
00015e  f88d500f          STRB     r5,[sp,#0xf]
;;;379    NVIC_Init(&NVIC_InitStructure); //??????????????
000162  a803              ADD      r0,sp,#0xc
000164  f7fffffe          BL       NVIC_Init
;;;380    USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);  //???????? ?????? ?????????? ??? ??? ?????
000168  4c14              LDR      r4,|L5.444|
00016a  2201              MOVS     r2,#1
00016c  f2405125          MOV      r1,#0x525
000170  4620              MOV      r0,r4
000172  f7fffffe          BL       USART_ITConfig
;;;381    USART_ITConfig(USART2, USART_IT_TC, ENABLE);  //???????? ?????? ?????????? ??? ??? ?????
000176  2201              MOVS     r2,#1
000178  f2406126          MOV      r1,#0x626
00017c  4620              MOV      r0,r4
00017e  f7fffffe          BL       USART_ITConfig
000182  490f              LDR      r1,|L5.448|
000184  2040              MOVS     r0,#0x40
000186  6008              STR      r0,[r1,#0]
                  |L5.392|
;;;382    
;;;383    
;;;384    	NVIC_EnableIRQ (USART2_IRQn); // ????????? ?????????? ?? USART1
;;;385    	/*
;;;386      NVIC_EnableIRQ (ADC1_IRQn); // ????????? ?????????? ?? ???
;;;387      NVIC_DisableIRQ (USART1_IRQn); // ????????? ???????
;;;388      NVIC_DisableIRQ (ADC1_IRQn); // ??? ??? ????????? ?????????? ????
;;;389    */
;;;390    //	SendStringUSART2("start ver 1.0 /0"); 
;;;391    /*
;;;392    	txsize=10;
;;;393    	tekper=0;
;;;394    	for (i = 0; i < txsize ; i++)
;;;395      {
;;;396    		TxBuffer[i]=0x30+i;
;;;397    	}
;;;398    	USART_SendData(USART2, 0x3A);
;;;399    */	
;;;400        while (1)
;;;401      {
;;;402        /* Host Task handler */
;;;403        USBH_Process(&USB_OTG_Core, &USB_Host);
000188  4904              LDR      r1,|L5.412|
00018a  3984              SUBS     r1,r1,#0x84
00018c  f5a16096          SUB      r0,r1,#0x4b0
000190  f7fffffe          BL       USBH_Process
000194  e7f8              B        |L5.392|
;;;404      }
;;;405      
;;;406    #endif
;;;407    	
;;;408    
;;;409      
;;;410    }
;;;411    
                          ENDP

000196  0000              DCW      0x0000
                  |L5.408|
                          DCD      0x40020800
                  |L5.412|
                          DCD      ||.bss||+0x534
                  |L5.416|
                          DCD      0xe000ed23
                  |L5.420|
                          DCD      ||.data||
                  |L5.424|
                          DCD      LED_Toggle
                  |L5.428|
                          DCD      0x40012200
                  |L5.432|
                          DCD      USR_Callbacks
                  |L5.436|
                          DCD      USBH_MSC_cb
                  |L5.440|
                          DCD      0x40020c00
                  |L5.444|
                          DCD      0x40004400
                  |L5.448|
                          DCD      0xe000e104

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USB_OTG_Core
                          %        1200
                  USB_Host
                          %        132
                  RCC_Clocks
                          %        16
                  RxBuffer
                          %        255
                  TxBuffer
                          %        255

                          AREA ||area_number.8||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.8||, ||.bss||
                  kor
                          %        80

                          AREA ||area_number.9||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.9||, ||.bss||
                  Buf_adc_zap1
                          %        2000

                          AREA ||area_number.10||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.10||, ||.bss||
                  Buf_adc_zap2
                          %        2000

                          AREA ||area_number.11||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.11||, ||.bss||
                  Buf_zap
                          %        6000

                          AREA ||area_number.12||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.12||, ||.bss||
                  average
                          %        20

                          AREA ||area_number.13||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.13||, ||.bss||
                  summa
                          %        20

                          AREA ||area_number.14||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.14||, ||.bss||
                  ||fz||
                          %        20

                          AREA ||area_number.15||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.15||, ||.bss||
                  fz_average
                          %        20

                          AREA ||area_number.16||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.16||, ||.bss||
                  max
                          %        20

                          AREA ||.data||, DATA, ALIGN=1

                  RepeatState
000000  00                DCB      0x00
                  new_komand
000001  00                DCB      0x00
                  address
000002  01                DCB      0x01
                  txsize
000003  00                DCB      0x00
                  rxsize
000004  00                DCB      0x00
                  tekper
000005  00                DCB      0x00
                  tekpr
000006  0000              DCB      0x00,0x00
                  CCR_Val
000008  41ba              DCW      0x41ba
                  ADC3ConvertedValue
00000a  0000              DCW      0x0000

                          AREA ||area_number.19||, DATA, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.data||
                  tick
                          DCD      0x00000000

                          AREA ||area_number.20||, DATA, ALIGN=0

                          EXPORTAS ||area_number.20||, ||.data||
                  number_buff
000000  00                DCB      0x00

                          AREA ||area_number.21||, DATA, ALIGN=1

                          EXPORTAS ||area_number.21||, ||.data||
                  time_label
000000  0000              DCW      0x0000

                          AREA ||area_number.22||, DATA, ALIGN=1

                          EXPORTAS ||area_number.22||, ||.data||
                  por
000000  0000              DCW      0x0000

                          AREA ||area_number.23||, DATA, ALIGN=0

                          EXPORTAS ||area_number.23||, ||.data||
                  counter
000000  00                DCB      0x00

                          AREA ||area_number.24||, DATA, ALIGN=0

                          EXPORTAS ||area_number.24||, ||.data||
                  tmp1
000000  00                DCB      0x00

                          AREA ||area_number.25||, DATA, ALIGN=0

                          EXPORTAS ||area_number.25||, ||.data||
                  tmp2
000000  00                DCB      0x00

                          AREA ||area_number.26||, DATA, ALIGN=0

                          EXPORTAS ||area_number.26||, ||.data||
                  tmp3
000000  00                DCB      0x00

                          AREA ||area_number.27||, DATA, ALIGN=0

                          EXPORTAS ||area_number.27||, ||.data||
                  tmp4
000000  00                DCB      0x00

                          AREA ||area_number.28||, DATA, ALIGN=0

                          EXPORTAS ||area_number.28||, ||.data||
                  ||sm||
000000  00                DCB      0x00

                          AREA ||area_number.29||, DATA, ALIGN=1

                          EXPORTAS ||area_number.29||, ||.data||
                  ||cnt||
000000  0000              DCW      0x0000

                          AREA ||area_number.30||, DATA, ALIGN=1

                          EXPORTAS ||area_number.30||, ||.data||
                  kol_zap
000000  0000              DCW      0x0000

                          AREA ||area_number.31||, DATA, ALIGN=0

                          EXPORTAS ||area_number.31||, ||.data||
                  file_cr
000000  00                DCB      0x00

                          AREA ||area_number.32||, DATA, ALIGN=0

                          EXPORTAS ||area_number.32||, ||.data||
                  buffering
000000  00                DCB      0x00

                          AREA ||area_number.33||, DATA, ALIGN=1

                          EXPORTAS ||area_number.33||, ||.data||
                  ||del||
000000  0000              DCW      0x0000

                          AREA ||area_number.34||, DATA, ALIGN=1

                          EXPORTAS ||area_number.34||, ||.data||
                  minute
000000  0000              DCW      0x0000

                          AREA ||area_number.35||, DATA, ALIGN=1

                          EXPORTAS ||area_number.35||, ||.data||
                  pred_minute
000000  0000              DCW      0x0000

                          AREA ||area_number.36||, DATA, ALIGN=0

                          EXPORTAS ||area_number.36||, ||.data||
                  kol_average
000000  00                DCB      0x00

                          AREA ||area_number.37||, DATA, ALIGN=0

                          EXPORTAS ||area_number.37||, ||.data||
                  DT_zap
                          DCDU     0x00000000
000004  000000            DCB      0x00,0x00,0x00

                          AREA ||area_number.38||, DATA, ALIGN=1

                          EXPORTAS ||area_number.38||, ||.data||
                  bytesWritten
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.39||, DATA, ALIGN=1

                          EXPORTAS ||area_number.39||, ||.data||
                  zad
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.40||, DATA, ALIGN=1

                          EXPORTAS ||area_number.40||, ||.data||
                  ||ms||
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.41||, DATA, ALIGN=1

                          EXPORTAS ||area_number.41||, ||.data||
                  kolkor
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.42||, DATA, ALIGN=1

                          EXPORTAS ||area_number.42||, ||.data||
                  tekkor
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.43||, DATA, ALIGN=1

                          EXPORTAS ||area_number.43||, ||.data||
                  flper
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.44||, DATA, ALIGN=1

                          EXPORTAS ||area_number.44||, ||.data||
                  tmo
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.45||, DATA, ALIGN=1

                          EXPORTAS ||area_number.45||, ||.data||
                  pertmo
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "src\\main.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_main_c_0d317553____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___6_main_c_0d317553____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_main_c_0d317553____REVSH|
#line 128
|__asm___6_main_c_0d317553____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
