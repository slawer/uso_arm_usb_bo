; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\MEDIA_USB_KEY\main.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\MEDIA_USB_KEY\main.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\MEDIA_USB_KEY\main.crf src\main.c]
                          THUMB

                          AREA ||i.ADC3_CH12_DMA_Config||, CODE, READONLY, ALIGN=2

                  ADC3_CH12_DMA_Config PROC
;;;139    
;;;140    void ADC3_CH12_DMA_Config(void)
000000  b570              PUSH     {r4-r6,lr}
;;;141    {
000002  b09c              SUB      sp,sp,#0x70
;;;142      ADC_InitTypeDef       ADC_InitStructure;
;;;143      ADC_CommonInitTypeDef ADC_CommonInitStructure;
;;;144      DMA_InitTypeDef       DMA_InitStructure;
;;;145      GPIO_InitTypeDef      GPIO_InitStructure;
;;;146    
;;;147      // Enable ADC3, DMA2 and GPIO clocks **************************************
;;;148      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2 | RCC_AHB1Periph_GPIOC, ENABLE);
000004  2101              MOVS     r1,#1
000006  482e              LDR      r0,|L1.192|
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;149      RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0288              LSLS     r0,r1,#10
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;150    
;;;151      // DMA2 Stream0 channel0 configuration ************************************
;;;152      DMA_InitStructure.DMA_Channel = DMA_Channel_2;  
000014  f04f6080          MOV      r0,#0x4000000
;;;153      DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)ADC3_DR_ADDRESS;
000018  9000              STR      r0,[sp,#0]
00001a  482a              LDR      r0,|L1.196|
;;;154      DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&ADC3ConvertedValue;
00001c  9001              STR      r0,[sp,#4]
00001e  482a              LDR      r0,|L1.200|
;;;155      DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
;;;156      DMA_InitStructure.DMA_BufferSize = 1;
000020  a902              ADD      r1,sp,#8
000022  2400              MOVS     r4,#0                 ;155
000024  2501              MOVS     r5,#1
000026  c131              STM      r1!,{r0,r4,r5}
;;;157      DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
;;;158      DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;
;;;159      DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
000028  02e8              LSLS     r0,r5,#11
00002a  e9cd4006          STRD     r4,r0,[sp,#0x18]
;;;160      DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
00002e  0080              LSLS     r0,r0,#2
;;;161      DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
000030  9008              STR      r0,[sp,#0x20]
000032  1140              ASRS     r0,r0,#5
;;;162      DMA_InitStructure.DMA_Priority = DMA_Priority_High;
000034  9009              STR      r0,[sp,#0x24]
000036  a90a              ADD      r1,sp,#0x28
000038  9405              STR      r4,[sp,#0x14]         ;159
00003a  0240              LSLS     r0,r0,#9
00003c  c131              STM      r1!,{r0,r4,r5}
;;;163      DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;         
;;;164      DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
;;;165      DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
;;;166      DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
;;;167      DMA_Init(DMA2_Stream0, &DMA_InitStructure);
00003e  4e23              LDR      r6,|L1.204|
000040  940d              STR      r4,[sp,#0x34]         ;166
000042  4669              MOV      r1,sp
000044  4630              MOV      r0,r6
000046  940e              STR      r4,[sp,#0x38]
000048  f7fffffe          BL       DMA_Init
;;;168      DMA_Cmd(DMA2_Stream0, ENABLE);
00004c  2101              MOVS     r1,#1
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       DMA_Cmd
;;;169    
;;;170     // Configure ADC3 Channel12 pin as analog input ****************************
;;;171      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000054  2004              MOVS     r0,#4
;;;172      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AN;
000056  9019              STR      r0,[sp,#0x64]
000058  2003              MOVS     r0,#3
00005a  f88d0068          STRB     r0,[sp,#0x68]
;;;173      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
00005e  f88d406b          STRB     r4,[sp,#0x6b]
;;;174      GPIO_Init(GPIOC, &GPIO_InitStructure);
000062  a919              ADD      r1,sp,#0x64
000064  481a              LDR      r0,|L1.208|
000066  f7fffffe          BL       GPIO_Init
;;;175    
;;;176      // ADC Common Init *********************************************************
;;;177      ADC_CommonInitStructure.ADC_Mode = ADC_Mode_Independent;
;;;178      ADC_CommonInitStructure.ADC_Prescaler = ADC_Prescaler_Div2;
00006a  9415              STR      r4,[sp,#0x54]
;;;179      ADC_CommonInitStructure.ADC_DMAAccessMode = ADC_DMAAccessMode_Disabled;
00006c  9416              STR      r4,[sp,#0x58]
;;;180      ADC_CommonInitStructure.ADC_TwoSamplingDelay = ADC_TwoSamplingDelay_5Cycles;
00006e  9417              STR      r4,[sp,#0x5c]
;;;181      ADC_CommonInit(&ADC_CommonInitStructure);
000070  a815              ADD      r0,sp,#0x54
000072  9418              STR      r4,[sp,#0x60]
000074  f7fffffe          BL       ADC_CommonInit
;;;182    
;;;183     // ADC3 Init ***************************************************************
;;;184      ADC_InitStructure.ADC_Resolution = ADC_Resolution_12b;
;;;185      ADC_InitStructure.ADC_ScanConvMode = DISABLE;
000078  940f              STR      r4,[sp,#0x3c]
00007a  f88d4040          STRB     r4,[sp,#0x40]
;;;186      ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
;;;187      ADC_InitStructure.ADC_ExternalTrigConvEdge = ADC_ExternalTrigConvEdge_None;
;;;188      ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
00007e  9411              STR      r4,[sp,#0x44]
;;;189      ADC_InitStructure.ADC_NbrOfConversion = 1;
000080  9413              STR      r4,[sp,#0x4c]
;;;190      ADC_Init(ADC3, &ADC_InitStructure);
000082  4c10              LDR      r4,|L1.196|
000084  f88d5041          STRB     r5,[sp,#0x41]         ;186
000088  3c4c              SUBS     r4,r4,#0x4c
00008a  f88d5050          STRB     r5,[sp,#0x50]         ;189
00008e  a90f              ADD      r1,sp,#0x3c
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       ADC_Init
;;;191    
;;;192      // ADC3 regular channel12 configuration ***********************************
;;;193      ADC_RegularChannelConfig(ADC3, ADC_Channel_12, 1, ADC_SampleTime_3Cycles);
000096  2300              MOVS     r3,#0
000098  2201              MOVS     r2,#1
00009a  210c              MOVS     r1,#0xc
00009c  4620              MOV      r0,r4
00009e  f7fffffe          BL       ADC_RegularChannelConfig
;;;194    
;;;195     // Enable DMA request after last transfer (Single-ADC mode)
;;;196      ADC_DMARequestAfterLastTransferCmd(ADC3, ENABLE);
0000a2  2101              MOVS     r1,#1
0000a4  4620              MOV      r0,r4
0000a6  f7fffffe          BL       ADC_DMARequestAfterLastTransferCmd
;;;197    
;;;198      // Enable ADC3 DMA 
;;;199      ADC_DMACmd(ADC3, ENABLE);
0000aa  2101              MOVS     r1,#1
0000ac  4620              MOV      r0,r4
0000ae  f7fffffe          BL       ADC_DMACmd
;;;200    
;;;201      // Enable ADC3 
;;;202      ADC_Cmd(ADC3, ENABLE);
0000b2  2101              MOVS     r1,#1
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       ADC_Cmd
;;;203    }
0000ba  b01c              ADD      sp,sp,#0x70
0000bc  bd70              POP      {r4-r6,pc}
;;;204    
                          ENDP

0000be  0000              DCW      0x0000
                  |L1.192|
                          DCD      0x00400004
                  |L1.196|
                          DCD      0x4001224c
                  |L1.200|
                          DCD      ||area_number.37||+0x6
                  |L1.204|
                          DCD      0x40026410
                  |L1.208|
                          DCD      0x40020800

                          AREA ||i.TIM_LED_Config||, CODE, READONLY, ALIGN=2

                  TIM_LED_Config PROC
;;;1779     */
;;;1780   static void TIM_LED_Config(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1781   {
000002  b08a              SUB      sp,sp,#0x28
;;;1782     TIM_OCInitTypeDef  TIM_OCInitStructure;
;;;1783     TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;1784     NVIC_InitTypeDef NVIC_InitStructure;
;;;1785     uint16_t prescalervalue = 0;
;;;1786     
;;;1787     /* TIM4 clock enable */
;;;1788     RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);
000004  2101              MOVS     r1,#1
000006  2004              MOVS     r0,#4
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;1789     
;;;1790     NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
00000c  f44f60a0          MOV      r0,#0x500
000010  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;1791     
;;;1792     /* Enable the TIM3 gloabal Interrupt */
;;;1793     NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;
000014  201e              MOVS     r0,#0x1e
000016  f88d0020          STRB     r0,[sp,#0x20]
;;;1794     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
00001a  2400              MOVS     r4,#0
00001c  f88d4021          STRB     r4,[sp,#0x21]
;;;1795     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
000020  f88d4022          STRB     r4,[sp,#0x22]
;;;1796     NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000024  2501              MOVS     r5,#1
000026  f88d5023          STRB     r5,[sp,#0x23]
;;;1797     NVIC_Init(&NVIC_InitStructure);
00002a  a808              ADD      r0,sp,#0x20
00002c  f7fffffe          BL       NVIC_Init
;;;1798   
;;;1799     /* Initialize Leds mounted on STM324F4-EVAL board */
;;;1800     STM_EVAL_LEDInit(LED3);
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       STM_EVAL_LEDInit
;;;1801     STM_EVAL_LEDInit(LED4);
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       STM_EVAL_LEDInit
;;;1802     STM_EVAL_LEDInit(LED6);
00003c  2003              MOVS     r0,#3
00003e  f7fffffe          BL       STM_EVAL_LEDInit
;;;1803     
;;;1804     /* Compute the prescaler value */
;;;1805     prescalervalue = (uint16_t) ((SystemCoreClock ) / 550000) - 1;
000042  481a              LDR      r0,|L2.172|
000044  491a              LDR      r1,|L2.176|
;;;1806     
;;;1807     /* Time base configuration */
;;;1808     TIM_TimeBaseStructure.TIM_Period = 65535;
;;;1809     TIM_TimeBaseStructure.TIM_Prescaler = prescalervalue;
;;;1810     TIM_TimeBaseStructure.TIM_ClockDivision = 0;
;;;1811     TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
;;;1812     TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
000046  4e1b              LDR      r6,|L2.180|
000048  6800              LDR      r0,[r0,#0]            ;1805  ; SystemCoreClock
00004a  f8ad401c          STRH     r4,[sp,#0x1c]         ;1810
00004e  fbb0f0f1          UDIV     r0,r0,r1              ;1805
000052  1e40              SUBS     r0,r0,#1              ;1805
000054  f64f71ff          MOV      r1,#0xffff            ;1808
000058  f8ad0014          STRH     r0,[sp,#0x14]         ;1809
00005c  9106              STR      r1,[sp,#0x18]         ;1809
00005e  f8ad4016          STRH     r4,[sp,#0x16]         ;1811
000062  a905              ADD      r1,sp,#0x14
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       TIM_TimeBaseInit
;;;1813     
;;;1814     /* Enable TIM4 Preload register on ARR */
;;;1815     TIM_ARRPreloadConfig(TIM4, ENABLE);
00006a  2101              MOVS     r1,#1
00006c  4630              MOV      r0,r6
00006e  f7fffffe          BL       TIM_ARRPreloadConfig
;;;1816     
;;;1817     /* TIM PWM1 Mode configuration: Channel */
;;;1818     TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Timing;
;;;1819     TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
;;;1820     TIM_OCInitStructure.TIM_Pulse = CCR_Val;
000072  4811              LDR      r0,|L2.184|
000074  f8ad4000          STRH     r4,[sp,#0]            ;1818
000078  f8ad5002          STRH     r5,[sp,#2]            ;1819
00007c  8880              LDRH     r0,[r0,#4]  ; CCR_Val
;;;1821     TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
00007e  9002              STR      r0,[sp,#8]
000080  f8ad400c          STRH     r4,[sp,#0xc]
;;;1822     
;;;1823     /* Output Compare PWM1 Mode configuration: Channel2 */
;;;1824     TIM_OC1Init(TIM4, &TIM_OCInitStructure);
000084  4669              MOV      r1,sp
000086  4630              MOV      r0,r6
000088  f7fffffe          BL       TIM_OC1Init
;;;1825     TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Disable);
00008c  2100              MOVS     r1,#0
00008e  4630              MOV      r0,r6
000090  f7fffffe          BL       TIM_OC1PreloadConfig
;;;1826       
;;;1827     /* TIM Interrupts enable */
;;;1828     TIM_ITConfig(TIM4, TIM_IT_CC1 , ENABLE);
000094  2201              MOVS     r2,#1
000096  2102              MOVS     r1,#2
000098  4630              MOV      r0,r6
00009a  f7fffffe          BL       TIM_ITConfig
;;;1829     
;;;1830     /* TIM4 enable counter */
;;;1831     TIM_Cmd(TIM4, ENABLE);
00009e  2101              MOVS     r1,#1
0000a0  4630              MOV      r0,r6
0000a2  f7fffffe          BL       TIM_Cmd
;;;1832   }
0000a6  b00a              ADD      sp,sp,#0x28
0000a8  bd70              POP      {r4-r6,pc}
;;;1833   
                          ENDP

0000aa  0000              DCW      0x0000
                  |L2.172|
                          DCD      SystemCoreClock
                  |L2.176|
                          DCD      0x00086470
                  |L2.180|
                          DCD      0x40000800
                  |L2.184|
                          DCD      ||area_number.37||

                          AREA ||i.UART2Init||, CODE, READONLY, ALIGN=2

                  UART2Init PROC
;;;205    
;;;206    void UART2Init(void)
000000  b570              PUSH     {r4-r6,lr}
;;;207    {
;;;208    
;;;209       GPIO_InitTypeDef GPIO_InitStructure;
;;;210       USART_InitTypeDef USART_InitStructure;
;;;211    
;;;212       RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);    	// 1.
000002  2101              MOVS     r1,#1
000004  b086              SUB      sp,sp,#0x18           ;207
000006  0448              LSLS     r0,r1,#17
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;213       RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD,ENABLE); 			// 2.
00000c  2101              MOVS     r1,#1
00000e  2008              MOVS     r0,#8
000010  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;214    
;;;215       GPIO_PinAFConfig  ( GPIOD, GPIO_PinSource5 , GPIO_AF_USART2) ;
000014  4e1c              LDR      r6,|L3.136|
000016  2207              MOVS     r2,#7
000018  2105              MOVS     r1,#5
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       GPIO_PinAFConfig
;;;216       GPIO_PinAFConfig  ( GPIOD, GPIO_PinSource6 , GPIO_AF_USART2) ;   
000020  2207              MOVS     r2,#7
000022  2106              MOVS     r1,#6
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       GPIO_PinAFConfig
;;;217       // 
;;;218       //     //  Tx
;;;219         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
;;;220         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; // alternate function!
00002a  2502              MOVS     r5,#2
00002c  2020              MOVS     r0,#0x20              ;219
00002e  f88d5004          STRB     r5,[sp,#4]
;;;221       GPIO_InitStructure.GPIO_OType = GPIO_OType_PP ;
000032  2400              MOVS     r4,#0
000034  9000              STR      r0,[sp,#0]            ;220
000036  f88d4006          STRB     r4,[sp,#6]
;;;222         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00003a  f88d5005          STRB     r5,[sp,#5]
;;;223         GPIO_Init(GPIOD, &GPIO_InitStructure);
00003e  4669              MOV      r1,sp
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       GPIO_Init
;;;224       ////
;;;225    
;;;226       //     // Rx
;;;227         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
000046  2040              MOVS     r0,#0x40
;;;228         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF; //GPIO_Mode_IN;
000048  9000              STR      r0,[sp,#0]
00004a  f88d5004          STRB     r5,[sp,#4]
;;;229         GPIO_Init(GPIOD, &GPIO_InitStructure);
00004e  4669              MOV      r1,sp
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       GPIO_Init
;;;230       //
;;;231         USART_InitStructure.USART_BaudRate = 9600;
000056  f44f5016          MOV      r0,#0x2580
;;;232         USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00005a  f8ad400c          STRH     r4,[sp,#0xc]
00005e  9002              STR      r0,[sp,#8]
;;;233         USART_InitStructure.USART_StopBits = USART_StopBits_1;
000060  f8ad400e          STRH     r4,[sp,#0xe]
;;;234         USART_InitStructure.USART_Parity = USART_Parity_No;
000064  f8ad4010          STRH     r4,[sp,#0x10]
;;;235         USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000068  f8ad4014          STRH     r4,[sp,#0x14]
;;;236         USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00006c  200c              MOVS     r0,#0xc
;;;237    
;;;238       USART_Init(USART2, &USART_InitStructure);
00006e  4c07              LDR      r4,|L3.140|
000070  f8ad0012          STRH     r0,[sp,#0x12]         ;236
000074  a902              ADD      r1,sp,#8
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       USART_Init
;;;239    	 
;;;240    	 // enable interrupt on sended data
;;;241    	//	USART_ITConfig(USART2, USART_IT_TC, ENABLE);
;;;242    		// enable interrupt on received data
;;;243    //	  USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//?????????? ?????????? ?? ?????
;;;244    
;;;245    //RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;   //???????????? GPIO
;;;246    //RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;   //???????????? ?????????????? ??????? GPIO
;;;247    //RCC->APB2ENR |= RCC_APB2ENR_USART1EN; //???????????? ?????? USART1
;;;248    
;;;249       USART_Cmd(USART2, ENABLE); // enable USART2
00007c  2101              MOVS     r1,#1
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       USART_Cmd
;;;250    
;;;251    }
000084  b006              ADD      sp,sp,#0x18
000086  bd70              POP      {r4-r6,pc}
;;;252    
                          ENDP

                  |L3.136|
                          DCD      0x40020c00
                  |L3.140|
                          DCD      0x40004400

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;73     
;;;74     void USART2_IRQHandler(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;75     { 
;;;76     
;;;77         	
;;;78     				if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)		  // приняли
000004  4d27              LDR      r5,|L4.164|
000006  f2405825          MOV      r8,#0x525
00000a  4641              MOV      r1,r8
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       USART_GetITStatus
;;;79     					{		u8 tmp=0;
;;;80     						USART_ClearITPendingBit(USART2, USART_IT_RXNE);
;;;81     				
;;;82     						tmp=USART_ReceiveData (USART2);
;;;83     						if (tmp==0x3A)
;;;84     								tekpr=0;
000012  4c25              LDR      r4,|L4.168|
000014  2600              MOVS     r6,#0                 ;78
000016  b1b8              CBZ      r0,|L4.72|
000018  4641              MOV      r1,r8                 ;80
00001a  4628              MOV      r0,r5                 ;80
00001c  f7fffffe          BL       USART_ClearITPendingBit
000020  4628              MOV      r0,r5                 ;82
000022  f7fffffe          BL       USART_ReceiveData
000026  b2c1              UXTB     r1,r0                 ;82
000028  293a              CMP      r1,#0x3a              ;83
00002a  d002              BEQ      |L4.50|
;;;85     	/*
;;;86     						if (tekpr==1)
;;;87     								if (tmp!=address)
;;;88     								{
;;;89     									tekpr=0;
;;;90     									rxsize=0;
;;;91     								}
;;;92     		*/				
;;;93     						if (tmp==0x0D)
00002c  290d              CMP      r1,#0xd
00002e  d002              BEQ      |L4.54|
000030  e005              B        |L4.62|
                  |L4.50|
000032  81e6              STRH     r6,[r4,#0xe]          ;84
000034  e003              B        |L4.62|
                  |L4.54|
;;;94     						{
;;;95     							rxsize=tekpr;
000036  89e0              LDRH     r0,[r4,#0xe]  ; tekpr
000038  8160              STRH     r0,[r4,#0xa]
;;;96     				//			USART_ITConfig(USART2, USART_IT_RXNE, DISABLE);
;;;97     							new_komand=1;
00003a  2001              MOVS     r0,#1
00003c  70a0              STRB     r0,[r4,#2]
                  |L4.62|
;;;98     						}
;;;99     						RxBuffer[tekpr]=tmp;
00003e  4a1b              LDR      r2,|L4.172|
000040  89e0              LDRH     r0,[r4,#0xe]  ; tekpr
000042  5411              STRB     r1,[r2,r0]
;;;100    						tekpr++;
000044  1c40              ADDS     r0,r0,#1
000046  81e0              STRH     r0,[r4,#0xe]
                  |L4.72|
;;;101    				//		GPIOD->ODR ^= tx_pin_en;
;;;102    				//		GPIOD->ODR ^= rx_pin_en;
;;;103    						
;;;104    
;;;105    					}
;;;106    //Transmission complete interrupt								 // чтото передали
;;;107            if(USART_GetITStatus(USART2, USART_IT_TC) != RESET)
000048  f2406726          MOV      r7,#0x626
00004c  4639              MOV      r1,r7
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       USART_GetITStatus
000054  2800              CMP      r0,#0
000056  d023              BEQ      |L4.160|
;;;108            {
;;;109    		
;;;110    					USART_ClearITPendingBit(USART2, USART_IT_TC);//очищаем признак прерывания
000058  4639              MOV      r1,r7
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       USART_ClearITPendingBit
;;;111    					
;;;112    					if (txsize>tekper)
000060  8920              LDRH     r0,[r4,#8]  ; txsize
000062  89a1              LDRH     r1,[r4,#0xc]  ; tekper
000064  4288              CMP      r0,r1
000066  d902              BLS      |L4.110|
;;;113    						USART_SendData(USART2,TxBuffer[tekper]);
000068  4811              LDR      r0,|L4.176|
00006a  5c41              LDRB     r1,[r0,r1]
00006c  e002              B        |L4.116|
                  |L4.110|
;;;114    					else
;;;115    					{
;;;116    						if (txsize==tekper)
00006e  d105              BNE      |L4.124|
;;;117    								USART_SendData(USART2, 0x0D);
000070  f04f010d          MOV      r1,#0xd
                  |L4.116|
000074  4628              MOV      r0,r5
000076  f7fffffe          BL       USART_SendData
00007a  e009              B        |L4.144|
                  |L4.124|
;;;118    						else
;;;119    						{
;;;120    							GPIO_WriteBit(GPIOD, rx_pin_en, Bit_RESET); 
00007c  2200              MOVS     r2,#0
00007e  2108              MOVS     r1,#8
000080  480c              LDR      r0,|L4.180|
000082  f7fffffe          BL       GPIO_WriteBit
;;;121    							USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
000086  2201              MOVS     r2,#1
000088  4641              MOV      r1,r8
00008a  4628              MOV      r0,r5
00008c  f7fffffe          BL       USART_ITConfig
                  |L4.144|
;;;122    						}
;;;123    						//
;;;124    //						GPIOD->ODR ^= tx_pin_en;
;;;125    		//					GPIOD->ODR ^= rx_pin_en;
;;;126    					}
;;;127    					if (tekper>TxBufferSize-1)
000090  89a0              LDRH     r0,[r4,#0xc]  ; tekper
000092  f5b07ffa          CMP      r0,#0x1f4
000096  d300              BCC      |L4.154|
;;;128    						tekper=0;
000098  81a6              STRH     r6,[r4,#0xc]
                  |L4.154|
;;;129    					tekper++;
00009a  89a0              LDRH     r0,[r4,#0xc]  ; tekper
00009c  1c40              ADDS     r0,r0,#1
00009e  81a0              STRH     r0,[r4,#0xc]
                  |L4.160|
;;;130    					
;;;131    			 
;;;132    					//					GPIOA->BSRR=GPIO_BSRR_BR11|GPIO_BSRR_BR12; // настроиться на прием
;;;133            }
;;;134    
;;;135    
;;;136    
;;;137    }
0000a0  e8bd81f0          POP      {r4-r8,pc}
;;;138    
                          ENDP

                  |L4.164|
                          DCD      0x40004400
                  |L4.168|
                          DCD      ||area_number.37||
                  |L4.172|
                          DCD      ||.bss||+0x544
                  |L4.176|
                          DCD      ||.bss||+0x738
                  |L4.180|
                          DCD      0x40020c00

                          AREA ||i.delay_spi||, CODE, READONLY, ALIGN=1

                  delay_spi PROC
;;;469    
;;;470    void delay_spi(u32 kol)
000000  2100              MOVS     r1,#0
;;;471    {
000002  e001              B        |L5.8|
                  |L5.4|
;;;472    	u32 i=0;
;;;473    
;;;474    
;;;475    	for (i=0;i<kol;i++)
;;;476    				__ASM volatile ("nop");
000004  bf00              NOP      
000006  1c49              ADDS     r1,r1,#1              ;475
                  |L5.8|
000008  4281              CMP      r1,r0                 ;475
00000a  d3fb              BCC      |L5.4|
;;;477    }
00000c  4770              BX       lr
;;;478    
                          ENDP


                          AREA ||i.ind_blank_all||, CODE, READONLY, ALIGN=2

                  ind_blank_all PROC
;;;962    
;;;963    void ind_blank_all(u8 numb_ind)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;964    {
;;;965    		u8 i=0,ind=0;
;;;966    		uint16_t  pin=0;
;;;967    	
;;;968    		pin=pin_ind(numb_ind);
000004  f7fffffe          BL       pin_ind
000008  0007              MOVS     r7,r0
;;;969    		if (pin==0)
00000a  d022              BEQ      |L6.82|
;;;970    				return;
;;;971    
;;;972    			for (i=1;i<9;i++)
;;;973    			{
;;;974    				// blank all
;;;975    				GPIO_WriteBit(GPIOA, pin, Bit_RESET);      delay_spi(zad_spi);
00000c  4e12              LDR      r6,|L6.88|
00000e  4d13              LDR      r5,|L6.92|
000010  2401              MOVS     r4,#1                 ;972
                  |L6.18|
000012  2200              MOVS     r2,#0
000014  4639              MOV      r1,r7
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       GPIO_WriteBit
00001c  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
00001e  f7fffffe          BL       delay_spi
;;;976    				spi_send((u8) i);					delay_spi(zad_spi);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       spi_send
000028  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
00002a  f7fffffe          BL       delay_spi
;;;977    				spi_send(0x00);					  delay_spi(zad_spi);			
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       spi_send
000034  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
000036  f7fffffe          BL       delay_spi
;;;978    				GPIO_WriteBit(GPIOA, pin, Bit_SET);      		delay_spi(zad_spi2);
00003a  2201              MOVS     r2,#1
00003c  4639              MOV      r1,r7
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       GPIO_WriteBit
000044  69e8              LDR      r0,[r5,#0x1c]  ; zad_spi2
000046  f7fffffe          BL       delay_spi
00004a  1c64              ADDS     r4,r4,#1              ;972
00004c  b2e4              UXTB     r4,r4                 ;972
00004e  2c09              CMP      r4,#9                 ;972
000050  d3df              BCC      |L6.18|
                  |L6.82|
;;;979    			}
;;;980    		
;;;981    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;982    void init_ind(u8 numb_ind, u8 kol_ind, u8 type_ind)
                          ENDP

000056  0000              DCW      0x0000
                  |L6.88|
                          DCD      0x40020000
                  |L6.92|
                          DCD      ||area_number.37||

                          AREA ||i.indicate||, CODE, READONLY, ALIGN=2

                  indicate PROC
;;;1248   
;;;1249   void indicate(u8 numb_ind,u16 chislo_new, u8 kol_cifr)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1250   {
000004  4616              MOV      r6,r2
000006  460a              MOV      r2,r1
;;;1251   		 	uint16_t  pin=0;
;;;1252   			u16 chislo=chislo_new; //indicators[numb_ind].chislo;
;;;1253   			u8 i=0, zn[6], null=1, simb=0;
000008  f04f0901          MOV      r9,#1
;;;1254   			u32   maximum=0;
;;;1255   			
;;;1256   
;;;1257   			/*
;;;1258   			switch (numb_ind)
;;;1259   			{
;;;1260   				case 0x00:  // CS0
;;;1261   					pin=GPIO_Pin_0;
;;;1262   					break;
;;;1263   
;;;1264   				case 0x01:  // CS1
;;;1265   					pin=GPIO_Pin_1;
;;;1266   					break;
;;;1267   
;;;1268   				case 0x02:  // CS2
;;;1269   					pin=GPIO_Pin_2;
;;;1270   					break;
;;;1271   
;;;1272   				case 0x03:  // CS3
;;;1273   					pin=GPIO_Pin_3;
;;;1274   					break;
;;;1275   
;;;1276   				case 0x04:  // CS4
;;;1277   					pin=GPIO_Pin_4;
;;;1278   					break;								
;;;1279   			}
;;;1280   			*/
;;;1281   			pin=pin_ind(numb_ind);
00000c  f7fffffe          BL       pin_ind
;;;1282   		if (pin==0)
000010  9000              STR      r0,[sp,#0]
000012  2800              CMP      r0,#0
000014  d05d              BEQ      |L7.210|
;;;1283   				return ;
;;;1284   		
;;;1285   	//		switch (conf.indicators[numb_ind-1].kol_cifr)
;;;1286   			switch (kol_cifr)
;;;1287   			{
;;;1288   				case 0x00:  // CS0
;;;1289   					return;
;;;1290   					break;
;;;1291   				case 0x01:  // CS0
;;;1292   					maximum=10;
;;;1293   					break;			
;;;1294   				case 0x02:  // CS0
;;;1295   					maximum=100;
;;;1296   					break;
;;;1297   				case 0x03:  // CS0
;;;1298   					maximum=1000;
;;;1299   					break;
;;;1300   				case 0x04:  // CS0
;;;1301   					maximum=10000;
;;;1302   					break;
;;;1303   				case 0x05:  // CS0
;;;1304   					maximum=100000;
;;;1305   					break;	
;;;1306   				case 0x06:  // CS0
;;;1307   					maximum=1000000;
;;;1308   					break;	
;;;1309   				case 0x07:  // CS0
;;;1310   					maximum=10000000;
;;;1311   					break;	
;;;1312   				case 0x08:  // CS0
;;;1313   					maximum=100000000;
000016  4856              LDR      r0,|L7.368|
000018  2e08              CMP      r6,#8                 ;1286
00001a  d214              BCS      |L7.70|
00001c  e8dff006          TBB      [pc,r6]               ;1286
000020  59040608          DCB      0x59,0x04,0x06,0x08
000024  0b0e1012          DCB      0x0b,0x0e,0x10,0x12
000028  200a              MOVS     r0,#0xa               ;1292
00002a  e00c              B        |L7.70|
00002c  2064              MOVS     r0,#0x64              ;1295
00002e  e00a              B        |L7.70|
000030  f44f707a          MOV      r0,#0x3e8             ;1298
000034  e007              B        |L7.70|
000036  f2427010          MOV      r0,#0x2710            ;1301
00003a  e004              B        |L7.70|
00003c  484d              LDR      r0,|L7.372|
00003e  e002              B        |L7.70|
000040  484d              LDR      r0,|L7.376|
000042  e000              B        |L7.70|
000044  484d              LDR      r0,|L7.380|
                  |L7.70|
;;;1314   					break;					
;;;1315   				default:  // CS0
;;;1316   					maximum=100000000;
;;;1317   					break;					
;;;1318   			}
;;;1319   	
;;;1320   			if (chislo>=maximum)   // reflow
;;;1321   			{			
;;;1322   				GPIO_WriteBit(GPIOA, pin, Bit_RESET);      
000046  f8dfa138          LDR      r10,|L7.384|
;;;1323   				delay_spi(zad_spi);
00004a  4f4e              LDR      r7,|L7.388|
;;;1324   				spi_send(1);delay_spi(zad_spi);
;;;1325   				spi_send(0x4F); delay_spi(zad_spi);		
;;;1326   				GPIO_WriteBit(GPIOA, pin, Bit_SET);      
;;;1327   			  delay_spi(zad_spi2);	
;;;1328   				
;;;1329   		//		for (i=2;i<conf.indicators[numb_ind-1].kol_cifr+1;i++)  {
;;;1330   				for (i=2;i<kol_cifr+1;i++)  {
00004c  f1060801          ADD      r8,r6,#1
000050  4282              CMP      r2,r0                 ;1320
000052  d340              BCC      |L7.214|
000054  2200              MOVS     r2,#0                 ;1322
000056  4655              MOV      r5,r10                ;1322
000058  4650              MOV      r0,r10                ;1322
00005a  9900              LDR      r1,[sp,#0]            ;1322
00005c  f7fffffe          BL       GPIO_WriteBit
000060  69b8              LDR      r0,[r7,#0x18]         ;1323  ; zad_spi
000062  f7fffffe          BL       delay_spi
000066  2001              MOVS     r0,#1                 ;1324
000068  f7fffffe          BL       spi_send
00006c  69b8              LDR      r0,[r7,#0x18]         ;1324  ; zad_spi
00006e  f7fffffe          BL       delay_spi
000072  204f              MOVS     r0,#0x4f              ;1325
000074  f7fffffe          BL       spi_send
000078  69b8              LDR      r0,[r7,#0x18]         ;1325  ; zad_spi
00007a  f7fffffe          BL       delay_spi
00007e  2201              MOVS     r2,#1                 ;1326
000080  4628              MOV      r0,r5                 ;1326
000082  9900              LDR      r1,[sp,#0]            ;1326
000084  f7fffffe          BL       GPIO_WriteBit
000088  69f8              LDR      r0,[r7,#0x1c]         ;1327  ; zad_spi2
00008a  f7fffffe          BL       delay_spi
00008e  2402              MOVS     r4,#2
000090  e01d              B        |L7.206|
                  |L7.146|
;;;1331   				GPIO_WriteBit(GPIOA, pin, Bit_RESET);      
000092  2200              MOVS     r2,#0
000094  4628              MOV      r0,r5
000096  9900              LDR      r1,[sp,#0]
000098  f7fffffe          BL       GPIO_WriteBit
;;;1332   				delay_spi(zad_spi);
00009c  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
00009e  f7fffffe          BL       delay_spi
;;;1333   				spi_send((u8) i);delay_spi(zad_spi);
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       spi_send
0000a8  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
0000aa  f7fffffe          BL       delay_spi
;;;1334   				spi_send(0); delay_spi(zad_spi);		
0000ae  2000              MOVS     r0,#0
0000b0  f7fffffe          BL       spi_send
0000b4  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
0000b6  f7fffffe          BL       delay_spi
;;;1335   				GPIO_WriteBit(GPIOA, pin, Bit_SET);      
0000ba  2201              MOVS     r2,#1
0000bc  4628              MOV      r0,r5
0000be  9900              LDR      r1,[sp,#0]
0000c0  f7fffffe          BL       GPIO_WriteBit
;;;1336   			  delay_spi(zad_spi2);			}					
0000c4  69f8              LDR      r0,[r7,#0x1c]  ; zad_spi2
0000c6  f7fffffe          BL       delay_spi
0000ca  1c64              ADDS     r4,r4,#1              ;1330
0000cc  b2e4              UXTB     r4,r4                 ;1330
                  |L7.206|
0000ce  4544              CMP      r4,r8                 ;1330
0000d0  d3df              BCC      |L7.146|
                  |L7.210|
;;;1337   				return ;
;;;1338   			}	
;;;1339   
;;;1340   			
;;;1341   	//		for (i=conf.indicators[numb_ind-1].kol_cifr;i>0;i--)
;;;1342   			for (i=kol_cifr;i>0;i--)
;;;1343   			{	
;;;1344   					zn[i]=(u8) (chislo%10);
;;;1345   					chislo=chislo/10;
;;;1346   			}
;;;1347   			/*
;;;1348   			zn[0]=0;
;;;1349   			zn[1]=1;
;;;1350   			zn[2]=2;
;;;1351   			zn[3]=3;
;;;1352   			zn[4]=4;
;;;1353   			zn[5]=5;
;;;1354   */
;;;1355   
;;;1356   	//		for (i=1;i<conf.indicators[numb_ind-1].kol_cifr+1;i++)
;;;1357   			for (i=1;i<kol_cifr+1;i++)
;;;1358   			{	
;;;1359   						simb=symb_code[zn[i]];
;;;1360   				
;;;1361   		//				if ((conf.indicators[numb_ind-1].kol_cifr-i)==conf.indicators[numb_ind-1].pol_zap)
;;;1362   				if ((kol_cifr-i)==1)
;;;1363   							simb+=0x80;
;;;1364   				
;;;1365   						if ((simb==0x7E)&(null))
;;;1366   							simb=0;
;;;1367   						else
;;;1368   							null=0;
;;;1369   						
;;;1370   	//					if (i==conf.indicators[numb_ind-1].kol_cifr)
;;;1371   						if (i==kol_cifr)
;;;1372   							simb&=0x7F;
;;;1373   	
;;;1374   						GPIO_WriteBit(GPIOA, pin, Bit_RESET);     	delay_spi(zad_spi);
;;;1375   						spi_send((u8) i);delay_spi(zad_spi);
;;;1376   						spi_send(simb); delay_spi(zad_spi);			
;;;1377   				//		spi_send(symb_code[i]); delay_spi(zad_spi);	
;;;1378   								//  indicators
;;;1379   								//   12.3
;;;1380   						GPIO_WriteBit(GPIOA, pin, Bit_SET);    			delay_spi(zad_spi2);				
;;;1381   			}
;;;1382   }
0000d2  e8bd8ffe          POP      {r1-r11,pc}
                  |L7.214|
0000d6  4630              MOV      r0,r6                 ;1342
0000d8  f10d0b04          ADD      r11,sp,#4             ;1253
0000dc  210a              MOVS     r1,#0xa               ;1292
0000de  e008              B        |L7.242|
                  |L7.224|
0000e0  4613              MOV      r3,r2                 ;1344
0000e2  fbb2f2f1          UDIV     r2,r2,r1              ;1344
0000e6  fb013412          MLS      r4,r1,r2,r3           ;1344
0000ea  f80b4000          STRB     r4,[r11,r0]           ;1344
0000ee  1e40              SUBS     r0,r0,#1              ;1342
0000f0  b2c0              UXTB     r0,r0                 ;1342
                  |L7.242|
0000f2  2800              CMP      r0,#0                 ;1342
0000f4  d1f4              BNE      |L7.224|
0000f6  2501              MOVS     r5,#1                 ;1357
0000f8  e037              B        |L7.362|
                  |L7.250|
0000fa  4922              LDR      r1,|L7.388|
0000fc  f81b0005          LDRB     r0,[r11,r5]           ;1359
000100  3120              ADDS     r1,r1,#0x20           ;1359
000102  5c0c              LDRB     r4,[r1,r0]            ;1359
000104  1b70              SUBS     r0,r6,r5              ;1362
000106  2801              CMP      r0,#1                 ;1362
000108  d101              BNE      |L7.270|
00010a  3480              ADDS     r4,r4,#0x80           ;1363
00010c  b2e4              UXTB     r4,r4                 ;1363
                  |L7.270|
00010e  2c7e              CMP      r4,#0x7e              ;1365
000110  d005              BEQ      |L7.286|
000112  2000              MOVS     r0,#0                 ;1365
                  |L7.276|
000114  ea100f09          TST      r0,r9                 ;1365
000118  d003              BEQ      |L7.290|
00011a  2400              MOVS     r4,#0                 ;1366
00011c  e003              B        |L7.294|
                  |L7.286|
00011e  2001              MOVS     r0,#1                 ;1365
000120  e7f8              B        |L7.276|
                  |L7.290|
000122  f04f0900          MOV      r9,#0                 ;1368
                  |L7.294|
000126  42b5              CMP      r5,r6                 ;1371
000128  d101              BNE      |L7.302|
00012a  f004047f          AND      r4,r4,#0x7f           ;1372
                  |L7.302|
00012e  2200              MOVS     r2,#0                 ;1374
000130  4650              MOV      r0,r10                ;1374
000132  9900              LDR      r1,[sp,#0]            ;1374
000134  f7fffffe          BL       GPIO_WriteBit
000138  69b8              LDR      r0,[r7,#0x18]         ;1374  ; zad_spi
00013a  f7fffffe          BL       delay_spi
00013e  4628              MOV      r0,r5                 ;1375
000140  f7fffffe          BL       spi_send
000144  69b8              LDR      r0,[r7,#0x18]         ;1375  ; zad_spi
000146  f7fffffe          BL       delay_spi
00014a  4620              MOV      r0,r4                 ;1376
00014c  f7fffffe          BL       spi_send
000150  69b8              LDR      r0,[r7,#0x18]         ;1376  ; zad_spi
000152  f7fffffe          BL       delay_spi
000156  2201              MOVS     r2,#1                 ;1380
000158  4650              MOV      r0,r10                ;1380
00015a  9900              LDR      r1,[sp,#0]            ;1380
00015c  f7fffffe          BL       GPIO_WriteBit
000160  69f8              LDR      r0,[r7,#0x1c]         ;1380  ; zad_spi2
000162  f7fffffe          BL       delay_spi
000166  1c6d              ADDS     r5,r5,#1              ;1357
000168  b2ed              UXTB     r5,r5                 ;1357
                  |L7.362|
00016a  4545              CMP      r5,r8                 ;1357
00016c  d3c5              BCC      |L7.250|
00016e  e7b0              B        |L7.210|
;;;1383   
                          ENDP

                  |L7.368|
                          DCD      0x05f5e100
                  |L7.372|
                          DCD      0x000186a0
                  |L7.376|
                          DCD      0x000f4240
                  |L7.380|
                          DCD      0x00989680
                  |L7.384|
                          DCD      0x40020000
                  |L7.388|
                          DCD      ||area_number.37||

                          AREA ||i.indicate_err||, CODE, READONLY, ALIGN=2

                  indicate_err PROC
;;;943    
;;;944    void indicate_err(u8 numb_ind)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;945    {
;;;946    			uint16_t  pin=0;
;;;947    			u8 i=0;
;;;948    	
;;;949    			pin=pin_ind(numb_ind);
000004  f7fffffe          BL       pin_ind
000008  0007              MOVS     r7,r0
;;;950    			if (pin==0)
00000a  d022              BEQ      |L8.82|
;;;951    				return;
;;;952    			
;;;953    			for (i=1;i<9;i++)
;;;954    			{
;;;955    				// error
;;;956    				GPIO_WriteBit(GPIOA, pin, Bit_RESET);      delay_spi(zad_spi);
00000c  4e12              LDR      r6,|L8.88|
00000e  4d13              LDR      r5,|L8.92|
000010  2401              MOVS     r4,#1                 ;953
                  |L8.18|
000012  2200              MOVS     r2,#0
000014  4639              MOV      r1,r7
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       GPIO_WriteBit
00001c  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
00001e  f7fffffe          BL       delay_spi
;;;957    				spi_send((u8) i);					delay_spi(zad_spi);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       spi_send
000028  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
00002a  f7fffffe          BL       delay_spi
;;;958    				spi_send(0x01);					  delay_spi(zad_spi);			
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       spi_send
000034  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
000036  f7fffffe          BL       delay_spi
;;;959    				GPIO_WriteBit(GPIOA, pin, Bit_SET);      		delay_spi(zad_spi2);
00003a  2201              MOVS     r2,#1
00003c  4639              MOV      r1,r7
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       GPIO_WriteBit
000044  69e8              LDR      r0,[r5,#0x1c]  ; zad_spi2
000046  f7fffffe          BL       delay_spi
00004a  1c64              ADDS     r4,r4,#1              ;953
00004c  b2e4              UXTB     r4,r4                 ;953
00004e  2c09              CMP      r4,#9                 ;953
000050  d3df              BCC      |L8.18|
                  |L8.82|
;;;960    			}	
;;;961    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;962    
                          ENDP

000056  0000              DCW      0x0000
                  |L8.88|
                          DCD      0x40020000
                  |L8.92|
                          DCD      ||area_number.37||

                          AREA ||i.indicate_lin||, CODE, READONLY, ALIGN=2

                  indicate_lin PROC
;;;540    }
;;;541    void indicate_lin(u8 numb_ind,u16 zn, u16 maks, u16 max_kol_st)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;542    {
000004  4682              MOV      r10,r0
;;;543    		uint16_t  pin=0;
;;;544    		const u8 tabl[9]={0,1,3,7,0xf,0x1f,0x3f,0x7f,0xff};
000006  a0ab              ADR      r0,|L9.692|
000008  4690              MOV      r8,r2                 ;542
00000a  460e              MOV      r6,r1                 ;542
00000c  e9d01200          LDRD     r1,r2,[r0,#0]
000010  6880              LDR      r0,[r0,#8]
000012  9100              STR      r1,[sp,#0]
000014  e9cd2001          STRD     r2,r0,[sp,#4]
;;;545    		u8 viv=0;
;;;546    		
;;;547    //		u16  zad_spi=1000,zad_spi2=10000;
;;;548    
;;;549    	 tmp=(u32) (max_kol_st*zn);
000018  4fa9              LDR      r7,|L9.704|
00001a  fb03f006          MUL      r0,r3,r6
00001e  461d              MOV      r5,r3                 ;542
;;;550    	fl_tmp=(float) ((float)zn/(float)maks*(float)max_kol_st);
000020  6138              STR      r0,[r7,#0x10]  ; tmp
000022  4618              MOV      r0,r3
000024  f7fffffe          BL       __aeabi_ui2f
000028  4681              MOV      r9,r0
00002a  4640              MOV      r0,r8
00002c  f7fffffe          BL       __aeabi_ui2f
000030  4604              MOV      r4,r0
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       __aeabi_ui2f
000038  4621              MOV      r1,r4
00003a  f7fffffe          BL       __aeabi_fdiv
00003e  4649              MOV      r1,r9
000040  f7fffffe          BL       __aeabi_fmul
;;;551    	fl_tmp+=0.5;
000044  f04f517c          MOV      r1,#0x3f000000
000048  f7fffffe          BL       __aeabi_fadd
;;;552    	 kol=(u8) (fl_tmp);
00004c  6178              STR      r0,[r7,#0x14]  ; fl_tmp
00004e  f7fffffe          BL       __aeabi_f2uiz
000052  7038              STRB     r0,[r7,#0]
;;;553    
;;;554    	
;;;555    /*
;;;556    		  switch (numb_ind)
;;;557    			{
;;;558    				case 0x00:  // CS0
;;;559    					pin=GPIO_Pin_0;
;;;560    					break;
;;;561    
;;;562    				case 0x01:  // CS1
;;;563    					pin=GPIO_Pin_1;
;;;564    					break;
;;;565    
;;;566    				case 0x02:  // CS2
;;;567    					pin=GPIO_Pin_2;
;;;568    					break;
;;;569    
;;;570    				case 0x03:  // CS3
;;;571    					pin=GPIO_Pin_3;
;;;572    					break;
;;;573    
;;;574    				case 0x04:  // CS4
;;;575    					pin=GPIO_Pin_4;
;;;576    					break;								
;;;577    			}
;;;578    	*/
;;;579    	  pin=pin_ind(numb_ind);
000054  4650              MOV      r0,r10
000056  f7fffffe          BL       pin_ind
00005a  0004              MOVS     r4,r0
;;;580    		if (pin==0)
00005c  d07c              BEQ      |L9.344|
;;;581    				return ;
;;;582    		if ((kol>max_kol_st)|(zn>=maks))
00005e  7838              LDRB     r0,[r7,#0]  ; kol
000060  42a8              CMP      r0,r5
000062  d901              BLS      |L9.104|
000064  2101              MOVS     r1,#1
000066  e000              B        |L9.106|
                  |L9.104|
000068  2100              MOVS     r1,#0
                  |L9.106|
00006a  4546              CMP      r6,r8
00006c  d301              BCC      |L9.114|
00006e  2201              MOVS     r2,#1
000070  e000              B        |L9.116|
                  |L9.114|
000072  2200              MOVS     r2,#0
                  |L9.116|
;;;583    		{
;;;584    			if (max_kol_st==28)
;;;585    			{
;;;586    				GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
000074  f8df824c          LDR      r8,|L9.708|
000078  4311              ORRS     r1,r1,r2              ;582
00007a  d06f              BEQ      |L9.348|
00007c  2d1c              CMP      r5,#0x1c              ;584
00007e  d16b              BNE      |L9.344|
000080  2200              MOVS     r2,#0
000082  4621              MOV      r1,r4
000084  4640              MOV      r0,r8
000086  f7fffffe          BL       GPIO_WriteBit
00008a  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
00008c  f7fffffe          BL       delay_spi
;;;587    				spi_send((u8)0x01);											delay_spi(zad_spi);
000090  2001              MOVS     r0,#1
000092  f7fffffe          BL       spi_send
000096  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
000098  f7fffffe          BL       delay_spi
;;;588    				spi_send((u8) 0); 											delay_spi(zad_spi);	
00009c  2000              MOVS     r0,#0
00009e  f7fffffe          BL       spi_send
0000a2  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
0000a4  f7fffffe          BL       delay_spi
;;;589    				GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);
0000a8  2201              MOVS     r2,#1
0000aa  4621              MOV      r1,r4
0000ac  4640              MOV      r0,r8
0000ae  f7fffffe          BL       GPIO_WriteBit
0000b2  69f8              LDR      r0,[r7,#0x1c]  ; zad_spi2
0000b4  f7fffffe          BL       delay_spi
;;;590    
;;;591    				GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
0000b8  2200              MOVS     r2,#0
0000ba  4621              MOV      r1,r4
0000bc  4640              MOV      r0,r8
0000be  f7fffffe          BL       GPIO_WriteBit
0000c2  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
0000c4  f7fffffe          BL       delay_spi
;;;592    				spi_send((u8)0x02);											delay_spi(zad_spi);
0000c8  2002              MOVS     r0,#2
0000ca  f7fffffe          BL       spi_send
0000ce  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
0000d0  f7fffffe          BL       delay_spi
;;;593    				spi_send((u8) 0); 											delay_spi(zad_spi);	
0000d4  2000              MOVS     r0,#0
0000d6  f7fffffe          BL       spi_send
0000da  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
0000dc  f7fffffe          BL       delay_spi
;;;594    				GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);
0000e0  2201              MOVS     r2,#1
0000e2  4621              MOV      r1,r4
0000e4  4640              MOV      r0,r8
0000e6  f7fffffe          BL       GPIO_WriteBit
0000ea  69f8              LDR      r0,[r7,#0x1c]  ; zad_spi2
0000ec  f7fffffe          BL       delay_spi
;;;595    
;;;596    				GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
0000f0  2200              MOVS     r2,#0
0000f2  4621              MOV      r1,r4
0000f4  4640              MOV      r0,r8
0000f6  f7fffffe          BL       GPIO_WriteBit
0000fa  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
0000fc  f7fffffe          BL       delay_spi
;;;597    				spi_send((u8)0x03);											delay_spi(zad_spi);
000100  2003              MOVS     r0,#3
000102  f7fffffe          BL       spi_send
000106  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
000108  f7fffffe          BL       delay_spi
;;;598    				spi_send((u8) 0); 											delay_spi(zad_spi);	
00010c  2000              MOVS     r0,#0
00010e  f7fffffe          BL       spi_send
000112  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
000114  f7fffffe          BL       delay_spi
;;;599    				GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);				
000118  2201              MOVS     r2,#1
00011a  4621              MOV      r1,r4
00011c  4640              MOV      r0,r8
00011e  f7fffffe          BL       GPIO_WriteBit
000122  69f8              LDR      r0,[r7,#0x1c]  ; zad_spi2
000124  f7fffffe          BL       delay_spi
;;;600    				
;;;601    				GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
000128  2200              MOVS     r2,#0
00012a  4621              MOV      r1,r4
00012c  4640              MOV      r0,r8
00012e  f7fffffe          BL       GPIO_WriteBit
000132  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
000134  f7fffffe          BL       delay_spi
;;;602    				spi_send((u8)0x04);											delay_spi(zad_spi);
000138  2004              MOVS     r0,#4
00013a  f7fffffe          BL       spi_send
00013e  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
000140  f7fffffe          BL       delay_spi
;;;603    				spi_send((u8) 0x08); 										delay_spi(zad_spi);	
000144  2008              MOVS     r0,#8
000146  f7fffffe          BL       spi_send
00014a  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
00014c  f7fffffe          BL       delay_spi
;;;604    				GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);
000150  2201              MOVS     r2,#1
000152  4621              MOV      r1,r4
000154  4640              MOV      r0,r8
000156  e0a6              B        |L9.678|
                  |L9.344|
000158  e0aa              B        |L9.688|
00015a  e7ff              B        |L9.348|
                  |L9.348|
00015c  466e              MOV      r6,sp                 ;544
;;;605    			 }
;;;606    			return ;
;;;607    		}
;;;608    		if (kol>7)
00015e  2807              CMP      r0,#7
000160  d902              BLS      |L9.360|
;;;609    			viv=tabl[8];
000162  f89d5008          LDRB     r5,[sp,#8]
000166  e002              B        |L9.366|
                  |L9.360|
;;;610    		else
;;;611    			viv=tabl[kol%8];
000168  f0000007          AND      r0,r0,#7
00016c  5c35              LDRB     r5,[r6,r0]
                  |L9.366|
;;;612    		
;;;613    		GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
00016e  2200              MOVS     r2,#0
000170  4621              MOV      r1,r4
000172  4640              MOV      r0,r8
000174  f7fffffe          BL       GPIO_WriteBit
000178  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
00017a  f7fffffe          BL       delay_spi
;;;614    		spi_send((u8)0x01);											delay_spi(zad_spi);
00017e  2001              MOVS     r0,#1
000180  f7fffffe          BL       spi_send
000184  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
000186  f7fffffe          BL       delay_spi
;;;615    		spi_send((u8) viv); 										delay_spi(zad_spi);	
00018a  4628              MOV      r0,r5
00018c  f7fffffe          BL       spi_send
000190  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
000192  f7fffffe          BL       delay_spi
;;;616    		GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);
000196  2201              MOVS     r2,#1
000198  4621              MOV      r1,r4
00019a  4640              MOV      r0,r8
00019c  f7fffffe          BL       GPIO_WriteBit
0001a0  69f8              LDR      r0,[r7,#0x1c]  ; zad_spi2
0001a2  f7fffffe          BL       delay_spi
;;;617    		
;;;618    		if (kol<8)
0001a6  7838              LDRB     r0,[r7,#0]  ; kol
0001a8  2808              CMP      r0,#8
0001aa  d201              BCS      |L9.432|
;;;619    			viv=0;
0001ac  2500              MOVS     r5,#0
0001ae  e00a              B        |L9.454|
                  |L9.432|
;;;620    		else
;;;621    		{
;;;622    			kol=kol-8;
0001b0  3808              SUBS     r0,r0,#8
0001b2  b2c0              UXTB     r0,r0
0001b4  7038              STRB     r0,[r7,#0]
;;;623    			if (kol>7)
0001b6  2807              CMP      r0,#7
0001b8  d902              BLS      |L9.448|
;;;624    				viv=tabl[8];
0001ba  f89d5008          LDRB     r5,[sp,#8]
0001be  e002              B        |L9.454|
                  |L9.448|
;;;625    			else
;;;626    				viv=tabl[kol%8];
0001c0  f0000007          AND      r0,r0,#7
0001c4  5c35              LDRB     r5,[r6,r0]
                  |L9.454|
;;;627    		}
;;;628    		
;;;629    		GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
0001c6  2200              MOVS     r2,#0
0001c8  4621              MOV      r1,r4
0001ca  4640              MOV      r0,r8
0001cc  f7fffffe          BL       GPIO_WriteBit
0001d0  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
0001d2  f7fffffe          BL       delay_spi
;;;630    		spi_send((u8)0x02);											delay_spi(zad_spi);
0001d6  2002              MOVS     r0,#2
0001d8  f7fffffe          BL       spi_send
0001dc  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
0001de  f7fffffe          BL       delay_spi
;;;631    		spi_send((u8)viv); 											delay_spi(zad_spi);	
0001e2  4628              MOV      r0,r5
0001e4  f7fffffe          BL       spi_send
0001e8  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
0001ea  f7fffffe          BL       delay_spi
;;;632    		GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);
0001ee  2201              MOVS     r2,#1
0001f0  4621              MOV      r1,r4
0001f2  4640              MOV      r0,r8
0001f4  f7fffffe          BL       GPIO_WriteBit
0001f8  69f8              LDR      r0,[r7,#0x1c]  ; zad_spi2
0001fa  f7fffffe          BL       delay_spi
;;;633    	
;;;634    		if (kol<8)
0001fe  7838              LDRB     r0,[r7,#0]  ; kol
000200  2808              CMP      r0,#8
000202  d201              BCS      |L9.520|
;;;635    			viv=0;
000204  2500              MOVS     r5,#0
000206  e00a              B        |L9.542|
                  |L9.520|
;;;636    		else
;;;637    		{
;;;638    			kol=kol-8;
000208  3808              SUBS     r0,r0,#8
00020a  b2c0              UXTB     r0,r0
00020c  7038              STRB     r0,[r7,#0]
;;;639    			if (kol>7)
00020e  2807              CMP      r0,#7
000210  d902              BLS      |L9.536|
;;;640    				viv=tabl[8];
000212  f89d5008          LDRB     r5,[sp,#8]
000216  e002              B        |L9.542|
                  |L9.536|
;;;641    			else
;;;642    				viv=tabl[kol%8];
000218  f0000007          AND      r0,r0,#7
00021c  5c35              LDRB     r5,[r6,r0]
                  |L9.542|
;;;643    		}
;;;644    		
;;;645    		GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
00021e  2200              MOVS     r2,#0
000220  4621              MOV      r1,r4
000222  4640              MOV      r0,r8
000224  f7fffffe          BL       GPIO_WriteBit
000228  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
00022a  f7fffffe          BL       delay_spi
;;;646    		spi_send((u8)0x03);delay_spi(zad_spi);
00022e  2003              MOVS     r0,#3
000230  f7fffffe          BL       spi_send
000234  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
000236  f7fffffe          BL       delay_spi
;;;647    		spi_send((u8)viv); delay_spi(zad_spi);	
00023a  4628              MOV      r0,r5
00023c  f7fffffe          BL       spi_send
000240  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
000242  f7fffffe          BL       delay_spi
;;;648    		GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);
000246  2201              MOVS     r2,#1
000248  4621              MOV      r1,r4
00024a  4640              MOV      r0,r8
00024c  f7fffffe          BL       GPIO_WriteBit
000250  69f8              LDR      r0,[r7,#0x1c]  ; zad_spi2
000252  f7fffffe          BL       delay_spi
;;;649    
;;;650    		if (kol<8)
000256  7838              LDRB     r0,[r7,#0]  ; kol
000258  2808              CMP      r0,#8
00025a  d201              BCS      |L9.608|
;;;651    			viv=0;
00025c  2500              MOVS     r5,#0
00025e  e00a              B        |L9.630|
                  |L9.608|
;;;652    		else
;;;653    		{
;;;654    			kol=kol-8;
000260  3808              SUBS     r0,r0,#8
000262  b2c0              UXTB     r0,r0
000264  7038              STRB     r0,[r7,#0]
;;;655    			if (kol>7)
000266  2807              CMP      r0,#7
000268  d902              BLS      |L9.624|
;;;656    				viv=tabl[8];
00026a  f89d5008          LDRB     r5,[sp,#8]
00026e  e002              B        |L9.630|
                  |L9.624|
;;;657    			else
;;;658    				viv=tabl[kol%8];
000270  f0000007          AND      r0,r0,#7
000274  5c35              LDRB     r5,[r6,r0]
                  |L9.630|
;;;659    		}
;;;660    		
;;;661    		GPIO_WriteBit(GPIOA, pin, Bit_RESET); 	delay_spi(zad_spi);
000276  2200              MOVS     r2,#0
000278  4621              MOV      r1,r4
00027a  4646              MOV      r6,r8
00027c  4640              MOV      r0,r8
00027e  f7fffffe          BL       GPIO_WriteBit
000282  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
000284  f7fffffe          BL       delay_spi
;;;662    		spi_send((u8)0x04);delay_spi(zad_spi);
000288  2004              MOVS     r0,#4
00028a  f7fffffe          BL       spi_send
00028e  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
000290  f7fffffe          BL       delay_spi
;;;663    		spi_send((u8)viv); delay_spi(zad_spi);	
000294  4628              MOV      r0,r5
000296  f7fffffe          BL       spi_send
00029a  69b8              LDR      r0,[r7,#0x18]  ; zad_spi
00029c  f7fffffe          BL       delay_spi
;;;664    		GPIO_WriteBit(GPIOA, pin, Bit_SET);			delay_spi(zad_spi2);
0002a0  2201              MOVS     r2,#1
0002a2  4621              MOV      r1,r4
0002a4  4630              MOV      r0,r6
                  |L9.678|
0002a6  f7fffffe          BL       GPIO_WriteBit
0002aa  69f8              LDR      r0,[r7,#0x1c]         ;604  ; zad_spi2
0002ac  f7fffffe          BL       delay_spi
                  |L9.688|
;;;665    	//	kol=kol%8;			
;;;666    
;;;667    	
;;;668    }
0002b0  e8bd8ffe          POP      {r1-r11,pc}
;;;669    /*
                          ENDP

                  |L9.692|
0002b4  00                DCB      0
0002b5  0103070f          DCB      1,3,"\a",15,31,"?",127,255,0
0002b9  1f3f7fff
0002bd  00      
0002be  00                DCB      0
0002bf  00                DCB      0
                  |L9.704|
                          DCD      ||area_number.37||
                  |L9.708|
                          DCD      0x40020000

                          AREA ||i.indicate_time||, CODE, READONLY, ALIGN=2

                  indicate_time PROC
;;;1384   
;;;1385   void indicate_time(u8 numb_ind, u8 hh, u8 mm, u8 en)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1386   {
000004  4699              MOV      r9,r3
000006  4692              MOV      r10,r2
000008  460d              MOV      r5,r1
;;;1387   		 	uint16_t  pin=0;
;;;1388   			u8 i=0;
;;;1389   
;;;1390   /*
;;;1391   			switch (numb_ind)
;;;1392   			{
;;;1393   				case 0x00:  // CS0
;;;1394   					pin=GPIO_Pin_0;
;;;1395   					break;
;;;1396   
;;;1397   				case 0x01:  // CS1
;;;1398   					pin=GPIO_Pin_1;
;;;1399   					break;
;;;1400   
;;;1401   				case 0x02:  // CS2
;;;1402   					pin=GPIO_Pin_2;
;;;1403   					break;
;;;1404   
;;;1405   				case 0x03:  // CS3
;;;1406   					pin=GPIO_Pin_3;
;;;1407   					break;
;;;1408   
;;;1409   				case 0x04:  // CS4
;;;1410   					pin=GPIO_Pin_4;
;;;1411   					break;						
;;;1412   			}
;;;1413   	*/
;;;1414   	
;;;1415   			  pin=pin_ind(numb_ind);
00000a  f7fffffe          BL       pin_ind
00000e  0007              MOVS     r7,r0
;;;1416   		if (pin==0)
000010  d07d              BEQ      |L10.270|
;;;1417   				return ;
;;;1418   				GPIO_WriteBit(GPIOA, pin, Bit_RESET);      //   
000012  f8df8160          LDR      r8,|L10.372|
000016  4601              MOV      r1,r0
000018  2200              MOVS     r2,#0
00001a  4644              MOV      r4,r8
00001c  4640              MOV      r0,r8
00001e  f7fffffe          BL       GPIO_WriteBit
;;;1419   				delay_spi(100);
000022  2064              MOVS     r0,#0x64
000024  f7fffffe          BL       delay_spi
;;;1420   				spi_send(0x0f);delay_spi(100);
000028  200f              MOVS     r0,#0xf
00002a  f7fffffe          BL       spi_send
00002e  2064              MOVS     r0,#0x64
000030  f7fffffe          BL       delay_spi
;;;1421   				spi_send(0x00); delay_spi(100);
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       spi_send
00003a  2064              MOVS     r0,#0x64
00003c  f7fffffe          BL       delay_spi
;;;1422   				GPIO_WriteBit(GPIOA, pin, Bit_SET);      //  
000040  2201              MOVS     r2,#1
000042  4639              MOV      r1,r7
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       GPIO_WriteBit
;;;1423   				delay_spi(1000);
00004a  f44f707a          MOV      r0,#0x3e8
00004e  f7fffffe          BL       delay_spi
;;;1424   	/*	
;;;1425   			for (i=1;i<8;i++)
;;;1426   			{		
;;;1427   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);   delay_spi(zad_spi);
;;;1428   			spi_send(i);														delay_spi(zad_spi);
;;;1429   			spi_send(symb_code[i]); 														delay_spi(zad_spi);
;;;1430   			GPIO_WriteBit(GPIOA, pin, Bit_SET);     delay_spi(zad_spi2);						
;;;1431   			}		
;;;1432   	*/	
;;;1433   
;;;1434   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);     delay_spi(zad_spi);
000052  2200              MOVS     r2,#0
000054  4639              MOV      r1,r7
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       GPIO_WriteBit
00005c  4c46              LDR      r4,|L10.376|
00005e  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
000060  f7fffffe          BL       delay_spi
;;;1435   			spi_send(1);															delay_spi(zad_spi);
000064  2001              MOVS     r0,#1
000066  f7fffffe          BL       spi_send
00006a  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
00006c  f7fffffe          BL       delay_spi
;;;1436   			if (hh/10==0)
;;;1437   				spi_send(0); 
;;;1438   			else
;;;1439   				spi_send(symb_code[hh/10]); 
000070  f04f0b0a          MOV      r11,#0xa
000074  fbb5f6fb          UDIV     r6,r5,r11
000078  2d0a              CMP      r5,#0xa               ;1436
00007a  d201              BCS      |L10.128|
00007c  2000              MOVS     r0,#0                 ;1437
00007e  e002              B        |L10.134|
                  |L10.128|
000080  483d              LDR      r0,|L10.376|
000082  3020              ADDS     r0,r0,#0x20
000084  5d80              LDRB     r0,[r0,r6]
                  |L10.134|
000086  f7fffffe          BL       spi_send
;;;1440   			delay_spi(zad_spi);
00008a  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
00008c  f7fffffe          BL       delay_spi
;;;1441   			GPIO_WriteBit(GPIOA, pin, Bit_SET);       delay_spi(zad_spi2);
000090  2201              MOVS     r2,#1
000092  4639              MOV      r1,r7
000094  4837              LDR      r0,|L10.372|
000096  f7fffffe          BL       GPIO_WriteBit
00009a  69e0              LDR      r0,[r4,#0x1c]  ; zad_spi2
00009c  f7fffffe          BL       delay_spi
;;;1442   	
;;;1443   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);     delay_spi(zad_spi);
0000a0  2200              MOVS     r2,#0
0000a2  4639              MOV      r1,r7
0000a4  4833              LDR      r0,|L10.372|
0000a6  f7fffffe          BL       GPIO_WriteBit
0000aa  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
0000ac  f7fffffe          BL       delay_spi
;;;1444   			spi_send(2);															delay_spi(zad_spi);
0000b0  2002              MOVS     r0,#2
0000b2  f7fffffe          BL       spi_send
0000b6  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
0000b8  f7fffffe          BL       delay_spi
;;;1445   			spi_send(0x80*en+symb_code[hh%10]); 			delay_spi(zad_spi);	
0000bc  482e              LDR      r0,|L10.376|
0000be  fb0b5116          MLS      r1,r11,r6,r5
0000c2  3020              ADDS     r0,r0,#0x20
0000c4  46d8              MOV      r8,r11
0000c6  5c41              LDRB     r1,[r0,r1]
0000c8  eb0110c9          ADD      r0,r1,r9,LSL #7
0000cc  f7fffffe          BL       spi_send
0000d0  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
0000d2  f7fffffe          BL       delay_spi
;;;1446   			GPIO_WriteBit(GPIOA, pin, Bit_SET);     	delay_spi(zad_spi2);
0000d6  2201              MOVS     r2,#1
0000d8  4639              MOV      r1,r7
0000da  4826              LDR      r0,|L10.372|
0000dc  f7fffffe          BL       GPIO_WriteBit
0000e0  69e0              LDR      r0,[r4,#0x1c]  ; zad_spi2
0000e2  f7fffffe          BL       delay_spi
;;;1447   			
;;;1448   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);     delay_spi(zad_spi);
0000e6  2200              MOVS     r2,#0
0000e8  4639              MOV      r1,r7
0000ea  4822              LDR      r0,|L10.372|
0000ec  f7fffffe          BL       GPIO_WriteBit
0000f0  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
0000f2  f7fffffe          BL       delay_spi
;;;1449   			spi_send(3);															delay_spi(zad_spi);
0000f6  2003              MOVS     r0,#3
0000f8  f7fffffe          BL       spi_send
0000fc  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
0000fe  f7fffffe          BL       delay_spi
;;;1450   			spi_send(1*en+symb_code_min[mm/10]); 			delay_spi(zad_spi);
000102  fbbaf5f8          UDIV     r5,r10,r8
000106  4e1c              LDR      r6,|L10.376|
000108  362d              ADDS     r6,r6,#0x2d
00010a  5d71              LDRB     r1,[r6,r5]
00010c  e000              B        |L10.272|
                  |L10.270|
00010e  e02e              B        |L10.366|
                  |L10.272|
000110  eb010009          ADD      r0,r1,r9
000114  f7fffffe          BL       spi_send
000118  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
00011a  f7fffffe          BL       delay_spi
;;;1451   			GPIO_WriteBit(GPIOA, pin, Bit_SET);    	  delay_spi(zad_spi2);
00011e  2201              MOVS     r2,#1
000120  4639              MOV      r1,r7
000122  4814              LDR      r0,|L10.372|
000124  f7fffffe          BL       GPIO_WriteBit
000128  69e0              LDR      r0,[r4,#0x1c]  ; zad_spi2
00012a  f7fffffe          BL       delay_spi
;;;1452   
;;;1453   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);     delay_spi(zad_spi);
00012e  2200              MOVS     r2,#0
000130  4639              MOV      r1,r7
000132  4810              LDR      r0,|L10.372|
000134  f7fffffe          BL       GPIO_WriteBit
000138  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
00013a  f7fffffe          BL       delay_spi
;;;1454   			spi_send(4);															delay_spi(zad_spi);
00013e  2004              MOVS     r0,#4
000140  f7fffffe          BL       spi_send
000144  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
000146  f7fffffe          BL       delay_spi
;;;1455   			spi_send(symb_code_min[mm%10]); 					delay_spi(zad_spi);
00014a  fb08a115          MLS      r1,r8,r5,r10
00014e  5c70              LDRB     r0,[r6,r1]
000150  f7fffffe          BL       spi_send
000154  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
000156  f7fffffe          BL       delay_spi
;;;1456   			GPIO_WriteBit(GPIOA, pin, Bit_SET);       delay_spi(zad_spi2);
00015a  2201              MOVS     r2,#1
00015c  4639              MOV      r1,r7
00015e  4805              LDR      r0,|L10.372|
000160  f7fffffe          BL       GPIO_WriteBit
000164  69e0              LDR      r0,[r4,#0x1c]  ; zad_spi2
000166  e8bd5ff0          POP      {r4-r12,lr}
00016a  f7ffbffe          B.W      delay_spi
                  |L10.366|
;;;1457   }
00016e  e8bd9ff0          POP      {r4-r12,pc}
;;;1458   
                          ENDP

000172  0000              DCW      0x0000
                  |L10.372|
                          DCD      0x40020000
                  |L10.376|
                          DCD      ||area_number.37||

                          AREA ||i.init_ind||, CODE, READONLY, ALIGN=2

                  init_ind PROC
;;;981    }
;;;982    void init_ind(u8 numb_ind, u8 kol_ind, u8 type_ind)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;983    {
000004  4688              MOV      r8,r1
;;;984    			uint16_t  pin=0;
;;;985    			u8 i=0;
;;;986    //			u16  zad_spi=1000,zad_spi2=10000;
;;;987    
;;;988    			/*
;;;989    		  switch (numb_ind)
;;;990    			{
;;;991    				case 0x00:  // CS0
;;;992    					pin=GPIO_Pin_0;
;;;993    					break;
;;;994    
;;;995    				case 0x01:  // CS1
;;;996    					pin=GPIO_Pin_1;
;;;997    					break;
;;;998    
;;;999    				case 0x02:  // CS2
;;;1000   					pin=GPIO_Pin_2;
;;;1001   					break;
;;;1002   
;;;1003   				case 0x03:  // CS3
;;;1004   					pin=GPIO_Pin_3;
;;;1005   					break;
;;;1006   
;;;1007   				case 0x04:  // CS4
;;;1008   					pin=GPIO_Pin_4;
;;;1009   					break;								
;;;1010   			}
;;;1011   			*/
;;;1012   			pin=pin_ind(numb_ind);
000006  f7fffffe          BL       pin_ind
00000a  0007              MOVS     r7,r0
;;;1013   			if (pin==0)
00000c  d07a              BEQ      |L11.260|
;;;1014   				return;
;;;1015   			
;;;1016   			// shutdown off
;;;1017   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);  delay_spi(zad_spi);		
00000e  4e3e              LDR      r6,|L11.264|
000010  4601              MOV      r1,r0
000012  2200              MOVS     r2,#0
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       GPIO_WriteBit
00001a  4d3c              LDR      r5,|L11.268|
00001c  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
00001e  f7fffffe          BL       delay_spi
;;;1018   			spi_send(0x0C);			delay_spi(zad_spi);
000022  200c              MOVS     r0,#0xc
000024  f7fffffe          BL       spi_send
000028  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
00002a  f7fffffe          BL       delay_spi
;;;1019   			spi_send(0x01);			delay_spi(zad_spi);			
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       spi_send
000034  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
000036  f7fffffe          BL       delay_spi
;;;1020   			GPIO_WriteBit(GPIOA, pin, Bit_SET);      		delay_spi(zad_spi2);
00003a  2201              MOVS     r2,#1
00003c  4639              MOV      r1,r7
00003e  4630              MOV      r0,r6
000040  f7fffffe          BL       GPIO_WriteBit
000044  69e8              LDR      r0,[r5,#0x1c]  ; zad_spi2
000046  f7fffffe          BL       delay_spi
;;;1021   
;;;1022   		for (i=1;i<9;i++)
00004a  2401              MOVS     r4,#1
                  |L11.76|
;;;1023   		{
;;;1024   			// blank all
;;;1025   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);      delay_spi(zad_spi);
00004c  2200              MOVS     r2,#0
00004e  4639              MOV      r1,r7
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       GPIO_WriteBit
000056  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
000058  f7fffffe          BL       delay_spi
;;;1026   			spi_send((u8) i);					delay_spi(zad_spi);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       spi_send
000062  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
000064  f7fffffe          BL       delay_spi
;;;1027   			spi_send(0x00);					  delay_spi(zad_spi);			
000068  2000              MOVS     r0,#0
00006a  f7fffffe          BL       spi_send
00006e  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
000070  f7fffffe          BL       delay_spi
;;;1028   			GPIO_WriteBit(GPIOA, pin, Bit_SET);      		delay_spi(zad_spi2);
000074  2201              MOVS     r2,#1
000076  4639              MOV      r1,r7
000078  4630              MOV      r0,r6
00007a  f7fffffe          BL       GPIO_WriteBit
00007e  69e8              LDR      r0,[r5,#0x1c]  ; zad_spi2
000080  f7fffffe          BL       delay_spi
000084  1c64              ADDS     r4,r4,#1              ;1022
000086  b2e4              UXTB     r4,r4                 ;1022
000088  2c09              CMP      r4,#9                 ;1022
00008a  d3df              BCC      |L11.76|
;;;1029   		}
;;;1030   		
;;;1031   			// scan limit
;;;1032   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);   			delay_spi(zad_spi);
00008c  2200              MOVS     r2,#0
00008e  4639              MOV      r1,r7
000090  4630              MOV      r0,r6
000092  f7fffffe          BL       GPIO_WriteBit
000096  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
000098  f7fffffe          BL       delay_spi
;;;1033   			spi_send(0x0B);				delay_spi(zad_spi);
00009c  200b              MOVS     r0,#0xb
00009e  f7fffffe          BL       spi_send
0000a2  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
0000a4  f7fffffe          BL       delay_spi
;;;1034   			spi_send(kol_ind-1);	delay_spi(zad_spi);			
0000a8  f1a80001          SUB      r0,r8,#1
0000ac  b280              UXTH     r0,r0
0000ae  f7fffffe          BL       spi_send
0000b2  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
0000b4  f7fffffe          BL       delay_spi
;;;1035   			GPIO_WriteBit(GPIOA, pin, Bit_SET);      			delay_spi(zad_spi2);
0000b8  2201              MOVS     r2,#1
0000ba  4639              MOV      r1,r7
0000bc  4630              MOV      r0,r6
0000be  f7fffffe          BL       GPIO_WriteBit
0000c2  69e8              LDR      r0,[r5,#0x1c]  ; zad_spi2
0000c4  f7fffffe          BL       delay_spi
;;;1036   			
;;;1037   			// registr intensivnost
;;;1038   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);      delay_spi(zad_spi);
0000c8  2200              MOVS     r2,#0
0000ca  4639              MOV      r1,r7
0000cc  4630              MOV      r0,r6
0000ce  f7fffffe          BL       GPIO_WriteBit
0000d2  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
0000d4  f7fffffe          BL       delay_spi
;;;1039   			spi_send(0x0A);					delay_spi(zad_spi);
0000d8  200a              MOVS     r0,#0xa
0000da  f7fffffe          BL       spi_send
0000de  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
0000e0  f7fffffe          BL       delay_spi
;;;1040   			spi_send(0x0F);					delay_spi(zad_spi);			
0000e4  200f              MOVS     r0,#0xf
0000e6  f7fffffe          BL       spi_send
0000ea  69a8              LDR      r0,[r5,#0x18]  ; zad_spi
0000ec  f7fffffe          BL       delay_spi
;;;1041   			GPIO_WriteBit(GPIOA, pin, Bit_SET);     delay_spi(zad_spi2);
0000f0  2201              MOVS     r2,#1
0000f2  4639              MOV      r1,r7
0000f4  4630              MOV      r0,r6
0000f6  f7fffffe          BL       GPIO_WriteBit
0000fa  69e8              LDR      r0,[r5,#0x1c]  ; zad_spi2
0000fc  e8bd41f0          POP      {r4-r8,lr}
000100  f7ffbffe          B.W      delay_spi
                  |L11.260|
;;;1042   
;;;1043   /*	
;;;1044   		// test
;;;1045   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);      delay_spi(zad_spi);
;;;1046   			spi_send((u8) 0x0f);					delay_spi(zad_spi);
;;;1047   			spi_send(0x01);					delay_spi(zad_spi);			
;;;1048   			GPIO_WriteBit(GPIOA, pin, Bit_SET);      delay_spi(zad_spi2);
;;;1049   
;;;1050   		  delay_spi(zad_spi2*50);	
;;;1051   		
;;;1052   			GPIO_WriteBit(GPIOA, pin, Bit_RESET);      delay_spi(zad_spi);
;;;1053   			spi_send((u8) 0x0f);					delay_spi(zad_spi);
;;;1054   			spi_send(0x00);					delay_spi(zad_spi);			
;;;1055   			GPIO_WriteBit(GPIOA, pin, Bit_SET);     delay_spi(zad_spi2);			
;;;1056   */			
;;;1057   	//		test_ind_all(1);
;;;1058   	//	test_lin();
;;;1059   }
000104  e8bd81f0          POP      {r4-r8,pc}
;;;1060   
                          ENDP

                  |L11.264|
                          DCD      0x40020000
                  |L11.268|
                          DCD      ||area_number.37||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;1464   */
;;;1465   int main(void)
000000  b088              SUB      sp,sp,#0x20
;;;1466   { 
;;;1467   	u8 i=0;
000002  2400              MOVS     r4,#0
;;;1468   	GPIO_InitTypeDef GPIO_InitStructure;
;;;1469     NVIC_InitTypeDef NVIC_InitStructure;
;;;1470     RCC_ClocksTypeDef RCC_ClockFreq;
;;;1471   	
;;;1472   	uint16_t data[32];
;;;1473   	
;;;1474   	TDateTime DT;
;;;1475   
;;;1476   
;;;1477     /* Initialize LEDS */
;;;1478     STM_EVAL_LEDInit(LED3);
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       STM_EVAL_LEDInit
;;;1479     STM_EVAL_LEDInit(LED4);
00000a  2000              MOVS     r0,#0
00000c  f7fffffe          BL       STM_EVAL_LEDInit
;;;1480     STM_EVAL_LEDInit(LED5);
000010  2002              MOVS     r0,#2
000012  f7fffffe          BL       STM_EVAL_LEDInit
;;;1481     STM_EVAL_LEDInit(LED6);
000016  2003              MOVS     r0,#3
000018  f7fffffe          BL       STM_EVAL_LEDInit
;;;1482    
;;;1483     /* Green Led On: start of application */
;;;1484   	STM_EVAL_LEDOn(LED3);
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       STM_EVAL_LEDOn
;;;1485   	STM_EVAL_LEDOn(LED4);
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       STM_EVAL_LEDOn
;;;1486   	STM_EVAL_LEDOn(LED5);
000028  2002              MOVS     r0,#2
00002a  f7fffffe          BL       STM_EVAL_LEDOn
;;;1487   	STM_EVAL_LEDOn(LED6);	
00002e  2003              MOVS     r0,#3
000030  f7fffffe          BL       STM_EVAL_LEDOn
;;;1488   	 
;;;1489     /* This function fills the RCC_ClockFreq structure with the current
;;;1490     frequencies of different on chip clocks (for debug purpose) **************/
;;;1491     RCC_GetClocksFreq(&RCC_ClockFreq);
000034  a804              ADD      r0,sp,#0x10
000036  f7fffffe          BL       RCC_GetClocksFreq
;;;1492     
;;;1493     /* Enable Clock Security System(CSS): this will generate an NMI exception
;;;1494     when HSE clock fails *****************************************************/
;;;1495     RCC_ClockSecuritySystemCmd(ENABLE);
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       RCC_ClockSecuritySystemCmd
;;;1496     
;;;1497     /* Enable and configure RCC global IRQ channel, will be used to manage HSE ready 
;;;1498        and PLL ready interrupts. 
;;;1499        These interrupts are enabled in stm32f4xx_it.c file **********************/
;;;1500     NVIC_InitStructure.NVIC_IRQChannel = RCC_IRQn;
000040  2005              MOVS     r0,#5
000042  f88d000c          STRB     r0,[sp,#0xc]
;;;1501     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000046  2500              MOVS     r5,#0
000048  f88d500d          STRB     r5,[sp,#0xd]
;;;1502     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;  
00004c  f88d500e          STRB     r5,[sp,#0xe]
;;;1503     NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000050  2601              MOVS     r6,#1
000052  f88d600f          STRB     r6,[sp,#0xf]
;;;1504     NVIC_Init(&NVIC_InitStructure);
000056  a803              ADD      r0,sp,#0xc
000058  f7fffffe          BL       NVIC_Init
;;;1505   
;;;1506     /* Output clock on MCO2 pin(PC9) ****************************************/ 
;;;1507     /* Enable the GPIOC peripheral */ 
;;;1508     RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);
00005c  2101              MOVS     r1,#1
00005e  2004              MOVS     r0,#4
000060  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;1509     
;;;1510     /* Configure MCO2 pin(PC9) in alternate function */
;;;1511     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000064  0270              LSLS     r0,r6,#9
;;;1512     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
000066  9001              STR      r0,[sp,#4]
000068  2003              MOVS     r0,#3
00006a  f88d0009          STRB     r0,[sp,#9]
;;;1513     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00006e  2702              MOVS     r7,#2
000070  f88d7008          STRB     r7,[sp,#8]
;;;1514     GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;1515     GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;  
;;;1516     GPIO_Init(GPIOC, &GPIO_InitStructure);
000074  f8dfa1e4          LDR      r10,|L12.604|
000078  f88d500a          STRB     r5,[sp,#0xa]          ;1514
00007c  f88d600b          STRB     r6,[sp,#0xb]          ;1515
000080  a901              ADD      r1,sp,#4
000082  4650              MOV      r0,r10
000084  f7fffffe          BL       GPIO_Init
;;;1517       
;;;1518     /* System clock selected to output on MCO2 pin(PC9)*/
;;;1519     RCC_MCO2Config(RCC_MCO2Source_SYSCLK, RCC_MCO2Div_2);
000088  0771              LSLS     r1,r6,#29
00008a  2000              MOVS     r0,#0
00008c  f7fffffe          BL       RCC_MCO2Config
;;;1520   
;;;1521   
;;;1522   
;;;1523       // ???????? RTC
;;;1524       rtc_Reset();
000090  f7fffffe          BL       rtc_Reset
;;;1525       rtc_Init();
000094  f7fffffe          BL       rtc_Init
;;;1526    		
;;;1527   		
;;;1528   //	ADC_InitTypeDef  ADC_InitStructure;
;;;1529   	
;;;1530          
;;;1531     
;;;1532     /* Configure TIM4 Peripheral to manage LEDs lighting */
;;;1533     TIM_LED_Config();
000098  f7fffffe          BL       TIM_LED_Config
;;;1534     
;;;1535     /* Initialize the repeat status */
;;;1536     RepeatState = 0;
00009c  4870              LDR      r0,|L12.608|
00009e  7045              STRB     r5,[r0,#1]
;;;1537     LED_Toggle = 7;
0000a0  4970              LDR      r1,|L12.612|
0000a2  f04f0807          MOV      r8,#7
0000a6  f8818000          STRB     r8,[r1,#0]
;;;1538     
;;;1539   	// PC pin2
;;;1540     ADC3_CH12_DMA_Config();
0000aa  f7fffffe          BL       ADC3_CH12_DMA_Config
;;;1541     // Start ADC3 Software Conversion 
;;;1542     ADC_SoftwareStartConv(ADC3);
0000ae  486e              LDR      r0,|L12.616|
0000b0  f7fffffe          BL       ADC_SoftwareStartConv
;;;1543   	
;;;1544   	
;;;1545     
;;;1546   #if defined MEDIA_USB_KEY
;;;1547     
;;;1548     /* Initialize User Button */
;;;1549     STM_EVAL_PBInit(BUTTON_USER, BUTTON_MODE_EXTI);
0000b4  2101              MOVS     r1,#1
0000b6  2000              MOVS     r0,#0
0000b8  f7fffffe          BL       STM_EVAL_PBInit
;;;1550      
;;;1551     /* Init Host Library */
;;;1552     USBH_Init(&USB_OTG_Core, USB_OTG_FS_CORE_ID, &USB_Host, &USBH_MSC_cb, &USR_Callbacks);
0000bc  486b              LDR      r0,|L12.620|
0000be  4a6d              LDR      r2,|L12.628|
0000c0  9000              STR      r0,[sp,#0]
0000c2  4b6b              LDR      r3,|L12.624|
0000c4  2101              MOVS     r1,#1
0000c6  f5a26096          SUB      r0,r2,#0x4b0
0000ca  f7fffffe          BL       USBH_Init
;;;1553    
;;;1554   
;;;1555   
;;;1556   /*
;;;1557   SPI 1:
;;;1558   
;;;1559    nss - pa4
;;;1560    
;;;1561    sck - pa5
;;;1562    mosi - pa7
;;;1563    
;;;1564    miso - pa6
;;;1565   SPI 2:
;;;1566   
;;;1567    miso - pb14
;;;1568    mosi - pb15
;;;1569    sck - pb13
;;;1570    nss - pb12
;;;1571    
;;;1572   */
;;;1573   		spi1_init();
0000ce  f7fffffe          BL       spi1_init
;;;1574       spi2_init();
0000d2  f7fffffe          BL       spi2_init
;;;1575    
;;;1576   		
;;;1577   	
;;;1578   		RCC_APB2PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE); 	//port A
0000d6  2101              MOVS     r1,#1
0000d8  4608              MOV      r0,r1
0000da  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1579   		GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3;  //  vivod for CS 
0000de  200f              MOVS     r0,#0xf
;;;1580   		GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;     			// rezim vivoda
0000e0  f88d6008          STRB     r6,[sp,#8]
;;;1581   		GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;          //  PP GPIO_OType_PP
;;;1582   		// gpio.GPIO_PuPd = GPIO_PuPd_DOWN;
;;;1583   		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;     //speed
;;;1584   		GPIO_Init(GPIOA, &GPIO_InitStructure); 
0000e4  f8df9190          LDR      r9,|L12.632|
0000e8  9001              STR      r0,[sp,#4]            ;1580
0000ea  f88d600a          STRB     r6,[sp,#0xa]          ;1581
0000ee  f88d5009          STRB     r5,[sp,#9]            ;1583
0000f2  a901              ADD      r1,sp,#4
0000f4  4648              MOV      r0,r9
0000f6  f7fffffe          BL       GPIO_Init
;;;1585   		
;;;1586   		
;;;1587   		RCC_APB2PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE); 	//port A
0000fa  2101              MOVS     r1,#1
0000fc  4608              MOV      r0,r1
0000fe  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1588   		GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_4|GPIO_Pin_8|GPIO_Pin_9|GPIO_Pin_13|GPIO_Pin_14|GPIO_Pin_15;  //  vivod for RELE and svet AVARIYA 
000102  f24e3010          MOV      r0,#0xe310
;;;1589   		GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;     			// rezim vivoda
000106  f88d6008          STRB     r6,[sp,#8]
00010a  9001              STR      r0,[sp,#4]
;;;1590   		GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; //GPIO_OType_OD;          //  PP GPIO_OType_PP
00010c  f88d500a          STRB     r5,[sp,#0xa]
;;;1591   		// gpio.GPIO_PuPd = GPIO_PuPd_DOWN;
;;;1592   		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;     //speed
000110  f88d5009          STRB     r5,[sp,#9]
;;;1593   		GPIO_Init(GPIOA, &GPIO_InitStructure); 
000114  a901              ADD      r1,sp,#4
000116  4648              MOV      r0,r9
000118  f7fffffe          BL       GPIO_Init
;;;1594   	
;;;1595   		RCC_APB2PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE); 	//	port C
00011c  2101              MOVS     r1,#1
00011e  2004              MOVS     r0,#4
000120  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1596   		GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_1;  						// 	vvod for knopka
;;;1597   		GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN; //GPIO_Mode_OUT; //GPIO_Mode_IN;     			// 	rezim vivoda
000124  f88d5008          STRB     r5,[sp,#8]
;;;1598   	//	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;1599   //		GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;1600   	//	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD; //GPIO_OType_PP; 					//	GPIO_OType_OD;          //  PP GPIO_OType_PP
;;;1601   		// gpio.GPIO_PuPd = GPIO_PuPd_DOWN;
;;;1602   //		GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_NOPULL; //GPIO_PuPd_UP; //GPIO_PuPd_DOWN;  //GPIO_PuPd_NOPULL;
;;;1603   		GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;	
000128  f88d600a          STRB     r6,[sp,#0xa]
00012c  9701              STR      r7,[sp,#4]            ;1597
;;;1604   		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;     		//	speed
00012e  f88d7009          STRB     r7,[sp,#9]
;;;1605   		GPIO_Init(GPIOC, &GPIO_InitStructure); 	
000132  a901              ADD      r1,sp,#4
000134  4650              MOV      r0,r10
000136  f7fffffe          BL       GPIO_Init
;;;1606   
;;;1607   /*
;;;1608   		RCC_APB2PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE); 	//	port C
;;;1609   		GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_2;  						// 	vvod for knopka
;;;1610   		GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AN; //GPIO_Mode_IN;     			// 	rezim vivoda
;;;1611   	//	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD; //GPIO_OType_PP; 					//	GPIO_OType_OD;          //  PP GPIO_OType_PP
;;;1612   		// gpio.GPIO_PuPd = GPIO_PuPd_DOWN;
;;;1613   //		GPIO_InitStructure.GPIO_PuPd=GPIO_PuPd_NOPULL; //GPIO_PuPd_UP; //GPIO_PuPd_DOWN;  //GPIO_PuPd_NOPULL;
;;;1614   		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;     		//	speed
;;;1615   		GPIO_Init(GPIOC, &GPIO_InitStructure); 
;;;1616   	*/	
;;;1617   		/*
;;;1618   	  GPIO_PuPd_NOPULL = 0x00,
;;;1619     GPIO_PuPd_UP     = 0x01,
;;;1620     GPIO_PuPd_DOWN   = 0x02
;;;1621   */
;;;1622   
;;;1623   //		PIN_PRIBL
;;;1624   //		Port_PRIBL
;;;1625   		
;;;1626   /*
;;;1627   		RCC_APB2PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE); 	//port A
;;;1628   		GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_4;  //  vivod and RELE
;;;1629   		GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;     			// rezim vivoda
;;;1630   	//	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;          //  PP GPIO_OType_PP
;;;1631   		GPIO_InitStructure.GPIO_OType = GPIO_PuPd_DOWN;          //  PP GPIO_OType_PP
;;;1632   		
;;;1633   		// gpio.GPIO_PuPd = GPIO_PuPd_DOWN;
;;;1634   		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;     //speed
;;;1635   		GPIO_Init(GPIOA, &GPIO_InitStructure); 
;;;1636   */
;;;1637   /*
;;;1638   	conf.indicators[0].numb=1;
;;;1639   	conf.indicators[0].kol_cifr=8;
;;;1640   	conf.indicators[0].type_ind=0;
;;;1641   	conf.indicators[0].yark=0x0f;
;;;1642   	conf.indicators[0].rez_viv=0;   //   
;;;1643   	conf.indicators[0].chislo=0;
;;;1644   	conf.indicators[0].pol_zap=0;
;;;1645   	conf.indicators[0].porog=0xffff;	
;;;1646   
;;;1647   // lineika
;;;1648   	conf.indicators[1].numb=2;
;;;1649   	conf.indicators[1].kol_cifr=4;
;;;1650   	conf.indicators[1].type_ind=0;
;;;1651   	conf.indicators[1].yark=0x0f;
;;;1652   	conf.indicators[1].rez_viv=0;   //   
;;;1653   	conf.indicators[1].chislo=0;
;;;1654   	conf.indicators[1].pol_zap=0;
;;;1655   	conf.indicators[1].porog=0xffff;	
;;;1656   
;;;1657   	conf.indicators[2].numb=3;
;;;1658   	conf.indicators[2].kol_cifr=8;
;;;1659   	conf.indicators[2].type_ind=0;
;;;1660   	conf.indicators[2].yark=0x0f;
;;;1661   	conf.indicators[2].rez_viv=0;   //   
;;;1662   	conf.indicators[2].chislo=0;
;;;1663   	conf.indicators[2].pol_zap=0;
;;;1664   	conf.indicators[2].porog=0xffff;	
;;;1665   
;;;1666   // time
;;;1667   	conf.indicators[3].numb=4;
;;;1668   	conf.indicators[3].kol_cifr=4;
;;;1669   	conf.indicators[3].type_ind=0;
;;;1670   	conf.indicators[3].yark=0x0f;
;;;1671   	conf.indicators[3].rez_viv=0;   //   
;;;1672   	conf.indicators[3].chislo=0;
;;;1673   	conf.indicators[3].pol_zap=0;
;;;1674   	conf.indicators[3].porog=0xffff;	
;;;1675   //test_lin2();
;;;1676    
;;;1677   //	init_ind(indicators[0].numb, indicators[0].kol_cifr, indicators[0].type_ind);
;;;1678   //  init_ind(indicators[1].numb, indicators[1].kol_cifr, indicators[1].type_ind);
;;;1679   
;;;1680   	init_ind(conf.indicators[0].numb, conf.indicators[0].kol_cifr, conf.indicators[0].type_ind);
;;;1681     init_ind(conf.indicators[1].numb, conf.indicators[1].kol_cifr, conf.indicators[1].type_ind);
;;;1682   	init_ind(conf.indicators[2].numb, conf.indicators[2].kol_cifr, conf.indicators[2].type_ind);
;;;1683     init_ind(conf.indicators[3].numb, conf.indicators[3].kol_cifr, conf.indicators[3].type_ind);
;;;1684   	*/
;;;1685   	test_ind_all(1);
00013a  2001              MOVS     r0,#1
00013c  f7fffffe          BL       test_ind_all
;;;1686   	
;;;1687   	for (i = 0; i < 50; i ++)
;;;1688   		delay_spi(1000000);
000140  4a4e              LDR      r2,|L12.636|
                  |L12.322|
000142  4610              MOV      r0,r2
000144  f7fffffe          BL       delay_spi
000148  1c64              ADDS     r4,r4,#1              ;1687
00014a  b2e4              UXTB     r4,r4                 ;1687
00014c  2c32              CMP      r4,#0x32              ;1687
00014e  d3f8              BCC      |L12.322|
;;;1689   	test_ind_all(0);
000150  2000              MOVS     r0,#0
000152  f7fffffe          BL       test_ind_all
;;;1690   	init_ind(1, 8, 0);
000156  2200              MOVS     r2,#0
000158  2108              MOVS     r1,#8
00015a  2001              MOVS     r0,#1
00015c  f7fffffe          BL       init_ind
;;;1691     init_ind(2, 4, 0);   // lineika
000160  2200              MOVS     r2,#0
000162  2104              MOVS     r1,#4
000164  2002              MOVS     r0,#2
000166  f7fffffe          BL       init_ind
;;;1692   	init_ind(3, 8, 0);
00016a  2200              MOVS     r2,#0
00016c  2108              MOVS     r1,#8
00016e  2003              MOVS     r0,#3
000170  f7fffffe          BL       init_ind
;;;1693     init_ind(4, 4, 0);   // time
000174  2104              MOVS     r1,#4
000176  2200              MOVS     r2,#0
000178  4608              MOV      r0,r1
00017a  f7fffffe          BL       init_ind
;;;1694   	
;;;1695   
;;;1696   
;;;1697   // nastroika gpio
;;;1698   
;;;1699   //	GPIO_InitTypeDef  GPIO_InitStructure;                 
;;;1700   	RCC_APB2PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE); //port D
00017e  2101              MOVS     r1,#1
000180  2008              MOVS     r0,#8
000182  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;1701   	GPIO_InitStructure.GPIO_Pin   = tx_pin_en|rx_pin_en;      //  vivod for control mod-rs485
000186  2018              MOVS     r0,#0x18
;;;1702   	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;     // rezim vivoda
000188  f88d6008          STRB     r6,[sp,#8]
;;;1703   	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
;;;1704   	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;     //speed
;;;1705   	GPIO_Init(GPIOD, &GPIO_InitStructure);              
00018c  4c3c              LDR      r4,|L12.640|
00018e  9001              STR      r0,[sp,#4]            ;1702
000190  f88d600a          STRB     r6,[sp,#0xa]          ;1703
000194  f88d7009          STRB     r7,[sp,#9]            ;1704
000198  a901              ADD      r1,sp,#4
00019a  4620              MOV      r0,r4
00019c  f7fffffe          BL       GPIO_Init
;;;1706   
;;;1707   	UART2Init();
0001a0  f7fffffe          BL       UART2Init
;;;1708   	
;;;1709   	/*
;;;1710   	// nastroika na pereda4y
;;;1711   	GPIO_WriteBit(GPIOD, tx_pin_en, Bit_SET);      // GPIOD 4
;;;1712   	GPIO_WriteBit(GPIOD, rx_pin_en, Bit_SET);    //   GPIOD 3
;;;1713   	GPIOD->ODR ^= tx_pin_en;
;;;1714   */
;;;1715   	// nastroika na priem
;;;1716   	GPIO_WriteBit(GPIOD, tx_pin_en, Bit_SET);      // GPIOD 4
0001a4  2201              MOVS     r2,#1
0001a6  2110              MOVS     r1,#0x10
0001a8  4620              MOV      r0,r4
0001aa  f7fffffe          BL       GPIO_WriteBit
;;;1717   	GPIO_WriteBit(GPIOD, rx_pin_en, Bit_SET);    //   GPIOD 3
0001ae  2201              MOVS     r2,#1
0001b0  2108              MOVS     r1,#8
0001b2  4620              MOV      r0,r4
0001b4  f7fffffe          BL       GPIO_WriteBit
;;;1718   	GPIOD->ODR ^= rx_pin_en;
0001b8  4931              LDR      r1,|L12.640|
0001ba  3114              ADDS     r1,r1,#0x14
0001bc  6808              LDR      r0,[r1,#0]
0001be  f0800008          EOR      r0,r0,#8
0001c2  6008              STR      r0,[r1,#0]
;;;1719   
;;;1720   							GPIO_WriteBit(GPIOD, rx_pin_en, Bit_RESET); 
0001c4  2200              MOVS     r2,#0
0001c6  2108              MOVS     r1,#8
0001c8  4620              MOV      r0,r4
0001ca  f7fffffe          BL       GPIO_WriteBit
;;;1721   			//				USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
;;;1722   
;;;1723   NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn; //?????
0001ce  2026              MOVS     r0,#0x26
0001d0  f88d000c          STRB     r0,[sp,#0xc]
;;;1724   NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0; //?????????
0001d4  f88d500d          STRB     r5,[sp,#0xd]
;;;1725   NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;//????????? ?????????
0001d8  f88d500e          STRB     r5,[sp,#0xe]
;;;1726   NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //???????? ?????
0001dc  f88d600f          STRB     r6,[sp,#0xf]
;;;1727   NVIC_Init(&NVIC_InitStructure); //??????????????
0001e0  a803              ADD      r0,sp,#0xc
0001e2  f7fffffe          BL       NVIC_Init
;;;1728   
;;;1729   
;;;1730   // pd5 rxd  in wleif 3 contakt
;;;1731   // pd6 txd           4
;;;1732   // pd3 enabl         10
;;;1733   USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);  //???????? ?????? ?????????? ??? ??? ?????
0001e6  4c27              LDR      r4,|L12.644|
0001e8  2201              MOVS     r2,#1
0001ea  f2405125          MOV      r1,#0x525
0001ee  4620              MOV      r0,r4
0001f0  f7fffffe          BL       USART_ITConfig
;;;1734   USART_ITConfig(USART2, USART_IT_TC, ENABLE);  //???????? ?????? ?????????? ??? ??? ?????
0001f4  2201              MOVS     r2,#1
0001f6  f2406126          MOV      r1,#0x626
0001fa  4620              MOV      r0,r4
0001fc  f7fffffe          BL       USART_ITConfig
000200  4921              LDR      r1,|L12.648|
000202  2040              MOVS     r0,#0x40
000204  f04f24e0          MOV      r4,#0xe000e000
000208  6008              STR      r0,[r1,#0]
;;;1735   
;;;1736   
;;;1737   	NVIC_EnableIRQ (USART2_IRQn); // ????????? ?????????? ?? USART1
;;;1738   	/*
;;;1739     NVIC_EnableIRQ (ADC1_IRQn); // ????????? ?????????? ?? ???
;;;1740     NVIC_DisableIRQ (USART1_IRQn); // ????????? ???????
;;;1741     NVIC_DisableIRQ (ADC1_IRQn); // ??? ??? ????????? ?????????? ????
;;;1742   */
;;;1743   //	SendStringUSART2("start ver 1.0 /0"); 
;;;1744   /*
;;;1745   	txsize=10;
;;;1746   	tekper=0;
;;;1747   	for (i = 0; i < txsize ; i++)
;;;1748     {
;;;1749   		TxBuffer[i]=0x30+i;
;;;1750   	}
;;;1751   	USART_SendData(USART2, 0x3A);
;;;1752   */	
;;;1753   
;;;1754   	STM_EVAL_LEDOff(LED3);
00020a  2001              MOVS     r0,#1
00020c  f7fffffe          BL       STM_EVAL_LEDOff
;;;1755   	STM_EVAL_LEDOff(LED4);
000210  2000              MOVS     r0,#0
000212  f7fffffe          BL       STM_EVAL_LEDOff
;;;1756   	STM_EVAL_LEDOff(LED5);
000216  2002              MOVS     r0,#2
000218  f7fffffe          BL       STM_EVAL_LEDOff
;;;1757   	STM_EVAL_LEDOff(LED6);
00021c  2003              MOVS     r0,#3
00021e  f7fffffe          BL       STM_EVAL_LEDOff
;;;1758   	
;;;1759     /* SysTick end of count event each 10ms */
;;;1760     RCC_GetClocksFreq(&RCC_Clocks);
000222  4814              LDR      r0,|L12.628|
000224  3084              ADDS     r0,r0,#0x84
000226  f7fffffe          BL       RCC_GetClocksFreq
;;;1761     SysTick_Config(RCC_Clocks.HCLK_Frequency / 100);
00022a  4812              LDR      r0,|L12.628|
00022c  2164              MOVS     r1,#0x64
00022e  3084              ADDS     r0,r0,#0x84
000230  6840              LDR      r0,[r0,#4]  ; RCC_Clocks
000232  fbb0f0f1          UDIV     r0,r0,r1
000236  f1b07f80          CMP      r0,#0x1000000
00023a  d209              BCS      |L12.592|
00023c  f020407f          BIC      r0,r0,#0xff000000
000240  1e40              SUBS     r0,r0,#1
000242  6160              STR      r0,[r4,#0x14]
000244  4911              LDR      r1,|L12.652|
000246  20f0              MOVS     r0,#0xf0
000248  7008              STRB     r0,[r1,#0]
00024a  61a5              STR      r5,[r4,#0x18]
00024c  f8c48010          STR      r8,[r4,#0x10]
                  |L12.592|
;;;1762   	
;;;1763       while (1)
;;;1764     {
;;;1765       /* Host Task handler */
;;;1766       USBH_Process(&USB_OTG_Core, &USB_Host);
000250  4908              LDR      r1,|L12.628|
000252  f5a16096          SUB      r0,r1,#0x4b0
000256  f7fffffe          BL       USBH_Process
00025a  e7f9              B        |L12.592|
;;;1767     }
;;;1768     
;;;1769   #endif
;;;1770   	
;;;1771   
;;;1772     
;;;1773   }
;;;1774   
                          ENDP

                  |L12.604|
                          DCD      0x40020800
                  |L12.608|
                          DCD      ||area_number.37||
                  |L12.612|
                          DCD      LED_Toggle
                  |L12.616|
                          DCD      0x40012200
                  |L12.620|
                          DCD      USR_Callbacks
                  |L12.624|
                          DCD      USBH_MSC_cb
                  |L12.628|
                          DCD      ||.bss||+0x4b0
                  |L12.632|
                          DCD      0x40020000
                  |L12.636|
                          DCD      0x000f4240
                  |L12.640|
                          DCD      0x40020c00
                  |L12.644|
                          DCD      0x40004400
                  |L12.648|
                          DCD      0xe000e104
                  |L12.652|
                          DCD      0xe000ed23

                          AREA ||i.pin_ind||, CODE, READONLY, ALIGN=1

                  pin_ind PROC
;;;506    
;;;507    uint16_t pin_ind(u8 numb_ind)
000000  4601              MOV      r1,r0
;;;508    {
;;;509    	uint16_t  pin=0;
000002  2000              MOVS     r0,#0
;;;510    
;;;511    			switch (numb_ind-1)
000004  1e49              SUBS     r1,r1,#1
000006  d007              BEQ      |L13.24|
000008  2901              CMP      r1,#1
00000a  d007              BEQ      |L13.28|
00000c  2902              CMP      r1,#2
00000e  d007              BEQ      |L13.32|
000010  2903              CMP      r1,#3
000012  d100              BNE      |L13.22|
;;;512    			{
;;;513    				case 0x00:  // CS0   PA0
;;;514    					pin=GPIO_Pin_0;
;;;515    					break;
;;;516    
;;;517    				case 0x01:  // CS1	PA1
;;;518    					pin=GPIO_Pin_1;
;;;519    					break;
;;;520    
;;;521    				case 0x02:  // CS2	PA2
;;;522    					pin=GPIO_Pin_2;
;;;523    					break;
;;;524    
;;;525    				case 0x03:  // CS3	PA3
;;;526    					pin=GPIO_Pin_3;
000014  2008              MOVS     r0,#8
                  |L13.22|
;;;527    					break;
;;;528    				/*
;;;529    				case 0x04:  // CS4
;;;530    					pin=GPIO_Pin_4;
;;;531    					break;	
;;;532    				*/
;;;533    				default:
;;;534    					pin=0;
;;;535    					break;
;;;536    			}
;;;537    			
;;;538    			return pin;
;;;539    
;;;540    }
000016  4770              BX       lr
                  |L13.24|
000018  2001              MOVS     r0,#1                 ;514
00001a  4770              BX       lr
                  |L13.28|
00001c  2002              MOVS     r0,#2                 ;518
00001e  4770              BX       lr
                  |L13.32|
000020  2004              MOVS     r0,#4                 ;522
000022  4770              BX       lr
;;;541    void indicate_lin(u8 numb_ind,u16 zn, u16 maks, u16 max_kol_st)
                          ENDP


                          AREA ||i.settime||, CODE, READONLY, ALIGN=2

                  settime PROC
;;;264    
;;;265    void settime(void)
000000  480e              LDR      r0,|L14.60|
;;;266    {
;;;267    
;;;268    		RTC->ISR |= RTC_ISR_INIT;
000002  6801              LDR      r1,[r0,#0]
000004  f0410180          ORR      r1,r1,#0x80
000008  6001              STR      r1,[r0,#0]
                  |L14.10|
;;;269        while(!(RTC->ISR & RTC_ISR_INITF)) {}
00000a  6801              LDR      r1,[r0,#0]
00000c  0649              LSLS     r1,r1,#25
00000e  d5fc              BPL      |L14.10|
;;;270    			
;;;271    	//	rtc_SetDate(2, 6, 13, 7);
;;;272    		{
;;;273        uint32_t Tens, Units;
;;;274        uint32_t TempReg = 0;
;;;275    		uint8_t	Day=2,  Month=6,  Year=13,  DayOfWeek=7;
;;;276        
;;;277    
;;;278        TempReg = 0;
;;;279        {
;;;280            Tens  = (Year / 10) & 0x0f;          // ??????? ???
;;;281            Units = (Year - (Tens * 10)) & 0x0f; // ??????? ???
;;;282            
;;;283            TempReg |= (Tens  << 20); // YT, 20
;;;284            TempReg |= (Units << 16); // YU, 16
;;;285        }
;;;286    
;;;287        {
;;;288            Tens  = (Month / 10) & 0x01;          // ??????? ???????
;;;289            Units = (Month - (Tens * 10)) & 0x0f; // ??????? ???????
;;;290            
;;;291            TempReg |= (Tens  << 12); // MT, 12
;;;292            TempReg |= (Units << 8);  // MU, 8
;;;293        }
;;;294    
;;;295        {
;;;296            Tens  = (Day / 10) & 0x03;          // ??????? ????
;;;297            Units = (Day - (Tens * 10)) & 0x0f; // ??????? ????
;;;298            
;;;299            TempReg |= (Tens  << 4); // DT, 4
;;;300            TempReg |= (Units << 0);  // DU, 0
;;;301        }
;;;302    
;;;303        {
;;;304            TempReg |= ((DayOfWeek & 0x07) << 13); // WDU, 13
;;;305        }
;;;306        RTC->DR = TempReg;
000010  4b0a              LDR      r3,|L14.60|
000012  2200              MOVS     r2,#0                 ;288
000014  3b08              SUBS     r3,r3,#8
000016  490a              LDR      r1,|L14.64|
000018  6019              STR      r1,[r3,#0]
;;;307    		}
;;;308    			
;;;309    			
;;;310    //    rtc_SetTime(0, 0, 00);
;;;311    		
;;;312    		{
;;;313    			uint32_t Tens, Units;
;;;314    			uint32_t TempReg = 0;
;;;315    			uint8_t Hours=0,  Minutes=0,  Seconds=0;
;;;316        
;;;317        // ??????? ???? ????
;;;318        TempReg = 0;
;;;319        
;;;320        // ??????? ????
;;;321        {
;;;322            Tens  = (Hours / 10) & 0x03;          // ??????? ?????
;;;323            Units = (Hours - (Tens * 10)) & 0x0f; // ??????? ?????
;;;324            
;;;325            TempReg |= (Tens  << 20); // HT, 20
;;;326            TempReg |= (Units << 16); // HU, 16
;;;327        }
;;;328        // ??????? ??????
;;;329        {
;;;330            Tens  = (Minutes / 10) & 0x07;          // ??????? ?????
;;;331            Units = (Minutes - (Tens * 10)) & 0x0f; // ??????? ?????
;;;332            
;;;333            TempReg |= (Tens  << 12); // MNT, 12
;;;334            TempReg |= (Units << 8);  // MNU, 8
;;;335        }
;;;336        // ??????? ???????
;;;337        {
;;;338            Tens  = (Seconds / 10) & 0x07;          // ??????? ??????
;;;339            Units = (Seconds - (Tens * 10)) & 0x0f; // ??????? ??????
;;;340            
;;;341            TempReg |= (Tens  << 4); // ST, 4
;;;342            TempReg |= (Units << 0);  // SU, 0
;;;343        }
;;;344        
;;;345        // ?????????? ???? ??? ?????
;;;346        RTC->TR = TempReg;
00001a  1f19              SUBS     r1,r3,#4
00001c  600a              STR      r2,[r1,#0]
;;;347    		
;;;348    		}
;;;349            
;;;350        RTC->CR |= RTC_CR_FMT;
00001e  1d19              ADDS     r1,r3,#4
000020  680a              LDR      r2,[r1,#0]
000022  f0420240          ORR      r2,r2,#0x40
000026  600a              STR      r2,[r1,#0]
;;;351        RTC->ISR &= ~RTC_ISR_INIT;
000028  6801              LDR      r1,[r0,#0]
00002a  f0210180          BIC      r1,r1,#0x80
00002e  6001              STR      r1,[r0,#0]
;;;352    		RTC->WPR = 0xFF;
000030  4902              LDR      r1,|L14.60|
000032  20ff              MOVS     r0,#0xff
000034  3118              ADDS     r1,r1,#0x18
000036  6008              STR      r0,[r1,#0]
;;;353    	
;;;354    }
000038  4770              BX       lr
;;;355    
                          ENDP

00003a  0000              DCW      0x0000
                  |L14.60|
                          DCD      0x4000280c
                  |L14.64|
                          DCD      0x0013e602

                          AREA ||i.sohr_backup||, CODE, READONLY, ALIGN=1

                  sohr_backup PROC
;;;355    
;;;356    void sohr_backup(u16 kol_byte,uint8_t* buf)
000000  4770              BX       lr
;;;357    {
;;;358    
;;;359    }
;;;360    
                          ENDP


                          AREA ||i.spi1_init||, CODE, READONLY, ALIGN=2

                  spi1_init PROC
;;;397    
;;;398    void spi1_init() {
000000  b530              PUSH     {r4,r5,lr}
;;;399    	SPI_InitTypeDef spi1;
;;;400    	 GPIO_InitTypeDef gpio;
;;;401    	
;;;402        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);  // ???????????? ?????
000002  2101              MOVS     r1,#1
000004  b087              SUB      sp,sp,#0x1c           ;398
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;403        RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);  // ???????????? SPI1 
00000c  2101              MOVS     r1,#1
00000e  0308              LSLS     r0,r1,#12
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;404       
;;;405        GPIO_StructInit(&gpio);
000014  a805              ADD      r0,sp,#0x14
000016  f7fffffe          BL       GPIO_StructInit
;;;406        gpio.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
00001a  20e0              MOVS     r0,#0xe0
;;;407        gpio.GPIO_Mode = GPIO_Mode_AF;
00001c  9005              STR      r0,[sp,#0x14]
00001e  2002              MOVS     r0,#2
000020  f88d0018          STRB     r0,[sp,#0x18]
;;;408        gpio.GPIO_Speed = GPIO_Speed_2MHz;
000024  2400              MOVS     r4,#0
000026  f88d4019          STRB     r4,[sp,#0x19]
;;;409        gpio.GPIO_OType = GPIO_OType_PP;
00002a  f88d401a          STRB     r4,[sp,#0x1a]
;;;410        gpio.GPIO_PuPd = GPIO_PuPd_DOWN;
;;;411        GPIO_Init(GPIOA,&gpio);
00002e  4d1a              LDR      r5,|L16.152|
000030  f88d001b          STRB     r0,[sp,#0x1b]         ;410
000034  a905              ADD      r1,sp,#0x14
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       GPIO_Init
;;;412        GPIO_PinAFConfig(GPIOA,GPIO_PinSource5,GPIO_AF_SPI1);
00003c  2205              MOVS     r2,#5
00003e  4611              MOV      r1,r2
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       GPIO_PinAFConfig
;;;413        GPIO_PinAFConfig(GPIOA,GPIO_PinSource6,GPIO_AF_SPI1);
000046  2205              MOVS     r2,#5
000048  2106              MOVS     r1,#6
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       GPIO_PinAFConfig
;;;414        GPIO_PinAFConfig(GPIOA,GPIO_PinSource7,GPIO_AF_SPI1);
000050  2205              MOVS     r2,#5
000052  2107              MOVS     r1,#7
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       GPIO_PinAFConfig
;;;415        SPI_I2S_DeInit(SPI1);
00005a  4d10              LDR      r5,|L16.156|
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       SPI_I2S_DeInit
;;;416        
;;;417        SPI_StructInit(&spi1);
000062  4668              MOV      r0,sp
000064  f7fffffe          BL       SPI_StructInit
;;;418        spi1.SPI_Mode = SPI_Mode_Master;
000068  f44f7082          MOV      r0,#0x104
00006c  f8ad0002          STRH     r0,[sp,#2]
;;;419        spi1.SPI_DataSize = SPI_DataSize_8b; //SPI_DataSize_16b;		
;;;420        spi1.SPI_NSS = SPI_NSS_Soft;
000070  1568              ASRS     r0,r5,#21
000072  f8ad000a          STRH     r0,[sp,#0xa]
;;;421    
;;;422      spi1.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;
000076  2038              MOVS     r0,#0x38
000078  f8ad000c          STRH     r0,[sp,#0xc]
00007c  f8ad4004          STRH     r4,[sp,#4]            ;419
;;;423      spi1.SPI_FirstBit = SPI_FirstBit_MSB;
000080  f8ad400e          STRH     r4,[sp,#0xe]
;;;424    	
;;;425        SPI_Init(SPI1,&spi1);
000084  4669              MOV      r1,sp
000086  4628              MOV      r0,r5
000088  f7fffffe          BL       SPI_Init
;;;426        SPI_Cmd(SPI1,ENABLE);
00008c  2101              MOVS     r1,#1
00008e  4628              MOV      r0,r5
000090  f7fffffe          BL       SPI_Cmd
;;;427    }
000094  b007              ADD      sp,sp,#0x1c
000096  bd30              POP      {r4,r5,pc}
;;;428    
                          ENDP

                  |L16.152|
                          DCD      0x40020000
                  |L16.156|
                          DCD      0x40013000

                          AREA ||i.spi2_init||, CODE, READONLY, ALIGN=2

                  spi2_init PROC
;;;429    
;;;430    void spi2_init() {
000000  b530              PUSH     {r4,r5,lr}
000002  b087              SUB      sp,sp,#0x1c
;;;431    	SPI_InitTypeDef spi2;
;;;432    	 GPIO_InitTypeDef gpio;
;;;433    	
;;;434        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB,ENABLE);
000004  2101              MOVS     r1,#1
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;435        RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,ENABLE);
00000c  2101              MOVS     r1,#1
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;436       
;;;437        GPIO_StructInit(&gpio);
000014  a805              ADD      r0,sp,#0x14
000016  f7fffffe          BL       GPIO_StructInit
;;;438        gpio.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
00001a  f44f4060          MOV      r0,#0xe000
;;;439        gpio.GPIO_Mode = GPIO_Mode_AF;
00001e  9005              STR      r0,[sp,#0x14]
000020  2002              MOVS     r0,#2
000022  f88d0018          STRB     r0,[sp,#0x18]
;;;440        gpio.GPIO_Speed = GPIO_Speed_50MHz;
000026  f88d0019          STRB     r0,[sp,#0x19]
;;;441        gpio.GPIO_OType = GPIO_OType_PP;
00002a  2400              MOVS     r4,#0
00002c  f88d401a          STRB     r4,[sp,#0x1a]
;;;442        gpio.GPIO_PuPd = GPIO_PuPd_DOWN;
;;;443        GPIO_Init(GPIOB,&gpio);
000030  4d17              LDR      r5,|L17.144|
000032  f88d001b          STRB     r0,[sp,#0x1b]         ;442
000036  a905              ADD      r1,sp,#0x14
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       GPIO_Init
;;;444        GPIO_PinAFConfig(GPIOB,GPIO_PinSource13,GPIO_AF_SPI2);
00003e  2205              MOVS     r2,#5
000040  210d              MOVS     r1,#0xd
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       GPIO_PinAFConfig
;;;445        GPIO_PinAFConfig(GPIOB,GPIO_PinSource14,GPIO_AF_SPI2);
000048  2205              MOVS     r2,#5
00004a  210e              MOVS     r1,#0xe
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       GPIO_PinAFConfig
;;;446        GPIO_PinAFConfig(GPIOB,GPIO_PinSource15,GPIO_AF_SPI2);
000052  2205              MOVS     r2,#5
000054  210f              MOVS     r1,#0xf
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       GPIO_PinAFConfig
;;;447        SPI_I2S_DeInit(SPI2);
00005c  4d0d              LDR      r5,|L17.148|
00005e  4628              MOV      r0,r5
000060  f7fffffe          BL       SPI_I2S_DeInit
;;;448        
;;;449        SPI_StructInit(&spi2);
000064  4668              MOV      r0,sp
000066  f7fffffe          BL       SPI_StructInit
;;;450        spi2.SPI_Mode = SPI_Mode_Slave;
;;;451        spi2.SPI_DataSize = SPI_DataSize_16b;
00006a  14e9              ASRS     r1,r5,#19
;;;452        spi2.SPI_NSS = SPI_NSS_Soft;
00006c  1088              ASRS     r0,r1,#2
00006e  f8ad1004          STRH     r1,[sp,#4]            ;451
000072  f8ad000a          STRH     r0,[sp,#0xa]
000076  f8ad4002          STRH     r4,[sp,#2]            ;450
;;;453        SPI_Init(SPI2,&spi2);
00007a  4669              MOV      r1,sp
00007c  4628              MOV      r0,r5
00007e  f7fffffe          BL       SPI_Init
;;;454        SPI_Cmd(SPI2,ENABLE);
000082  2101              MOVS     r1,#1
000084  4628              MOV      r0,r5
000086  f7fffffe          BL       SPI_Cmd
;;;455    }
00008a  b007              ADD      sp,sp,#0x1c
00008c  bd30              POP      {r4,r5,pc}
;;;456    
                          ENDP

00008e  0000              DCW      0x0000
                  |L17.144|
                          DCD      0x40020400
                  |L17.148|
                          DCD      0x40003800

                          AREA ||i.spi_init||, CODE, READONLY, ALIGN=2

                  spi_init PROC
;;;360    
;;;361    void spi_init(){
000000  b510              PUSH     {r4,lr}
;;;362    
;;;363    		GPIO_InitTypeDef GPIO_InitStructure;
;;;364        GPIO_InitTypeDef gpio;
;;;365    	  SPI_InitTypeDef spi1;
;;;366    	
;;;367        RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA,ENABLE);  // ???????????? ?????
000002  2101              MOVS     r1,#1
000004  b088              SUB      sp,sp,#0x20           ;361
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;368        RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,ENABLE);  // ???????????? SPI1
00000c  2101              MOVS     r1,#1
00000e  0308              LSLS     r0,r1,#12
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;369    
;;;370        GPIO_StructInit(&gpio);
000014  a805              ADD      r0,sp,#0x14
000016  f7fffffe          BL       GPIO_StructInit
;;;371    /*
;;;372         gpio.GPIO_Pin   = GPIO_Pin_4;   // NSS
;;;373         gpio.GPIO_Mode  = GPIO_Mode_OUT;
;;;374         gpio.GPIO_Speed = GPIO_Speed_50MHz;
;;;375         gpio.GPIO_OType = GPIO_OType_PP;
;;;376         gpio.GPIO_PuPd  = GPIO_PuPd_NOPULL;
;;;377         GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;378    */
;;;379        gpio.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
00001a  20e0              MOVS     r0,#0xe0
;;;380        gpio.GPIO_Mode = GPIO_Mode_AF;
00001c  9005              STR      r0,[sp,#0x14]
00001e  2002              MOVS     r0,#2
000020  f88d0018          STRB     r0,[sp,#0x18]
;;;381        gpio.GPIO_Speed = GPIO_Speed_50MHz;
000024  f88d0019          STRB     r0,[sp,#0x19]
;;;382        gpio.GPIO_OType = GPIO_OType_PP;
000028  2100              MOVS     r1,#0
00002a  f88d101a          STRB     r1,[sp,#0x1a]
;;;383        gpio.GPIO_PuPd = GPIO_PuPd_DOWN;
;;;384        GPIO_Init(GPIOA,&gpio);
00002e  4c18              LDR      r4,|L18.144|
000030  f88d001b          STRB     r0,[sp,#0x1b]         ;383
000034  a905              ADD      r1,sp,#0x14
000036  4620              MOV      r0,r4
000038  f7fffffe          BL       GPIO_Init
;;;385        GPIO_PinAFConfig(GPIOA,GPIO_PinSource5,GPIO_AF_SPI1);   
00003c  2205              MOVS     r2,#5
00003e  4611              MOV      r1,r2
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       GPIO_PinAFConfig
;;;386        GPIO_PinAFConfig(GPIOA,GPIO_PinSource6,GPIO_AF_SPI1);
000046  2205              MOVS     r2,#5
000048  2106              MOVS     r1,#6
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       GPIO_PinAFConfig
;;;387        GPIO_PinAFConfig(GPIOA,GPIO_PinSource7,GPIO_AF_SPI1);
000050  2205              MOVS     r2,#5
000052  2107              MOVS     r1,#7
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       GPIO_PinAFConfig
;;;388        SPI_I2S_DeInit(SPI1);
00005a  4c0e              LDR      r4,|L18.148|
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       SPI_I2S_DeInit
;;;389    
;;;390        SPI_StructInit(&spi1);
000062  4668              MOV      r0,sp
000064  f7fffffe          BL       SPI_StructInit
;;;391        spi1.SPI_Mode = SPI_Mode_Master;
000068  f44f7182          MOV      r1,#0x104
00006c  f8ad1002          STRH     r1,[sp,#2]
;;;392        spi1.SPI_DataSize = SPI_DataSize_16b;
000070  14e1              ASRS     r1,r4,#19
000072  f8ad1004          STRH     r1,[sp,#4]
;;;393        spi1.SPI_NSS = SPI_NSS_Soft;
000076  1089              ASRS     r1,r1,#2
000078  f8ad100a          STRH     r1,[sp,#0xa]
;;;394        SPI_Init(SPI1,&spi1);
00007c  4669              MOV      r1,sp
00007e  4620              MOV      r0,r4
000080  f7fffffe          BL       SPI_Init
;;;395        SPI_Cmd(SPI1,ENABLE);
000084  2101              MOVS     r1,#1
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       SPI_Cmd
;;;396    }
00008c  b008              ADD      sp,sp,#0x20
00008e  bd10              POP      {r4,pc}
;;;397    
                          ENDP

                  |L18.144|
                          DCD      0x40020000
                  |L18.148|
                          DCD      0x40013000

                          AREA ||i.spi_receve||, CODE, READONLY, ALIGN=2

                  spi_receve PROC
;;;461    }
;;;462    uint16_t spi_receve() {
000000  b510              PUSH     {r4,lr}
;;;463    		uint16_t received;
;;;464        while (SPI_I2S_GetFlagStatus(SPI2, SPI_I2S_FLAG_RXNE) == RESET);  // ???? ???? ?????? ???????
000002  4c06              LDR      r4,|L19.28|
                  |L19.4|
000004  2101              MOVS     r1,#1
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000c  2800              CMP      r0,#0
00000e  d0f9              BEQ      |L19.4|
;;;465        received = SPI_I2S_ReceiveData(SPI2);
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      SPI_I2S_ReceiveData
;;;466        return received;
;;;467    }
;;;468    
                          ENDP

00001a  0000              DCW      0x0000
                  |L19.28|
                          DCD      0x40003800

                          AREA ||i.spi_send||, CODE, READONLY, ALIGN=2

                  spi_send PROC
;;;457    
;;;458    void spi_send(uint16_t data) {
000000  b510              PUSH     {r4,lr}
;;;459    	SPI_I2S_SendData(SPI1,data);
000002  4c06              LDR      r4,|L20.28|
000004  4601              MOV      r1,r0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       SPI_I2S_SendData
                  |L20.12|
;;;460        while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE) == RESET);  // ???? ???? ?????? ?????
00000c  2102              MOVS     r1,#2
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       SPI_I2S_GetFlagStatus
000014  2800              CMP      r0,#0
000016  d0f9              BEQ      |L20.12|
;;;461    }
000018  bd10              POP      {r4,pc}
;;;462    uint16_t spi_receve() {
                          ENDP

00001a  0000              DCW      0x0000
                  |L20.28|
                          DCD      0x40013000

                          AREA ||i.test_ind||, CODE, READONLY, ALIGN=2

                  test_ind PROC
;;;1060   
;;;1061   void test_ind(u8 numb_ind)
000000  b570              PUSH     {r4-r6,lr}
;;;1062   {
;;;1063   	uint16_t  pin=0;
;;;1064   	 /*
;;;1065   			switch (numb_ind)
;;;1066   			{
;;;1067   				case 0x00:  // CS0
;;;1068   					pin=GPIO_Pin_0;
;;;1069   					break;
;;;1070   
;;;1071   				case 0x01:  // CS1
;;;1072   					pin=GPIO_Pin_1;
;;;1073   					break;
;;;1074   
;;;1075   				case 0x02:  // CS2
;;;1076   					pin=GPIO_Pin_2;
;;;1077   					break;
;;;1078   
;;;1079   				case 0x03:  // CS3
;;;1080   					pin=GPIO_Pin_3;
;;;1081   					break;
;;;1082   
;;;1083   				case 0x04:  // CS4
;;;1084   					pin=GPIO_Pin_4;
;;;1085   					break;								
;;;1086   			}
;;;1087   			*/
;;;1088   			
;;;1089   			pin=pin_ind(numb_ind);
000002  f7fffffe          BL       pin_ind
000006  0004              MOVS     r4,r0
;;;1090   		if (pin==0)
000008  d01f              BEQ      |L21.74|
;;;1091   				return ;			
;;;1092   
;;;1093   				GPIO_WriteBit(GPIOA, pin, Bit_RESET);      //   GPIOB.2
00000a  4d10              LDR      r5,|L21.76|
00000c  4601              MOV      r1,r0
00000e  2200              MOVS     r2,#0
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       GPIO_WriteBit
;;;1094   				delay_spi(100);
000016  2064              MOVS     r0,#0x64
000018  f7fffffe          BL       delay_spi
;;;1095   				spi_send(0x0f);delay_spi(100);
00001c  200f              MOVS     r0,#0xf
00001e  f7fffffe          BL       spi_send
000022  2064              MOVS     r0,#0x64
000024  f7fffffe          BL       delay_spi
;;;1096   				spi_send(0x01); delay_spi(100);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       spi_send
00002e  2064              MOVS     r0,#0x64
000030  f7fffffe          BL       delay_spi
;;;1097   				GPIO_WriteBit(GPIOA, pin, Bit_SET);      //   GPIOB.2
000034  2201              MOVS     r2,#1
000036  4621              MOV      r1,r4
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       GPIO_WriteBit
;;;1098   				delay_spi(1000);
00003e  e8bd4070          POP      {r4-r6,lr}
000042  f44f707a          MOV      r0,#0x3e8
000046  f7ffbffe          B.W      delay_spi
                  |L21.74|
;;;1099   }
00004a  bd70              POP      {r4-r6,pc}
;;;1100   
                          ENDP

                  |L21.76|
                          DCD      0x40020000

                          AREA ||i.test_ind_all||, CODE, READONLY, ALIGN=2

                  test_ind_all PROC
;;;480    
;;;481    void test_ind_all(u8 rez)
000000  b570              PUSH     {r4-r6,lr}
;;;482    {
;;;483    	
;;;484    				GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_RESET); 	delay_spi(zad_spi);
000002  4d3a              LDR      r5,|L22.236|
000004  4606              MOV      r6,r0                 ;482
000006  2200              MOVS     r2,#0
000008  2101              MOVS     r1,#1
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       GPIO_WriteBit
000010  4c37              LDR      r4,|L22.240|
000012  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
000014  f7fffffe          BL       delay_spi
;;;485    				spi_send(0x0f); delay_spi(zad_spi);				
000018  200f              MOVS     r0,#0xf
00001a  f7fffffe          BL       spi_send
00001e  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
000020  f7fffffe          BL       delay_spi
;;;486    				spi_send(rez);  delay_spi(zad_spi);
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       spi_send
00002a  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
00002c  f7fffffe          BL       delay_spi
;;;487    				GPIO_WriteBit(GPIOA, GPIO_Pin_0, Bit_SET);		delay_spi(zad_spi2);
000030  2201              MOVS     r2,#1
000032  4611              MOV      r1,r2
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       GPIO_WriteBit
00003a  69e0              LDR      r0,[r4,#0x1c]  ; zad_spi2
00003c  f7fffffe          BL       delay_spi
;;;488    
;;;489    				GPIO_WriteBit(GPIOA, GPIO_Pin_1, Bit_RESET); 	delay_spi(zad_spi);
000040  2200              MOVS     r2,#0
000042  2102              MOVS     r1,#2
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       GPIO_WriteBit
00004a  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
00004c  f7fffffe          BL       delay_spi
;;;490    				spi_send(0x0f); delay_spi(zad_spi);				
000050  200f              MOVS     r0,#0xf
000052  f7fffffe          BL       spi_send
000056  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
000058  f7fffffe          BL       delay_spi
;;;491    				spi_send(rez);  delay_spi(zad_spi);
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       spi_send
000062  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
000064  f7fffffe          BL       delay_spi
;;;492    				GPIO_WriteBit(GPIOA, GPIO_Pin_1, Bit_SET);		delay_spi(zad_spi2);
000068  2201              MOVS     r2,#1
00006a  2102              MOVS     r1,#2
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       GPIO_WriteBit
000072  69e0              LDR      r0,[r4,#0x1c]  ; zad_spi2
000074  f7fffffe          BL       delay_spi
;;;493    
;;;494    				GPIO_WriteBit(GPIOA, GPIO_Pin_2, Bit_RESET); 	delay_spi(zad_spi);
000078  2200              MOVS     r2,#0
00007a  2104              MOVS     r1,#4
00007c  4628              MOV      r0,r5
00007e  f7fffffe          BL       GPIO_WriteBit
000082  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
000084  f7fffffe          BL       delay_spi
;;;495    				spi_send(0x0f); delay_spi(zad_spi);				
000088  200f              MOVS     r0,#0xf
00008a  f7fffffe          BL       spi_send
00008e  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
000090  f7fffffe          BL       delay_spi
;;;496    				spi_send(rez);  delay_spi(zad_spi);
000094  4630              MOV      r0,r6
000096  f7fffffe          BL       spi_send
00009a  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
00009c  f7fffffe          BL       delay_spi
;;;497    				GPIO_WriteBit(GPIOA, GPIO_Pin_2, Bit_SET);		delay_spi(zad_spi2);
0000a0  2201              MOVS     r2,#1
0000a2  2104              MOVS     r1,#4
0000a4  4628              MOV      r0,r5
0000a6  f7fffffe          BL       GPIO_WriteBit
0000aa  69e0              LDR      r0,[r4,#0x1c]  ; zad_spi2
0000ac  f7fffffe          BL       delay_spi
;;;498    
;;;499    				GPIO_WriteBit(GPIOA, GPIO_Pin_3, Bit_RESET); 	delay_spi(zad_spi);
0000b0  2200              MOVS     r2,#0
0000b2  2108              MOVS     r1,#8
0000b4  4628              MOV      r0,r5
0000b6  f7fffffe          BL       GPIO_WriteBit
0000ba  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
0000bc  f7fffffe          BL       delay_spi
;;;500    				spi_send(0x0f); delay_spi(zad_spi);				
0000c0  200f              MOVS     r0,#0xf
0000c2  f7fffffe          BL       spi_send
0000c6  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
0000c8  f7fffffe          BL       delay_spi
;;;501    				spi_send(rez);  delay_spi(zad_spi);
0000cc  4630              MOV      r0,r6
0000ce  f7fffffe          BL       spi_send
0000d2  69a0              LDR      r0,[r4,#0x18]  ; zad_spi
0000d4  f7fffffe          BL       delay_spi
;;;502    				GPIO_WriteBit(GPIOA, GPIO_Pin_3, Bit_SET);		delay_spi(zad_spi2);	
0000d8  2201              MOVS     r2,#1
0000da  2108              MOVS     r1,#8
0000dc  4628              MOV      r0,r5
0000de  f7fffffe          BL       GPIO_WriteBit
0000e2  69e0              LDR      r0,[r4,#0x1c]  ; zad_spi2
0000e4  e8bd4070          POP      {r4-r6,lr}
0000e8  f7ffbffe          B.W      delay_spi
;;;503    	
;;;504    				
;;;505    }
;;;506    
                          ENDP

                  |L22.236|
                          DCD      0x40020000
                  |L22.240|
                          DCD      ||area_number.37||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USB_OTG_Core
                          %        1200
                  USB_Host
                          %        132
                  RCC_Clocks
                          %        16
                  RxBuffer
                          %        500
                  TxBuffer
                          %        500

                          AREA ||area_number.25||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.25||, ||.bss||
                  Buf_adc_zap1
                          %        2000

                          AREA ||area_number.26||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.26||, ||.bss||
                  Buf_adc_zap2
                          %        2000

                          AREA ||area_number.27||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.27||, ||.bss||
                  Buf_zap
                          %        6000

                          AREA ||area_number.28||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.28||, ||.bss||
                  average
                          %        20

                          AREA ||area_number.29||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.29||, ||.bss||
                  summa
                          %        20

                          AREA ||area_number.30||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.30||, ||.bss||
                  ||fz||
                          %        20

                          AREA ||area_number.31||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.31||, ||.bss||
                  fz_average
                          %        20

                          AREA ||area_number.32||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.32||, ||.bss||
                  max
                          %        20

                          AREA ||area_number.33||, DATA, NOINIT, ALIGN=1

                          EXPORTAS ||area_number.33||, ||.bss||
                  conf
                          %        190

                          AREA ||.data||, DATA, ALIGN=0

                  ||in||
000000  00                DCB      0x00

                          AREA ||area_number.36||, DATA, ALIGN=0

                          EXPORTAS ||area_number.36||, ||.data||
                  poz
000000  00                DCB      0x00

                          AREA ||area_number.37||, DATA, ALIGN=2

                          EXPORTAS ||area_number.37||, ||.data||
                  kol
000000  00                DCB      0x00
                  RepeatState
000001  00                DCB      0x00
                  new_komand
000002  0000              DCB      0x00,0x00
                  CCR_Val
000004  41ba              DCW      0x41ba
                  ADC3ConvertedValue
000006  0000              DCW      0x0000
                  txsize
000008  0000              DCB      0x00,0x00
                  rxsize
00000a  0000              DCB      0x00,0x00
                  tekper
00000c  0000              DCB      0x00,0x00
                  tekpr
00000e  0000              DCB      0x00,0x00
                  tmp
                          DCD      0x00000000
                  fl_tmp
000014  00000000          DCFS     0x00000000 ; 0
                  zad_spi
                          DCD      0x00002710
                  zad_spi2
                          DCD      0x000186a0
                  symb_code
000020  7e306d79          DCB      0x7e,0x30,0x6d,0x79
000024  335b5f70          DCB      0x33,0x5b,0x5f,0x70
000028  7f7b4f79          DCB      0x7f,0x7b,0x4f,0x79
00002c  80                DCB      0x80
                  symb_code_min
00002d  7e30ec            DCB      0x7e,0x30,0xec
000030  f8b2dade          DCB      0xf8,0xb2,0xda,0xde
000034  70feface          DCB      0x70,0xfe,0xfa,0xce
000038  f801              DCB      0xf8,0x01

                          AREA ||area_number.38||, DATA, ALIGN=2

                          EXPORTAS ||area_number.38||, ||.data||
                  tick
                          DCD      0x00000000

                          AREA ||area_number.39||, DATA, ALIGN=0

                          EXPORTAS ||area_number.39||, ||.data||
                  number_buff
000000  00                DCB      0x00

                          AREA ||area_number.40||, DATA, ALIGN=1

                          EXPORTAS ||area_number.40||, ||.data||
                  time_label
000000  0000              DCW      0x0000

                          AREA ||area_number.41||, DATA, ALIGN=1

                          EXPORTAS ||area_number.41||, ||.data||
                  por
000000  0000              DCW      0x0000

                          AREA ||area_number.42||, DATA, ALIGN=0

                          EXPORTAS ||area_number.42||, ||.data||
                  counter
000000  00                DCB      0x00

                          AREA ||area_number.43||, DATA, ALIGN=0

                          EXPORTAS ||area_number.43||, ||.data||
                  tmp1
000000  00                DCB      0x00

                          AREA ||area_number.44||, DATA, ALIGN=0

                          EXPORTAS ||area_number.44||, ||.data||
                  tmp2
000000  00                DCB      0x00

                          AREA ||area_number.45||, DATA, ALIGN=0

                          EXPORTAS ||area_number.45||, ||.data||
                  tmp3
000000  00                DCB      0x00

                          AREA ||area_number.46||, DATA, ALIGN=0

                          EXPORTAS ||area_number.46||, ||.data||
                  tmp4
000000  00                DCB      0x00

                          AREA ||area_number.47||, DATA, ALIGN=0

                          EXPORTAS ||area_number.47||, ||.data||
                  ||sm||
000000  00                DCB      0x00

                          AREA ||area_number.48||, DATA, ALIGN=1

                          EXPORTAS ||area_number.48||, ||.data||
                  ||cnt||
000000  0000              DCW      0x0000

                          AREA ||area_number.49||, DATA, ALIGN=1

                          EXPORTAS ||area_number.49||, ||.data||
                  kol_zap
000000  0000              DCW      0x0000

                          AREA ||area_number.50||, DATA, ALIGN=0

                          EXPORTAS ||area_number.50||, ||.data||
                  file_cr
000000  00                DCB      0x00

                          AREA ||area_number.51||, DATA, ALIGN=0

                          EXPORTAS ||area_number.51||, ||.data||
                  buffering
000000  00                DCB      0x00

                          AREA ||area_number.52||, DATA, ALIGN=1

                          EXPORTAS ||area_number.52||, ||.data||
                  ||del||
000000  0000              DCW      0x0000

                          AREA ||area_number.53||, DATA, ALIGN=1

                          EXPORTAS ||area_number.53||, ||.data||
                  minute
000000  0000              DCW      0x0000

                          AREA ||area_number.54||, DATA, ALIGN=1

                          EXPORTAS ||area_number.54||, ||.data||
                  pred_minute
000000  0000              DCW      0x0000

                          AREA ||area_number.55||, DATA, ALIGN=0

                          EXPORTAS ||area_number.55||, ||.data||
                  sost_pribl
000000  00                DCB      0x00

                          AREA ||area_number.56||, DATA, ALIGN=0

                          EXPORTAS ||area_number.56||, ||.data||
                  kol_average
000000  00                DCB      0x00

                          AREA ||area_number.57||, DATA, ALIGN=0

                          EXPORTAS ||area_number.57||, ||.data||
                  address
000000  01                DCB      0x01

                          AREA ||area_number.58||, DATA, ALIGN=1

                          EXPORTAS ||area_number.58||, ||.data||
                  SPI1_Buffer_Tx
000000  01020304          DCW      0x0102,0x0304
000004  05060708          DCW      0x0506,0x0708
000008  090a0b0c          DCW      0x090a,0x0b0c
00000c  0d0e0f10          DCW      0x0d0e,0x0f10
000010  11121314          DCW      0x1112,0x1314
000014  15161718          DCW      0x1516,0x1718
000018  191a1b1c          DCW      0x191a,0x1b1c
00001c  1d1e1f20          DCW      0x1d1e,0x1f20
000020  21222324          DCW      0x2122,0x2324
000024  25262728          DCW      0x2526,0x2728
000028  292a2b2c          DCW      0x292a,0x2b2c
00002c  2d2e2f30          DCW      0x2d2e,0x2f30
000030  31323334          DCW      0x3132,0x3334
000034  35363738          DCW      0x3536,0x3738
000038  393a3b3c          DCW      0x393a,0x3b3c
00003c  3d3e3f40          DCW      0x3d3e,0x3f40

                          AREA ||area_number.59||, DATA, ALIGN=0

                          EXPORTAS ||area_number.59||, ||.data||
                  smes
000000  00                DCB      0x00

                          AREA ||area_number.60||, DATA, ALIGN=2

                          EXPORTAS ||area_number.60||, ||.data||
                  pr_tick
                          DCD      0x00000000

                          AREA ||area_number.61||, DATA, ALIGN=1

                          EXPORTAS ||area_number.61||, ||.data||
                  tek_kol
000000  0000              DCW      0x0000

                          AREA ||area_number.62||, DATA, ALIGN=1

                          EXPORTAS ||area_number.62||, ||.data||
                  kol_usr
000000  0000              DCW      0x0000

                          AREA ||area_number.63||, DATA, ALIGN=2

                          EXPORTAS ||area_number.63||, ||.data||
                  buf_sum
                          DCD      0x00000000

                          AREA ||area_number.64||, DATA, ALIGN=1

                          EXPORTAS ||area_number.64||, ||.data||
                  kol_pribl_vikl
000000  0000              DCW      0x0000

                          AREA ||area_number.65||, DATA, ALIGN=1

                          EXPORTAS ||area_number.65||, ||.data||
                  kol_pribl_vkl
000000  0000              DCW      0x0000

                          AREA ||area_number.66||, DATA, ALIGN=1

                          EXPORTAS ||area_number.66||, ||.data||
                  kol_gr1_vkl
000000  0000              DCW      0x0000

                          AREA ||area_number.67||, DATA, ALIGN=1

                          EXPORTAS ||area_number.67||, ||.data||
                  kol_gr2_vkl
000000  0000              DCW      0x0000

                          AREA ||area_number.68||, DATA, ALIGN=0

                          EXPORTAS ||area_number.68||, ||.data||
                  avariya
000000  00                DCB      0x00

                          AREA ||area_number.69||, DATA, ALIGN=0

                          EXPORTAS ||area_number.69||, ||.data||
                  sost_flesh
000000  00                DCB      0x00

                          AREA ||area_number.70||, DATA, ALIGN=0

                          EXPORTAS ||area_number.70||, ||.data||
                  DT_zap
                          DCDU     0x00000000
000004  000000            DCB      0x00,0x00,0x00

                          AREA ||area_number.71||, DATA, ALIGN=1

                          EXPORTAS ||area_number.71||, ||.data||
                  bytesWritten
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.72||, DATA, ALIGN=1

                          EXPORTAS ||area_number.72||, ||.data||
                  zad
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.73||, DATA, ALIGN=1

                          EXPORTAS ||area_number.73||, ||.data||
                  ||ms||
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.74||, DATA, ALIGN=1

                          EXPORTAS ||area_number.74||, ||.data||
                  kolkor
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.75||, DATA, ALIGN=1

                          EXPORTAS ||area_number.75||, ||.data||
                  tekkor
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.76||, DATA, ALIGN=1

                          EXPORTAS ||area_number.76||, ||.data||
                  flper
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.77||, DATA, ALIGN=1

                          EXPORTAS ||area_number.77||, ||.data||
                  tmo
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.78||, DATA, ALIGN=1

                          EXPORTAS ||area_number.78||, ||.data||
                  pertmo
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "src\\main.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_main_c_in____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___6_main_c_in____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_main_c_in____REVSH|
#line 128
|__asm___6_main_c_in____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
