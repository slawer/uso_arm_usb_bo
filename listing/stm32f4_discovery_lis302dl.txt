; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\MEDIA_USB_KEY\stm32f4_discovery_lis302dl.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\MEDIA_USB_KEY\stm32f4_discovery_lis302dl.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\MEDIA_USB_KEY\stm32f4_discovery_lis302dl.crf Utilities\STM32F4-Discovery\stm32f4_discovery_lis302dl.c]
                          THUMB

                          AREA ||i.LIS302DL_DataRateCmd||, CODE, READONLY, ALIGN=1

                  LIS302DL_DataRateCmd PROC
;;;193      */
;;;194    void LIS302DL_DataRateCmd(uint8_t DataRateValue)
000000  b538              PUSH     {r3-r5,lr}
;;;195    {
000002  4604              MOV      r4,r0
;;;196      uint8_t tmpreg;
;;;197      
;;;198      /* Read CTRL_REG1 register */
;;;199      LIS302DL_Read(&tmpreg, LIS302DL_CTRL_REG1_ADDR, 1);
000004  2201              MOVS     r2,#1
000006  2120              MOVS     r1,#0x20
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       LIS302DL_Read
;;;200      
;;;201      /* Set new Data rate configuration */
;;;202      tmpreg &= (uint8_t)~LIS302DL_DATARATE_400;
00000e  f89d1000          LDRB     r1,[sp,#0]
;;;203      tmpreg |= DataRateValue;
;;;204      
;;;205      /* Write value to MEMS CTRL_REG1 regsister */
;;;206      LIS302DL_Write(&tmpreg, LIS302DL_CTRL_REG1_ADDR, 1);
000012  2201              MOVS     r2,#1
000014  f001017f          AND      r1,r1,#0x7f           ;202
000018  4321              ORRS     r1,r1,r4              ;203
00001a  f88d1000          STRB     r1,[sp,#0]            ;203
00001e  2120              MOVS     r1,#0x20
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       LIS302DL_Write
;;;207    }
000026  bd38              POP      {r3-r5,pc}
;;;208    
                          ENDP


                          AREA ||i.LIS302DL_FilterConfig||, CODE, READONLY, ALIGN=1

                  LIS302DL_FilterConfig PROC
;;;120      */
;;;121    void LIS302DL_FilterConfig(LIS302DL_FilterConfigTypeDef *LIS302DL_FilterConfigStruct)
000000  b538              PUSH     {r3-r5,lr}
;;;122    {
000002  4604              MOV      r4,r0
;;;123      uint8_t ctrl = 0x00;
000004  2000              MOVS     r0,#0
000006  f88d0000          STRB     r0,[sp,#0]
;;;124      
;;;125      /* Read CTRL_REG2 register */
;;;126      LIS302DL_Read(&ctrl, LIS302DL_CTRL_REG2_ADDR, 1);
00000a  2201              MOVS     r2,#1
00000c  2121              MOVS     r1,#0x21
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       LIS302DL_Read
;;;127      
;;;128      /* Clear high pass filter cut-off level, interrupt and data selection bits*/
;;;129      ctrl &= (uint8_t)~(LIS302DL_FILTEREDDATASELECTION_OUTPUTREGISTER | \
000014  f89d0000          LDRB     r0,[sp,#0]
000018  f00000d0          AND      r0,r0,#0xd0
00001c  f88d0000          STRB     r0,[sp,#0]
;;;130                         LIS302DL_HIGHPASSFILTER_LEVEL_3 | \
;;;131                         LIS302DL_HIGHPASSFILTERINTERRUPT_1_2);
;;;132      /* Configure MEMS high pass filter cut-off level, interrupt and data selection bits */                     
;;;133      ctrl |= (uint8_t)(LIS302DL_FilterConfigStruct->HighPassFilter_Data_Selection | \
000020  7821              LDRB     r1,[r4,#0]
000022  7862              LDRB     r2,[r4,#1]
000024  4311              ORRS     r1,r1,r2
000026  78a2              LDRB     r2,[r4,#2]
000028  4302              ORRS     r2,r2,r0
00002a  4311              ORRS     r1,r1,r2
00002c  f88d1000          STRB     r1,[sp,#0]
;;;134                        LIS302DL_FilterConfigStruct->HighPassFilter_CutOff_Frequency | \
;;;135                        LIS302DL_FilterConfigStruct->HighPassFilter_Interrupt);
;;;136      
;;;137      /* Write value to MEMS CTRL_REG2 register */
;;;138      LIS302DL_Write(&ctrl, LIS302DL_CTRL_REG2_ADDR, 1);
000030  2201              MOVS     r2,#1
000032  2121              MOVS     r1,#0x21
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       LIS302DL_Write
;;;139    }
00003a  bd38              POP      {r3-r5,pc}
;;;140    
                          ENDP


                          AREA ||i.LIS302DL_FullScaleCmd||, CODE, READONLY, ALIGN=1

                  LIS302DL_FullScaleCmd PROC
;;;216      */
;;;217    void LIS302DL_FullScaleCmd(uint8_t FS_value)
000000  b538              PUSH     {r3-r5,lr}
;;;218    {
000002  4604              MOV      r4,r0
;;;219      uint8_t tmpreg;
;;;220      
;;;221      /* Read CTRL_REG1 register */
;;;222      LIS302DL_Read(&tmpreg, LIS302DL_CTRL_REG1_ADDR, 1);
000004  2201              MOVS     r2,#1
000006  2120              MOVS     r1,#0x20
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       LIS302DL_Read
;;;223      
;;;224      /* Set new full scale configuration */
;;;225      tmpreg &= (uint8_t)~LIS302DL_FULLSCALE_9_2;
00000e  f89d1000          LDRB     r1,[sp,#0]
;;;226      tmpreg |= FS_value;
;;;227      
;;;228      /* Write value to MEMS CTRL_REG1 regsister */
;;;229      LIS302DL_Write(&tmpreg, LIS302DL_CTRL_REG1_ADDR, 1);
000012  2201              MOVS     r2,#1
000014  f00101df          AND      r1,r1,#0xdf           ;225
000018  4321              ORRS     r1,r1,r4              ;226
00001a  f88d1000          STRB     r1,[sp,#0]            ;226
00001e  2120              MOVS     r1,#0x20
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       LIS302DL_Write
;;;230    }
000026  bd38              POP      {r3-r5,pc}
;;;231    
                          ENDP


                          AREA ||i.LIS302DL_Init||, CODE, READONLY, ALIGN=1

                  LIS302DL_Init PROC
;;;98       */
;;;99     void LIS302DL_Init(LIS302DL_InitTypeDef *LIS302DL_InitStruct)
000000  b538              PUSH     {r3-r5,lr}
;;;100    {
000002  4604              MOV      r4,r0
;;;101      uint8_t ctrl = 0x00;
000004  2000              MOVS     r0,#0
000006  f88d0000          STRB     r0,[sp,#0]
;;;102      
;;;103      /* Configure the low level interface ---------------------------------------*/
;;;104      LIS302DL_LowLevel_Init();
00000a  f7fffffe          BL       LIS302DL_LowLevel_Init
;;;105      
;;;106      /* Configure MEMS: data rate, power mode, full scale, self test and axes */
;;;107      ctrl = (uint8_t) (LIS302DL_InitStruct->Output_DataRate | LIS302DL_InitStruct->Power_Mode | \
00000e  7860              LDRB     r0,[r4,#1]
000010  7821              LDRB     r1,[r4,#0]
000012  7922              LDRB     r2,[r4,#4]
000014  4308              ORRS     r0,r0,r1
000016  78e1              LDRB     r1,[r4,#3]
000018  4311              ORRS     r1,r1,r2
00001a  4308              ORRS     r0,r0,r1
00001c  78a1              LDRB     r1,[r4,#2]
;;;108                        LIS302DL_InitStruct->Full_Scale | LIS302DL_InitStruct->Self_Test | \
;;;109                        LIS302DL_InitStruct->Axes_Enable);
;;;110      
;;;111      /* Write value to MEMS CTRL_REG1 regsister */
;;;112      LIS302DL_Write(&ctrl, LIS302DL_CTRL_REG1_ADDR, 1);
00001e  2201              MOVS     r2,#1
000020  4308              ORRS     r0,r0,r1              ;107
000022  f88d0000          STRB     r0,[sp,#0]            ;107
000026  2120              MOVS     r1,#0x20
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       LIS302DL_Write
;;;113    }
00002e  bd38              POP      {r3-r5,pc}
;;;114    
                          ENDP


                          AREA ||i.LIS302DL_InterruptConfig||, CODE, READONLY, ALIGN=1

                  LIS302DL_InterruptConfig PROC
;;;146      */
;;;147    void LIS302DL_InterruptConfig(LIS302DL_InterruptConfigTypeDef *LIS302DL_IntConfigStruct)
000000  b538              PUSH     {r3-r5,lr}
;;;148    {
000002  4604              MOV      r4,r0
;;;149      uint8_t ctrl = 0x00;
000004  2000              MOVS     r0,#0
000006  f88d0000          STRB     r0,[sp,#0]
;;;150      
;;;151      /* Read CLICK_CFG register */
;;;152      LIS302DL_Read(&ctrl, LIS302DL_CLICK_CFG_REG_ADDR, 1);
00000a  2201              MOVS     r2,#1
00000c  2138              MOVS     r1,#0x38
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       LIS302DL_Read
;;;153      
;;;154      /* Configure latch Interrupt request, click interrupts and double click interrupts */                   
;;;155      ctrl = (uint8_t)(LIS302DL_IntConfigStruct->Latch_Request| \
000014  7820              LDRB     r0,[r4,#0]
000016  7861              LDRB     r1,[r4,#1]
;;;156                       LIS302DL_IntConfigStruct->SingleClick_Axes | \
;;;157                       LIS302DL_IntConfigStruct->DoubleClick_Axes);
;;;158      
;;;159      /* Write value to MEMS CLICK_CFG register */
;;;160      LIS302DL_Write(&ctrl, LIS302DL_CLICK_CFG_REG_ADDR, 1);
000018  2201              MOVS     r2,#1
00001a  4308              ORRS     r0,r0,r1              ;155
00001c  78a1              LDRB     r1,[r4,#2]            ;155
00001e  4308              ORRS     r0,r0,r1              ;155
000020  f88d0000          STRB     r0,[sp,#0]            ;155
000024  2138              MOVS     r1,#0x38
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       LIS302DL_Write
;;;161    }
00002c  bd38              POP      {r3-r5,pc}
;;;162    
                          ENDP


                          AREA ||i.LIS302DL_LowLevel_Init||, CODE, READONLY, ALIGN=2

                  LIS302DL_LowLevel_Init PROC
;;;361      */
;;;362    static void LIS302DL_LowLevel_Init(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;363    {
;;;364      GPIO_InitTypeDef GPIO_InitStructure;
;;;365      SPI_InitTypeDef  SPI_InitStructure;
;;;366    
;;;367      /* Enable the SPI periph */
;;;368      RCC_APB2PeriphClockCmd(LIS302DL_SPI_CLK, ENABLE);
000002  2101              MOVS     r1,#1
000004  b087              SUB      sp,sp,#0x1c           ;363
000006  0308              LSLS     r0,r1,#12
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;369    
;;;370      /* Enable SCK, MOSI and MISO GPIO clocks */
;;;371      RCC_AHB1PeriphClockCmd(LIS302DL_SPI_SCK_GPIO_CLK | LIS302DL_SPI_MISO_GPIO_CLK | LIS302DL_SPI_MOSI_GPIO_CLK, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;372    
;;;373      /* Enable CS  GPIO clock */
;;;374      RCC_AHB1PeriphClockCmd(LIS302DL_SPI_CS_GPIO_CLK, ENABLE);
000014  2101              MOVS     r1,#1
000016  2010              MOVS     r0,#0x10
000018  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;375      
;;;376      /* Enable INT1 GPIO clock */
;;;377      RCC_AHB1PeriphClockCmd(LIS302DL_SPI_INT1_GPIO_CLK, ENABLE);
00001c  2101              MOVS     r1,#1
00001e  2010              MOVS     r0,#0x10
000020  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;378      
;;;379      /* Enable INT2 GPIO clock */
;;;380      RCC_AHB1PeriphClockCmd(LIS302DL_SPI_INT2_GPIO_CLK, ENABLE);
000024  2101              MOVS     r1,#1
000026  2010              MOVS     r0,#0x10
000028  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;381    
;;;382      GPIO_PinAFConfig(LIS302DL_SPI_SCK_GPIO_PORT, LIS302DL_SPI_SCK_SOURCE, LIS302DL_SPI_SCK_AF);
00002c  4e39              LDR      r6,|L6.276|
00002e  2205              MOVS     r2,#5
000030  4611              MOV      r1,r2
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       GPIO_PinAFConfig
;;;383      GPIO_PinAFConfig(LIS302DL_SPI_MISO_GPIO_PORT, LIS302DL_SPI_MISO_SOURCE, LIS302DL_SPI_MISO_AF);
000038  2205              MOVS     r2,#5
00003a  2106              MOVS     r1,#6
00003c  4630              MOV      r0,r6
00003e  f7fffffe          BL       GPIO_PinAFConfig
;;;384      GPIO_PinAFConfig(LIS302DL_SPI_MOSI_GPIO_PORT, LIS302DL_SPI_MOSI_SOURCE, LIS302DL_SPI_MOSI_AF);
000042  2205              MOVS     r2,#5
000044  2107              MOVS     r1,#7
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       GPIO_PinAFConfig
;;;385    
;;;386      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
00004c  2502              MOVS     r5,#2
00004e  f88d5004          STRB     r5,[sp,#4]
;;;387      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000052  2400              MOVS     r4,#0
000054  f88d4006          STRB     r4,[sp,#6]
;;;388      GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_DOWN;
;;;389      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;390    
;;;391      /* SPI SCK pin configuration */
;;;392      GPIO_InitStructure.GPIO_Pin = LIS302DL_SPI_SCK_PIN;
000058  2020              MOVS     r0,#0x20
00005a  f88d5007          STRB     r5,[sp,#7]            ;388
;;;393      GPIO_Init(LIS302DL_SPI_SCK_GPIO_PORT, &GPIO_InitStructure);
00005e  9000              STR      r0,[sp,#0]
000060  f88d5005          STRB     r5,[sp,#5]            ;389
000064  4669              MOV      r1,sp
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       GPIO_Init
;;;394    
;;;395      /* SPI  MOSI pin configuration */
;;;396      GPIO_InitStructure.GPIO_Pin =  LIS302DL_SPI_MOSI_PIN;
00006c  2080              MOVS     r0,#0x80
;;;397      GPIO_Init(LIS302DL_SPI_MOSI_GPIO_PORT, &GPIO_InitStructure);
00006e  9000              STR      r0,[sp,#0]
000070  4669              MOV      r1,sp
000072  4630              MOV      r0,r6
000074  f7fffffe          BL       GPIO_Init
;;;398    
;;;399      /* SPI MISO pin configuration */
;;;400      GPIO_InitStructure.GPIO_Pin = LIS302DL_SPI_MISO_PIN;
000078  2040              MOVS     r0,#0x40
;;;401      GPIO_Init(LIS302DL_SPI_MISO_GPIO_PORT, &GPIO_InitStructure);
00007a  9000              STR      r0,[sp,#0]
00007c  4669              MOV      r1,sp
00007e  4630              MOV      r0,r6
000080  f7fffffe          BL       GPIO_Init
;;;402    
;;;403      /* SPI configuration -------------------------------------------------------*/
;;;404      SPI_I2S_DeInit(LIS302DL_SPI);
000084  4f24              LDR      r7,|L6.280|
000086  4638              MOV      r0,r7
000088  f7fffffe          BL       SPI_I2S_DeInit
;;;405      SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
;;;406      SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
;;;407      SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;
;;;408      SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
00008c  f8ad4010          STRH     r4,[sp,#0x10]
;;;409      SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
000090  0228              LSLS     r0,r5,#8
000092  f8ad0012          STRH     r0,[sp,#0x12]
;;;410      SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;
;;;411      SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
;;;412      SPI_InitStructure.SPI_CRCPolynomial = 7;
000096  2007              MOVS     r0,#7
000098  f8ad0018          STRH     r0,[sp,#0x18]
00009c  f8ad4008          STRH     r4,[sp,#8]            ;405
0000a0  2608              MOVS     r6,#8                 ;410
;;;413      SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
0000a2  f44f7082          MOV      r0,#0x104
0000a6  f8ad400c          STRH     r4,[sp,#0xc]          ;406
0000aa  f8ad6014          STRH     r6,[sp,#0x14]         ;410
0000ae  f8ad000a          STRH     r0,[sp,#0xa]
0000b2  f8ad400e          STRH     r4,[sp,#0xe]          ;407
0000b6  f8ad4016          STRH     r4,[sp,#0x16]         ;411
;;;414      SPI_Init(LIS302DL_SPI, &SPI_InitStructure);
0000ba  a902              ADD      r1,sp,#8
0000bc  4638              MOV      r0,r7
0000be  f7fffffe          BL       SPI_Init
;;;415    
;;;416      /* Enable SPI1  */
;;;417      SPI_Cmd(LIS302DL_SPI, ENABLE);
0000c2  2101              MOVS     r1,#1
0000c4  4638              MOV      r0,r7
0000c6  f7fffffe          BL       SPI_Cmd
;;;418    
;;;419      /* Configure GPIO PIN for Lis Chip select */
;;;420      GPIO_InitStructure.GPIO_Pin = LIS302DL_SPI_CS_PIN;
;;;421      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
0000ca  9600              STR      r6,[sp,#0]
0000cc  2601              MOVS     r6,#1
0000ce  f88d6004          STRB     r6,[sp,#4]
;;;422      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;423      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;424      GPIO_Init(LIS302DL_SPI_CS_GPIO_PORT, &GPIO_InitStructure);
0000d2  4f12              LDR      r7,|L6.284|
0000d4  f88d4006          STRB     r4,[sp,#6]            ;422
0000d8  f88d5005          STRB     r5,[sp,#5]            ;423
0000dc  4669              MOV      r1,sp
0000de  4638              MOV      r0,r7
0000e0  f7fffffe          BL       GPIO_Init
;;;425    
;;;426      /* Deselect : Chip Select high */
;;;427      GPIO_SetBits(LIS302DL_SPI_CS_GPIO_PORT, LIS302DL_SPI_CS_PIN);
0000e4  2108              MOVS     r1,#8
0000e6  4638              MOV      r0,r7
0000e8  f7fffffe          BL       GPIO_SetBits
;;;428      
;;;429      /* Configure GPIO PINs to detect Interrupts */
;;;430      GPIO_InitStructure.GPIO_Pin = LIS302DL_SPI_INT1_PIN;
;;;431      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
0000ec  f88d4004          STRB     r4,[sp,#4]
;;;432      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
0000f0  f88d4006          STRB     r4,[sp,#6]
;;;433      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000f4  f88d5005          STRB     r5,[sp,#5]
0000f8  9600              STR      r6,[sp,#0]            ;431
;;;434      GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
0000fa  f88d4007          STRB     r4,[sp,#7]
;;;435      GPIO_Init(LIS302DL_SPI_INT1_GPIO_PORT, &GPIO_InitStructure);
0000fe  4669              MOV      r1,sp
000100  4638              MOV      r0,r7
000102  f7fffffe          BL       GPIO_Init
;;;436      
;;;437      GPIO_InitStructure.GPIO_Pin = LIS302DL_SPI_INT2_PIN;
;;;438      GPIO_Init(LIS302DL_SPI_INT2_GPIO_PORT, &GPIO_InitStructure);
000106  4669              MOV      r1,sp
000108  4638              MOV      r0,r7
00010a  9500              STR      r5,[sp,#0]
00010c  f7fffffe          BL       GPIO_Init
;;;439    }
000110  b007              ADD      sp,sp,#0x1c
000112  bdf0              POP      {r4-r7,pc}
;;;440    
                          ENDP

                  |L6.276|
                          DCD      0x40020000
                  |L6.280|
                          DCD      0x40013000
                  |L6.284|
                          DCD      0x40021000

                          AREA ||i.LIS302DL_LowpowerCmd||, CODE, READONLY, ALIGN=1

                  LIS302DL_LowpowerCmd PROC
;;;170      */
;;;171    void LIS302DL_LowpowerCmd(uint8_t LowPowerMode)
000000  b538              PUSH     {r3-r5,lr}
;;;172    {
000002  4604              MOV      r4,r0
;;;173      uint8_t tmpreg;
;;;174      
;;;175      /* Read CTRL_REG1 register */
;;;176      LIS302DL_Read(&tmpreg, LIS302DL_CTRL_REG1_ADDR, 1);
000004  2201              MOVS     r2,#1
000006  2120              MOVS     r1,#0x20
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       LIS302DL_Read
;;;177      
;;;178      /* Set new low power mode configuration */
;;;179      tmpreg &= (uint8_t)~LIS302DL_LOWPOWERMODE_ACTIVE;
00000e  f89d1000          LDRB     r1,[sp,#0]
;;;180      tmpreg |= LowPowerMode;
;;;181      
;;;182      /* Write value to MEMS CTRL_REG1 regsister */
;;;183      LIS302DL_Write(&tmpreg, LIS302DL_CTRL_REG1_ADDR, 1);
000012  2201              MOVS     r2,#1
000014  f00101bf          AND      r1,r1,#0xbf           ;179
000018  4321              ORRS     r1,r1,r4              ;180
00001a  f88d1000          STRB     r1,[sp,#0]            ;180
00001e  2120              MOVS     r1,#0x20
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       LIS302DL_Write
;;;184    }
000026  bd38              POP      {r3-r5,pc}
;;;185    
                          ENDP


                          AREA ||i.LIS302DL_Read||, CODE, READONLY, ALIGN=2

                  LIS302DL_Read PROC
;;;290      */
;;;291    void LIS302DL_Read(uint8_t* pBuffer, uint8_t ReadAddr, uint16_t NumByteToRead)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;292    {  
000004  4614              MOV      r4,r2
000006  4605              MOV      r5,r0
;;;293      if(NumByteToRead > 0x01)
000008  2a01              CMP      r2,#1
00000a  d902              BLS      |L8.18|
;;;294      {
;;;295        ReadAddr |= (uint8_t)(READWRITE_CMD | MULTIPLEBYTE_CMD);
00000c  f04107c0          ORR      r7,r1,#0xc0
000010  e001              B        |L8.22|
                  |L8.18|
;;;296      }
;;;297      else
;;;298      {
;;;299        ReadAddr |= (uint8_t)READWRITE_CMD;
000012  f0410780          ORR      r7,r1,#0x80
                  |L8.22|
;;;300      }
;;;301      /* Set chip select Low at the start of the transmission */
;;;302      LIS302DL_CS_LOW();
000016  4e0c              LDR      r6,|L8.72|
000018  2108              MOVS     r1,#8
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       GPIO_ResetBits
;;;303      
;;;304      /* Send the Address of the indexed register */
;;;305      LIS302DL_SendByte(ReadAddr);
000020  4638              MOV      r0,r7
000022  f7fffffe          BL       LIS302DL_SendByte
;;;306      
;;;307      /* Receive the data that will be read from the device (MSB First) */
;;;308      while(NumByteToRead > 0x00)
000026  e006              B        |L8.54|
                  |L8.40|
;;;309      {
;;;310        /* Send dummy byte (0x00) to generate the SPI clock to LIS302DL (Slave device) */
;;;311        *pBuffer = LIS302DL_SendByte(DUMMY_BYTE);
000028  2000              MOVS     r0,#0
00002a  f7fffffe          BL       LIS302DL_SendByte
;;;312        NumByteToRead--;
00002e  1e64              SUBS     r4,r4,#1
000030  f8050b01          STRB     r0,[r5],#1            ;311
000034  b2a4              UXTH     r4,r4
                  |L8.54|
000036  2c00              CMP      r4,#0                 ;308
000038  d1f6              BNE      |L8.40|
;;;313        pBuffer++;
;;;314      }
;;;315      
;;;316      /* Set chip select High at the end of the transmission */ 
;;;317      LIS302DL_CS_HIGH();
00003a  4630              MOV      r0,r6
00003c  e8bd41f0          POP      {r4-r8,lr}
000040  2108              MOVS     r1,#8
000042  f7ffbffe          B.W      GPIO_SetBits
;;;318    }
;;;319    
                          ENDP

000046  0000              DCW      0x0000
                  |L8.72|
                          DCD      0x40021000

                          AREA ||i.LIS302DL_ReadACC||, CODE, READONLY, ALIGN=1

                  LIS302DL_ReadACC PROC
;;;325      */
;;;326    void LIS302DL_ReadACC(int32_t* out)
000000  b53e              PUSH     {r1-r5,lr}
;;;327    {
000002  4605              MOV      r5,r0
;;;328      uint8_t buffer[6];
;;;329      uint8_t crtl, i = 0x00;
000004  2400              MOVS     r4,#0
;;;330       
;;;331      LIS302DL_Read(&crtl, LIS302DL_CTRL_REG1_ADDR, 1);  
000006  2201              MOVS     r2,#1
000008  2120              MOVS     r1,#0x20
00000a  a802              ADD      r0,sp,#8
00000c  f7fffffe          BL       LIS302DL_Read
;;;332      LIS302DL_Read(buffer, LIS302DL_OUT_X_ADDR, 6);
000010  2206              MOVS     r2,#6
000012  2129              MOVS     r1,#0x29
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       LIS302DL_Read
;;;333      
;;;334      switch(crtl & 0x20) 
00001a  f89d0008          LDRB     r0,[sp,#8]
00001e  4669              MOV      r1,sp                 ;328
000020  f0100020          ANDS     r0,r0,#0x20
000024  d00e              BEQ      |L9.68|
000026  2820              CMP      r0,#0x20
000028  d10b              BNE      |L9.66|
                  |L9.42|
;;;335        {
;;;336        /* FS bit = 0 ==> Sensitivity typical value = 18milligals/digit*/ 
;;;337        case 0x00:
;;;338          for(i=0; i<0x03; i++)
;;;339          {
;;;340            *out =(int32_t)(LIS302DL_SENSITIVITY_2_3G *  (int8_t)buffer[2*i]);
;;;341            out++;
;;;342          }
;;;343          break;
;;;344        /* FS bit = 1 ==> Sensitivity typical value = 72milligals/digit*/ 
;;;345        case 0x20:
;;;346          for(i=0; i<0x03; i++)
;;;347          {
;;;348            *out =(int32_t)(LIS302DL_SENSITIVITY_9_2G * (int8_t)buffer[2*i]);
00002a  eb010044          ADD      r0,r1,r4,LSL #1
00002e  1c64              ADDS     r4,r4,#1              ;346
000030  f9900000          LDRSB    r0,[r0,#0]
000034  b2e4              UXTB     r4,r4                 ;346
000036  eb0000c0          ADD      r0,r0,r0,LSL #3
00003a  00c0              LSLS     r0,r0,#3
00003c  c501              STM      r5!,{r0}
00003e  2c03              CMP      r4,#3                 ;346
000040  d3f3              BCC      |L9.42|
                  |L9.66|
;;;349            out++;
;;;350          }         
;;;351          break;
;;;352        default:
;;;353          break;
;;;354        }
;;;355     }
000042  bd3e              POP      {r1-r5,pc}
                  |L9.68|
000044  eb010044          ADD      r0,r1,r4,LSL #1       ;340
000048  1c64              ADDS     r4,r4,#1              ;338
00004a  f9900000          LDRSB    r0,[r0,#0]            ;340
00004e  b2e4              UXTB     r4,r4                 ;338
000050  eb0000c0          ADD      r0,r0,r0,LSL #3       ;340
000054  0040              LSLS     r0,r0,#1              ;340
000056  c501              STM      r5!,{r0}              ;340
000058  2c03              CMP      r4,#3                 ;338
00005a  d3f3              BCC      |L9.68|
00005c  bd3e              POP      {r1-r5,pc}
;;;356    
                          ENDP


                          AREA ||i.LIS302DL_RebootCmd||, CODE, READONLY, ALIGN=1

                  LIS302DL_RebootCmd PROC
;;;236      */
;;;237    void LIS302DL_RebootCmd(void)
000000  b508              PUSH     {r3,lr}
;;;238    {
;;;239      uint8_t tmpreg;
;;;240      /* Read CTRL_REG2 register */
;;;241      LIS302DL_Read(&tmpreg, LIS302DL_CTRL_REG2_ADDR, 1);
000002  2201              MOVS     r2,#1
000004  2121              MOVS     r1,#0x21
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       LIS302DL_Read
;;;242      
;;;243      /* Enable or Disable the reboot memory */
;;;244      tmpreg |= LIS302DL_BOOT_REBOOTMEMORY;
00000c  f89d0000          LDRB     r0,[sp,#0]
;;;245      
;;;246      /* Write value to MEMS CTRL_REG2 regsister */
;;;247      LIS302DL_Write(&tmpreg, LIS302DL_CTRL_REG2_ADDR, 1);
000010  2201              MOVS     r2,#1
000012  f0400040          ORR      r0,r0,#0x40           ;244
000016  f88d0000          STRB     r0,[sp,#0]            ;244
00001a  2121              MOVS     r1,#0x21
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       LIS302DL_Write
;;;248    }
000022  bd08              POP      {r3,pc}
;;;249    
                          ENDP


                          AREA ||i.LIS302DL_SendByte||, CODE, READONLY, ALIGN=2

                  LIS302DL_SendByte PROC
;;;446      */
;;;447    static uint8_t LIS302DL_SendByte(uint8_t byte)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;448    {
;;;449      /* Loop while DR register in not emplty */
;;;450      LIS302DLTimeout = LIS302DL_FLAG_TIMEOUT;
000004  4c14              LDR      r4,|L11.88|
000006  f44f5580          MOV      r5,#0x1000
00000a  4607              MOV      r7,r0                 ;448
00000c  6025              STR      r5,[r4,#0]  ; LIS302DLTimeout
;;;451      while (SPI_I2S_GetFlagStatus(LIS302DL_SPI, SPI_I2S_FLAG_TXE) == RESET)
00000e  4e13              LDR      r6,|L11.92|
000010  e004              B        |L11.28|
                  |L11.18|
;;;452      {
;;;453        if((LIS302DLTimeout--) == 0) return 0; // LIS302DL_TIMEOUT_UserCallback();
000012  6820              LDR      r0,[r4,#0]  ; LIS302DLTimeout
000014  1e41              SUBS     r1,r0,#1
000016  6021              STR      r1,[r4,#0]  ; LIS302DLTimeout
000018  2800              CMP      r0,#0
00001a  d019              BEQ      |L11.80|
                  |L11.28|
00001c  2102              MOVS     r1,#2                 ;451
00001e  4630              MOV      r0,r6                 ;451
000020  f7fffffe          BL       SPI_I2S_GetFlagStatus
000024  2800              CMP      r0,#0                 ;451
000026  d0f4              BEQ      |L11.18|
;;;454      }
;;;455      
;;;456      /* Send a Byte through the SPI peripheral */
;;;457      SPI_I2S_SendData(LIS302DL_SPI, byte);
000028  4639              MOV      r1,r7
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       SPI_I2S_SendData
;;;458      
;;;459      /* Wait to receive a Byte */
;;;460      LIS302DLTimeout = LIS302DL_FLAG_TIMEOUT;
000030  6025              STR      r5,[r4,#0]  ; LIS302DLTimeout
;;;461      while (SPI_I2S_GetFlagStatus(LIS302DL_SPI, SPI_I2S_FLAG_RXNE) == RESET)
000032  e003              B        |L11.60|
                  |L11.52|
;;;462      {
;;;463        if((LIS302DLTimeout--) == 0) return 0; // LIS302DL_TIMEOUT_UserCallback();
000034  6821              LDR      r1,[r4,#0]  ; LIS302DLTimeout
000036  1e48              SUBS     r0,r1,#1
000038  6020              STR      r0,[r4,#0]  ; LIS302DLTimeout
00003a  b159              CBZ      r1,|L11.84|
                  |L11.60|
00003c  2101              MOVS     r1,#1                 ;461
00003e  4630              MOV      r0,r6                 ;461
000040  f7fffffe          BL       SPI_I2S_GetFlagStatus
000044  2800              CMP      r0,#0                 ;461
000046  d0f5              BEQ      |L11.52|
;;;464      }
;;;465      
;;;466      /* Return the Byte read from the SPI bus */
;;;467      return (uint8_t)SPI_I2S_ReceiveData(LIS302DL_SPI);
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       SPI_I2S_ReceiveData
00004e  b2c0              UXTB     r0,r0
                  |L11.80|
;;;468    }
000050  e8bd81f0          POP      {r4-r8,pc}
                  |L11.84|
000054  2000              MOVS     r0,#0                 ;463
000056  e7fb              B        |L11.80|
;;;469    
                          ENDP

                  |L11.88|
                          DCD      ||.data||
                  |L11.92|
                          DCD      0x40013000

                          AREA ||i.LIS302DL_Write||, CODE, READONLY, ALIGN=2

                  LIS302DL_Write PROC
;;;256      */
;;;257    void LIS302DL_Write(uint8_t* pBuffer, uint8_t WriteAddr, uint16_t NumByteToWrite)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;258    {
000004  4614              MOV      r4,r2
000006  4605              MOV      r5,r0
000008  460f              MOV      r7,r1
;;;259      /* Configure the MS bit: 
;;;260           - When 0, the address will remain unchanged in multiple read/write commands.
;;;261           - When 1, the address will be auto incremented in multiple read/write commands.
;;;262      */
;;;263      if(NumByteToWrite > 0x01)
00000a  2a01              CMP      r2,#1
00000c  d901              BLS      |L12.18|
;;;264      {
;;;265        WriteAddr |= (uint8_t)MULTIPLEBYTE_CMD;
00000e  f0410740          ORR      r7,r1,#0x40
                  |L12.18|
;;;266      }
;;;267      /* Set chip select Low at the start of the transmission */
;;;268      LIS302DL_CS_LOW();
000012  4e0b              LDR      r6,|L12.64|
000014  2108              MOVS     r1,#8
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       GPIO_ResetBits
;;;269      
;;;270      /* Send the Address of the indexed register */
;;;271      LIS302DL_SendByte(WriteAddr);
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       LIS302DL_SendByte
;;;272      /* Send the data that will be written into the device (MSB First) */
;;;273      while(NumByteToWrite >= 0x01)
000022  e005              B        |L12.48|
                  |L12.36|
;;;274      {
;;;275        LIS302DL_SendByte(*pBuffer);
000024  7828              LDRB     r0,[r5,#0]
000026  f7fffffe          BL       LIS302DL_SendByte
;;;276        NumByteToWrite--;
00002a  1e64              SUBS     r4,r4,#1
00002c  b2a4              UXTH     r4,r4
;;;277        pBuffer++;
00002e  1c6d              ADDS     r5,r5,#1
                  |L12.48|
000030  2c00              CMP      r4,#0                 ;273
000032  d1f7              BNE      |L12.36|
;;;278      }
;;;279      
;;;280      /* Set chip select High at the end of the transmission */ 
;;;281      LIS302DL_CS_HIGH();
000034  4630              MOV      r0,r6
000036  e8bd41f0          POP      {r4-r8,lr}
00003a  2108              MOVS     r1,#8
00003c  f7ffbffe          B.W      GPIO_SetBits
;;;282    }
;;;283    
                          ENDP

                  |L12.64|
                          DCD      0x40021000

                          AREA ||.data||, DATA, ALIGN=2

                  LIS302DLTimeout
                          DCD      0x00001000

;*** Start embedded assembler ***

#line 1 "Utilities\\STM32F4-Discovery\\stm32f4_discovery_lis302dl.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___28_stm32f4_discovery_lis302dl_c_0a756944____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___28_stm32f4_discovery_lis302dl_c_0a756944____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___28_stm32f4_discovery_lis302dl_c_0a756944____REVSH|
#line 128
|__asm___28_stm32f4_discovery_lis302dl_c_0a756944____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
