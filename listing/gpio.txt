; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\MEDIA_USB_KEY\gpio.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\MEDIA_USB_KEY\gpio.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\MEDIA_USB_KEY\gpio.crf src\gpio.c]
                          THUMB

                          AREA ||i.gpio_DigitalInput||, CODE, READONLY, ALIGN=2

                  gpio_DigitalInput PROC
;;;40     // Настроить вывод на вход
;;;41     void gpio_DigitalInput(uint8_t Port, uint8_t Pin)
000000  4a04              LDR      r2,|L1.20|
;;;42     {
;;;43         // Очистим поле
;;;44         // GP Input = 0
;;;45         Ports[Port]->MODER &= ~(0x03UL << (Pin * 2));
000002  f8520020          LDR      r0,[r2,r0,LSL #2]
000006  6802              LDR      r2,[r0,#0]
000008  004b              LSLS     r3,r1,#1
00000a  2103              MOVS     r1,#3
00000c  4099              LSLS     r1,r1,r3
00000e  438a              BICS     r2,r2,r1
000010  6002              STR      r2,[r0,#0]
;;;46     }
000012  4770              BX       lr
;;;47     
                          ENDP

                  |L1.20|
                          DCD      ||.data||

                          AREA ||i.gpio_DigitalOutput||, CODE, READONLY, ALIGN=2

                  gpio_DigitalOutput PROC
;;;29     // Настроить вывод на выход
;;;30     void gpio_DigitalOutput(uint8_t Port, uint8_t Pin)
000000  b530              PUSH     {r4,r5,lr}
;;;31     {
;;;32         // Очистим поле
;;;33         Ports[Port]->MODER &= ~(0x03UL << (Pin * 2));
000002  4c08              LDR      r4,|L2.36|
000004  f8542020          LDR      r2,[r4,r0,LSL #2]
000008  6813              LDR      r3,[r2,#0]
00000a  0049              LSLS     r1,r1,#1
00000c  2503              MOVS     r5,#3
00000e  408d              LSLS     r5,r5,r1
000010  43ab              BICS     r3,r3,r5
000012  6013              STR      r3,[r2,#0]
;;;34         
;;;35         // Режим выхода
;;;36         // GP Output = 1
;;;37         Ports[Port]->MODER |=  (0x01UL << (Pin * 2));
000014  f8540020          LDR      r0,[r4,r0,LSL #2]
000018  6802              LDR      r2,[r0,#0]
00001a  2301              MOVS     r3,#1
00001c  408b              LSLS     r3,r3,r1
00001e  431a              ORRS     r2,r2,r3
000020  6002              STR      r2,[r0,#0]
;;;38     }
000022  bd30              POP      {r4,r5,pc}
;;;39     
                          ENDP

                  |L2.36|
                          DCD      ||.data||

                          AREA ||i.gpio_HighLevel||, CODE, READONLY, ALIGN=2

                  gpio_HighLevel PROC
;;;48     // Высокий уровень на ножке
;;;49     void gpio_HighLevel(uint8_t Port, uint8_t Pin)
000000  f001020f          AND      r2,r1,#0xf
;;;50     {
;;;51         Ports[Port]->BSRRL = (1UL << (Pin & 0x0F));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a02              LDR      r2,|L3.20|
00000a  f8520020          LDR      r0,[r2,r0,LSL #2]
00000e  8301              STRH     r1,[r0,#0x18]
;;;52     }
000010  4770              BX       lr
;;;53     
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      ||.data||

                          AREA ||i.gpio_Init||, CODE, READONLY, ALIGN=2

                  gpio_Init PROC
;;;12     // Инициализация
;;;13     void gpio_Init(void)
000000  4803              LDR      r0,|L4.16|
;;;14     {
;;;15         // Тактирование во все порты!
;;;16         RCC->AHB1ENR |= 0 |
000002  6801              LDR      r1,[r0,#0]
000004  f24012ff          MOV      r2,#0x1ff
000008  4311              ORRS     r1,r1,r2
00000a  6001              STR      r1,[r0,#0]
;;;17                         RCC_AHB1ENR_GPIOAEN |
;;;18                         RCC_AHB1ENR_GPIOBEN |
;;;19                         RCC_AHB1ENR_GPIOCEN |
;;;20                         RCC_AHB1ENR_GPIODEN |
;;;21                         RCC_AHB1ENR_GPIOEEN |
;;;22                         RCC_AHB1ENR_GPIOFEN |
;;;23                         RCC_AHB1ENR_GPIOGEN |
;;;24                         RCC_AHB1ENR_GPIOHEN |
;;;25                         RCC_AHB1ENR_GPIOIEN |
;;;26                         0;
;;;27     }
00000c  4770              BX       lr
;;;28     
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      0x40023830

                          AREA ||i.gpio_LowLevel||, CODE, READONLY, ALIGN=2

                  gpio_LowLevel PROC
;;;54     // Низкий уровень на ножке
;;;55     void gpio_LowLevel(uint8_t Port, uint8_t Pin)
000000  f001020f          AND      r2,r1,#0xf
;;;56     {
;;;57         Ports[Port]->BSRRH = (1UL << (Pin & 0x0F));
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
000008  4a02              LDR      r2,|L5.20|
00000a  f8520020          LDR      r0,[r2,r0,LSL #2]
00000e  8341              STRH     r1,[r0,#0x1a]
;;;58     }
000010  4770              BX       lr
;;;59     
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      ||.data||

                          AREA ||i.gpio_OpenDrain||, CODE, READONLY, ALIGN=2

                  gpio_OpenDrain PROC
;;;67     // Включить Open Drain (иначе двухтактный)
;;;68     void gpio_OpenDrain(TPort Port, uint8_t Pin, bool Enable)
000000  b510              PUSH     {r4,lr}
;;;69     {
;;;70         if(Enable)
;;;71         {
;;;72             Ports[Port]->OTYPER |= (1 << Pin);
000002  4c06              LDR      r4,|L6.28|
000004  2301              MOVS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  f8540020          LDR      r0,[r4,r0,LSL #2]
;;;73         }
;;;74         else
;;;75         {
;;;76             Ports[Port]->OTYPER &= ~(1 << Pin);
00000c  6841              LDR      r1,[r0,#4]
00000e  b10a              CBZ      r2,|L6.20|
000010  4319              ORRS     r1,r1,r3              ;72
000012  e000              B        |L6.22|
                  |L6.20|
000014  4399              BICS     r1,r1,r3
                  |L6.22|
000016  6041              STR      r1,[r0,#4]            ;72
;;;77         }
;;;78     }
000018  bd10              POP      {r4,pc}
;;;79     
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      ||.data||

                          AREA ||i.gpio_SetAlternateFunction||, CODE, READONLY, ALIGN=2

                  gpio_SetAlternateFunction PROC
;;;80     // Установить для вывода альтернативную функцию (0-3)
;;;81     void gpio_SetAlternateFunction(uint8_t Port, uint8_t Pin, uint8_t Function)
000000  b5f0              PUSH     {r4-r7,lr}
;;;82     {
;;;83         Function &= 0x0F;
;;;84         
;;;85         // AF = 2
;;;86         Ports[Port]->MODER &= ~(0x03UL << (Pin * 2));
000002  4d19              LDR      r5,|L7.104|
000004  f002030f          AND      r3,r2,#0xf            ;83
000008  f8554020          LDR      r4,[r5,r0,LSL #2]
00000c  6826              LDR      r6,[r4,#0]
00000e  004a              LSLS     r2,r1,#1
000010  2703              MOVS     r7,#3
000012  4097              LSLS     r7,r7,r2
000014  43be              BICS     r6,r6,r7
000016  6026              STR      r6,[r4,#0]
;;;87         Ports[Port]->MODER |=  (0x02UL << (Pin * 2));
000018  f8554020          LDR      r4,[r5,r0,LSL #2]
00001c  6826              LDR      r6,[r4,#0]
00001e  2702              MOVS     r7,#2
000020  4097              LSLS     r7,r7,r2
000022  433e              ORRS     r6,r6,r7
000024  6026              STR      r6,[r4,#0]
;;;88         
;;;89         if(Pin < 8)
;;;90         {
;;;91             Pin &= 0x07;
;;;92             
;;;93             // Очистим, потом запишем
;;;94             Ports[Port]->AFR[0] &= ~(0x0F << (Pin * 4));
000026  260f              MOVS     r6,#0xf
000028  f0010207          AND      r2,r1,#7              ;91
00002c  2908              CMP      r1,#8                 ;89
00002e  d20d              BCS      |L7.76|
000030  f8551020          LDR      r1,[r5,r0,LSL #2]
000034  6a0c              LDR      r4,[r1,#0x20]
000036  0092              LSLS     r2,r2,#2
000038  4096              LSLS     r6,r6,r2
00003a  43b4              BICS     r4,r4,r6
00003c  620c              STR      r4,[r1,#0x20]
;;;95             Ports[Port]->AFR[0] |= ((uint32_t)Function << (Pin * 4));
00003e  f8550020          LDR      r0,[r5,r0,LSL #2]
000042  6a01              LDR      r1,[r0,#0x20]
000044  4093              LSLS     r3,r3,r2
000046  4319              ORRS     r1,r1,r3
000048  6201              STR      r1,[r0,#0x20]
;;;96         }
;;;97         else
;;;98         {
;;;99             Pin &= 0x07;
;;;100            
;;;101            // Очистим, потом запишем
;;;102            Ports[Port]->AFR[1] &= ~(0x0F << (Pin * 4));
;;;103            Ports[Port]->AFR[1] |= ((uint32_t)Function << (Pin * 4));
;;;104        }
;;;105    }
00004a  bdf0              POP      {r4-r7,pc}
                  |L7.76|
00004c  f8554020          LDR      r4,[r5,r0,LSL #2]     ;102
000050  6a67              LDR      r7,[r4,#0x24]         ;102
000052  0091              LSLS     r1,r2,#2              ;102
000054  408e              LSLS     r6,r6,r1              ;102
000056  43b7              BICS     r7,r7,r6              ;102
000058  6267              STR      r7,[r4,#0x24]         ;102
00005a  f8550020          LDR      r0,[r5,r0,LSL #2]     ;103
00005e  6a42              LDR      r2,[r0,#0x24]         ;103
000060  408b              LSLS     r3,r3,r1              ;103
000062  431a              ORRS     r2,r2,r3              ;103
000064  6242              STR      r2,[r0,#0x24]         ;103
000066  bdf0              POP      {r4-r7,pc}
                          ENDP

                  |L7.104|
                          DCD      ||.data||

                          AREA ||i.gpio_Value||, CODE, READONLY, ALIGN=2

                  gpio_Value PROC
;;;60     // Значение на ножке
;;;61     bool gpio_Value(uint8_t Port, uint8_t Pin)
000000  4a04              LDR      r2,|L8.20|
;;;62     {
;;;63         return ((Ports[Port]->IDR & (1 << Pin)) != 0);
000002  f8520020          LDR      r0,[r2,r0,LSL #2]
000006  6900              LDR      r0,[r0,#0x10]
000008  2201              MOVS     r2,#1
00000a  408a              LSLS     r2,r2,r1
00000c  4010              ANDS     r0,r0,r2
00000e  d000              BEQ      |L8.18|
000010  2001              MOVS     r0,#1
                  |L8.18|
;;;64     }
000012  4770              BX       lr
;;;65     
                          ENDP

                  |L8.20|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  Ports
                          DCD      0x40020000
                          DCD      0x40020400
                          DCD      0x40020800
                          DCD      0x40020c00
                          DCD      0x40021000
                          DCD      0x40021400
                          DCD      0x40021800
                          DCD      0x40021c00
                          DCD      0x40022000

;*** Start embedded assembler ***

#line 1 "src\\gpio.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_gpio_c_Ports____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___6_gpio_c_Ports____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___6_gpio_c_Ports____REVSH|
#line 128
|__asm___6_gpio_c_Ports____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
