; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\media_usb_key\stm32f4xx_rtc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\media_usb_key\stm32f4xx_rtc.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\media_usb_key\stm32f4xx_rtc.crf Libraries\CMSIS\stm32f4xx_rtc.c]
                          THUMB

                          AREA ||i.RTC_AlarmCmd||, CODE, READONLY, ALIGN=2

                  RTC_AlarmCmd PROC
;;;1282     */
;;;1283   ErrorStatus RTC_AlarmCmd(uint32_t RTC_Alarm, FunctionalState NewState)
000000  b538              PUSH     {r3-r5,lr}
;;;1284   {
;;;1285     __IO uint32_t alarmcounter = 0x00;
000002  2200              MOVS     r2,#0
;;;1286     uint32_t alarmstatus = 0x00;
;;;1287     ErrorStatus status = ERROR;
;;;1288       
;;;1289     /* Check the parameters */
;;;1290     assert_param(IS_RTC_CMD_ALARM(RTC_Alarm));
;;;1291     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1292   
;;;1293     /* Disable the write protection for RTC registers */
;;;1294     RTC->WPR = 0xCA;
000004  4c12              LDR      r4,|L1.80|
000006  9200              STR      r2,[sp,#0]
000008  22ca              MOVS     r2,#0xca
00000a  6022              STR      r2,[r4,#0]
;;;1295     RTC->WPR = 0x53;
00000c  2253              MOVS     r2,#0x53
00000e  6022              STR      r2,[r4,#0]
;;;1296   
;;;1297     /* Configure the Alarm state */
;;;1298     if (NewState != DISABLE)
;;;1299     {
;;;1300       RTC->CR |= (uint32_t)RTC_Alarm;
000010  4a0f              LDR      r2,|L1.80|
000012  3a1c              SUBS     r2,r2,#0x1c
000014  2900              CMP      r1,#0                 ;1298
;;;1301   
;;;1302       status = SUCCESS;    
;;;1303     }
;;;1304     else
;;;1305     { 
;;;1306       /* Disable the Alarm in RTC_CR register */
;;;1307       RTC->CR &= (uint32_t)~RTC_Alarm;
000016  6811              LDR      r1,[r2,#0]
000018  d002              BEQ      |L1.32|
00001a  4301              ORRS     r1,r1,r0              ;1300
00001c  6011              STR      r1,[r2,#0]            ;1300
00001e  e012              B        |L1.70|
                  |L1.32|
000020  4381              BICS     r1,r1,r0
000022  6011              STR      r1,[r2,#0]
;;;1308      
;;;1309       /* Wait till RTC ALRxWF flag is set and if Time out is reached exit */
;;;1310       do
;;;1311       {
;;;1312         alarmstatus = RTC->ISR & (RTC_Alarm >> 8);
000024  4a0a              LDR      r2,|L1.80|
000026  3a18              SUBS     r2,r2,#0x18
;;;1313         alarmcounter++;  
;;;1314       } while((alarmcounter != INITMODE_TIMEOUT) && (alarmstatus == 0x00));
000028  1395              ASRS     r5,r2,#14
                  |L1.42|
00002a  6811              LDR      r1,[r2,#0]            ;1312
00002c  9b00              LDR      r3,[sp,#0]            ;1313
00002e  ea012110          AND      r1,r1,r0,LSR #8       ;1312
000032  1c5b              ADDS     r3,r3,#1              ;1313
000034  9300              STR      r3,[sp,#0]
000036  42ab              CMP      r3,r5
000038  d001              BEQ      |L1.62|
00003a  2900              CMP      r1,#0
00003c  d0f5              BEQ      |L1.42|
                  |L1.62|
;;;1315       
;;;1316       if ((RTC->ISR & (RTC_Alarm >> 8)) == RESET)
00003e  6811              LDR      r1,[r2,#0]
000040  ea112010          ANDS     r0,r1,r0,LSR #8
000044  d000              BEQ      |L1.72|
                  |L1.70|
;;;1317       {
;;;1318         status = ERROR;
;;;1319       } 
;;;1320       else
;;;1321       {
;;;1322         status = SUCCESS;
000046  2001              MOVS     r0,#1
                  |L1.72|
;;;1323       }        
;;;1324     } 
;;;1325   
;;;1326     /* Enable the write protection for RTC registers */
;;;1327     RTC->WPR = 0xFF; 
000048  21ff              MOVS     r1,#0xff
00004a  6021              STR      r1,[r4,#0]
;;;1328     
;;;1329     return status;
;;;1330   }
00004c  bd38              POP      {r3-r5,pc}
;;;1331   
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      0x40002824

                          AREA ||i.RTC_AlarmStructInit||, CODE, READONLY, ALIGN=1

                  RTC_AlarmStructInit PROC
;;;1198     */
;;;1199   void RTC_AlarmStructInit(RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  2100              MOVS     r1,#0
;;;1200   {
;;;1201     /* Alarm Time Settings : Time = 00h:00mn:00sec */
;;;1202     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;1203     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;1204     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;1205     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = 0;
000008  7081              STRB     r1,[r0,#2]
;;;1206   
;;;1207     /* Alarm Date Settings : Date = 1st day of the month */
;;;1208     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = RTC_AlarmDateWeekDaySel_Date;
;;;1209     RTC_AlarmStruct->RTC_AlarmDateWeekDay = 1;
00000a  2201              MOVS     r2,#1
00000c  6081              STR      r1,[r0,#8]
00000e  7302              STRB     r2,[r0,#0xc]
;;;1210   
;;;1211     /* Alarm Masks Settings : Mask =  all fields are not masked */
;;;1212     RTC_AlarmStruct->RTC_AlarmMask = RTC_AlarmMask_None;
000010  6041              STR      r1,[r0,#4]
;;;1213   }
000012  4770              BX       lr
;;;1214   
                          ENDP


                          AREA ||i.RTC_AlarmSubSecondConfig||, CODE, READONLY, ALIGN=2

                  RTC_AlarmSubSecondConfig PROC
;;;1376     */
;;;1377   void RTC_AlarmSubSecondConfig(uint32_t RTC_Alarm, uint32_t RTC_AlarmSubSecondValue, uint32_t RTC_AlarmSubSecondMask)
000000  b510              PUSH     {r4,lr}
;;;1378   {
;;;1379     uint32_t tmpreg = 0;
;;;1380   
;;;1381     /* Check the parameters */
;;;1382     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1383     assert_param(IS_RTC_ALARM_SUB_SECOND_VALUE(RTC_AlarmSubSecondValue));
;;;1384     assert_param(IS_RTC_ALARM_SUB_SECOND_MASK(RTC_AlarmSubSecondMask));
;;;1385     
;;;1386     /* Disable the write protection for RTC registers */
;;;1387     RTC->WPR = 0xCA;
000002  4b09              LDR      r3,|L3.40|
000004  24ca              MOVS     r4,#0xca
000006  601c              STR      r4,[r3,#0]
;;;1388     RTC->WPR = 0x53;
000008  2453              MOVS     r4,#0x53
00000a  601c              STR      r4,[r3,#0]
;;;1389     
;;;1390     /* Configure the Alarm A or Alarm B SubSecond registers */
;;;1391     tmpreg = (uint32_t) (uint32_t)(RTC_AlarmSubSecondValue) | (uint32_t)(RTC_AlarmSubSecondMask);
00000c  4311              ORRS     r1,r1,r2
;;;1392     
;;;1393     if (RTC_Alarm == RTC_Alarm_A)
00000e  f5b07f80          CMP      r0,#0x100
000012  d005              BEQ      |L3.32|
;;;1394     {
;;;1395       /* Configure the AlarmA SubSecond register */
;;;1396       RTC->ALRMASSR = tmpreg;
;;;1397     }
;;;1398     else
;;;1399     {
;;;1400       /* Configure the Alarm B SubSecond register */
;;;1401       RTC->ALRMBSSR = tmpreg;
000014  4804              LDR      r0,|L3.40|
000016  3024              ADDS     r0,r0,#0x24
                  |L3.24|
000018  6001              STR      r1,[r0,#0]
;;;1402     }
;;;1403   
;;;1404     /* Enable the write protection for RTC registers */
;;;1405     RTC->WPR = 0xFF;
00001a  20ff              MOVS     r0,#0xff
00001c  6018              STR      r0,[r3,#0]
;;;1406   
;;;1407   }
00001e  bd10              POP      {r4,pc}
                  |L3.32|
000020  4801              LDR      r0,|L3.40|
000022  3020              ADDS     r0,r0,#0x20           ;1396
000024  e7f8              B        |L3.24|
;;;1408   
                          ENDP

000026  0000              DCW      0x0000
                  |L3.40|
                          DCD      0x40002824

                          AREA ||i.RTC_Bcd2ToByte||, CODE, READONLY, ALIGN=1

                  RTC_Bcd2ToByte PROC
;;;2712     */
;;;2713   static uint8_t RTC_Bcd2ToByte(uint8_t Value)
000000  0901              LSRS     r1,r0,#4
;;;2714   {
;;;2715     uint8_t tmp = 0;
;;;2716     tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
000002  eb010181          ADD      r1,r1,r1,LSL #2
;;;2717     return (tmp + (Value & (uint8_t)0x0F));
000006  f000000f          AND      r0,r0,#0xf
00000a  eb000041          ADD      r0,r0,r1,LSL #1
00000e  b2c0              UXTB     r0,r0
;;;2718   }
000010  4770              BX       lr
;;;2719   
                          ENDP


                          AREA ||i.RTC_BypassShadowCmd||, CODE, READONLY, ALIGN=2

                  RTC_BypassShadowCmd PROC
;;;697    */
;;;698    void RTC_BypassShadowCmd(FunctionalState NewState)
000000  4a09              LDR      r2,|L5.40|
;;;699    {
;;;700      /* Check the parameters */
;;;701      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;702    
;;;703      /* Disable the write protection for RTC registers */
;;;704      RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;705      RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;706      
;;;707      if (NewState != DISABLE)
;;;708      {
;;;709        /* Set the BYPSHAD bit */
;;;710        RTC->CR |= (uint8_t)RTC_CR_BYPSHAD;
00000a  4907              LDR      r1,|L5.40|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  2800              CMP      r0,#0                 ;707
;;;711      }
;;;712      else
;;;713      {
;;;714        /* Reset the BYPSHAD bit */
;;;715        RTC->CR &= (uint8_t)~RTC_CR_BYPSHAD;
000010  6808              LDR      r0,[r1,#0]
000012  d002              BEQ      |L5.26|
000014  f0400020          ORR      r0,r0,#0x20           ;710
000018  e001              B        |L5.30|
                  |L5.26|
00001a  f00000df          AND      r0,r0,#0xdf
                  |L5.30|
00001e  6008              STR      r0,[r1,#0]
;;;716      }
;;;717    
;;;718      /* Enable the write protection for RTC registers */
;;;719      RTC->WPR = 0xFF;
000020  20ff              MOVS     r0,#0xff
000022  6010              STR      r0,[r2,#0]
;;;720    }
000024  4770              BX       lr
;;;721    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      0x40002824

                          AREA ||i.RTC_ByteToBcd2||, CODE, READONLY, ALIGN=1

                  RTC_ByteToBcd2 PROC
;;;2694     */
;;;2695   static uint8_t RTC_ByteToBcd2(uint8_t Value)
000000  2100              MOVS     r1,#0
;;;2696   {
000002  e003              B        |L6.12|
                  |L6.4|
;;;2697     uint8_t bcdhigh = 0;
;;;2698     
;;;2699     while (Value >= 10)
;;;2700     {
;;;2701       bcdhigh++;
000004  1c49              ADDS     r1,r1,#1
;;;2702       Value -= 10;
000006  380a              SUBS     r0,r0,#0xa
000008  b2c9              UXTB     r1,r1                 ;2701
00000a  b2c0              UXTB     r0,r0
                  |L6.12|
00000c  280a              CMP      r0,#0xa               ;2699
00000e  d2f9              BCS      |L6.4|
;;;2703     }
;;;2704     
;;;2705     return  ((uint8_t)(bcdhigh << 4) | Value);
000010  0709              LSLS     r1,r1,#28
000012  ea406011          ORR      r0,r0,r1,LSR #24
;;;2706   }
000016  4770              BX       lr
;;;2707   
                          ENDP


                          AREA ||i.RTC_CalibOutputCmd||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputCmd PROC
;;;1810     */
;;;1811   void RTC_CalibOutputCmd(FunctionalState NewState)
000000  4a09              LDR      r2,|L7.40|
;;;1812   {
;;;1813     /* Check the parameters */
;;;1814     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1815     
;;;1816     /* Disable the write protection for RTC registers */
;;;1817     RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;1818     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1819     
;;;1820     if (NewState != DISABLE)
;;;1821     {
;;;1822       /* Enable the RTC clock output */
;;;1823       RTC->CR |= (uint32_t)RTC_CR_COE;
00000a  4907              LDR      r1,|L7.40|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  2800              CMP      r0,#0                 ;1820
;;;1824     }
;;;1825     else
;;;1826     { 
;;;1827       /* Disable the RTC clock output */
;;;1828       RTC->CR &= (uint32_t)~RTC_CR_COE;
000010  6808              LDR      r0,[r1,#0]
000012  d002              BEQ      |L7.26|
000014  f4400000          ORR      r0,r0,#0x800000       ;1823
000018  e001              B        |L7.30|
                  |L7.26|
00001a  f4200000          BIC      r0,r0,#0x800000
                  |L7.30|
00001e  6008              STR      r0,[r1,#0]
;;;1829     }
;;;1830     
;;;1831     /* Enable the write protection for RTC registers */
;;;1832     RTC->WPR = 0xFF; 
000020  20ff              MOVS     r0,#0xff
000022  6010              STR      r0,[r2,#0]
;;;1833   }
000024  4770              BX       lr
;;;1834   
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      0x40002824

                          AREA ||i.RTC_CalibOutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_CalibOutputConfig PROC
;;;1842   */
;;;1843   void RTC_CalibOutputConfig(uint32_t RTC_CalibOutput)
000000  4a08              LDR      r2,|L8.36|
;;;1844   {
;;;1845     /* Check the parameters */
;;;1846     assert_param(IS_RTC_CALIB_OUTPUT(RTC_CalibOutput));
;;;1847   
;;;1848     /* Disable the write protection for RTC registers */
;;;1849     RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;1850     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1851     
;;;1852     /*clear flags before config*/
;;;1853     RTC->CR &= (uint32_t)~(RTC_CR_COSEL);
00000a  4906              LDR      r1,|L8.36|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  680b              LDR      r3,[r1,#0]
000010  f4232300          BIC      r3,r3,#0x80000
000014  600b              STR      r3,[r1,#0]
;;;1854   
;;;1855     /* Configure the RTC_CR register */
;;;1856     RTC->CR |= (uint32_t)RTC_CalibOutput;
000016  680b              LDR      r3,[r1,#0]
000018  4303              ORRS     r3,r3,r0
00001a  600b              STR      r3,[r1,#0]
;;;1857   
;;;1858     /* Enable the write protection for RTC registers */
;;;1859     RTC->WPR = 0xFF;
00001c  20ff              MOVS     r0,#0xff
00001e  6010              STR      r0,[r2,#0]
;;;1860   }
000020  4770              BX       lr
;;;1861   
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      0x40002824

                          AREA ||i.RTC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RTC_ClearFlag PROC
;;;2611     */
;;;2612   void RTC_ClearFlag(uint32_t RTC_FLAG)
000000  b280              UXTH     r0,r0
;;;2613   {
;;;2614     /* Check the parameters */
;;;2615     assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG));
;;;2616   
;;;2617     /* Clear the Flags in the RTC_ISR register */
;;;2618     RTC->ISR = (uint32_t)((uint32_t)(~((RTC_FLAG | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT)));  
000002  f0400080          ORR      r0,r0,#0x80
000006  43c1              MVNS     r1,r0
000008  4803              LDR      r0,|L9.24|
00000a  6802              LDR      r2,[r0,#0]
00000c  f0020280          AND      r2,r2,#0x80
000010  4311              ORRS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;2619   }
000014  4770              BX       lr
;;;2620   
                          ENDP

000016  0000              DCW      0x0000
                  |L9.24|
                          DCD      0x4000280c

                          AREA ||i.RTC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RTC_ClearITPendingBit PROC
;;;2671     */
;;;2672   void RTC_ClearITPendingBit(uint32_t RTC_IT)
000000  f3c0100f          UBFX     r0,r0,#4,#16
;;;2673   {
;;;2674     uint32_t tmpreg = 0;
;;;2675   
;;;2676     /* Check the parameters */
;;;2677     assert_param(IS_RTC_CLEAR_IT(RTC_IT));
;;;2678   
;;;2679     /* Get the RTC_ISR Interrupt pending bits mask */
;;;2680     tmpreg = (uint32_t)(RTC_IT >> 4);
;;;2681   
;;;2682     /* Clear the interrupt pending bits in the RTC_ISR register */
;;;2683     RTC->ISR = (uint32_t)((uint32_t)(~((tmpreg | RTC_ISR_INIT)& 0x0000FFFF) | (uint32_t)(RTC->ISR & RTC_ISR_INIT))); 
000004  f0400080          ORR      r0,r0,#0x80
000008  43c1              MVNS     r1,r0
00000a  4803              LDR      r0,|L10.24|
00000c  6802              LDR      r2,[r0,#0]
00000e  f0020280          AND      r2,r2,#0x80
000012  4311              ORRS     r1,r1,r2
000014  6001              STR      r1,[r0,#0]
;;;2684   }
000016  4770              BX       lr
;;;2685   
                          ENDP

                  |L10.24|
                          DCD      0x4000280c

                          AREA ||i.RTC_CoarseCalibCmd||, CODE, READONLY, ALIGN=2

                  RTC_CoarseCalibCmd PROC
;;;1764     */
;;;1765   ErrorStatus RTC_CoarseCalibCmd(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1766   {
;;;1767     ErrorStatus status = ERROR;
;;;1768     
;;;1769     /* Check the parameters */
;;;1770     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1771   
;;;1772     /* Disable the write protection for RTC registers */
;;;1773     RTC->WPR = 0xCA;
000002  4d0d              LDR      r5,|L11.56|
000004  4606              MOV      r6,r0                 ;1766
000006  2400              MOVS     r4,#0                 ;1767
000008  20ca              MOVS     r0,#0xca
00000a  6028              STR      r0,[r5,#0]
;;;1774     RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6028              STR      r0,[r5,#0]
;;;1775     
;;;1776     /* Set Initialization mode */
;;;1777     if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b160              CBZ      r0,|L11.48|
;;;1778     {
;;;1779       status =  ERROR;
;;;1780     }
;;;1781     else
;;;1782     {
;;;1783       if (NewState != DISABLE)
;;;1784       {
;;;1785         /* Enable the Coarse Calibration */
;;;1786         RTC->CR |= (uint32_t)RTC_CR_DCE;
000016  4808              LDR      r0,|L11.56|
000018  381c              SUBS     r0,r0,#0x1c
;;;1787       }
;;;1788       else
;;;1789       { 
;;;1790         /* Disable the Coarse Calibration */
;;;1791         RTC->CR &= (uint32_t)~RTC_CR_DCE;
00001a  6801              LDR      r1,[r0,#0]
00001c  b116              CBZ      r6,|L11.36|
00001e  f0410180          ORR      r1,r1,#0x80           ;1786
000022  e001              B        |L11.40|
                  |L11.36|
000024  f0210180          BIC      r1,r1,#0x80
                  |L11.40|
000028  6001              STR      r1,[r0,#0]
;;;1792       }
;;;1793       /* Exit Initialization mode */
;;;1794       RTC_ExitInitMode();
00002a  f7fffffe          BL       RTC_ExitInitMode
;;;1795       
;;;1796       status = SUCCESS;
00002e  2401              MOVS     r4,#1
                  |L11.48|
;;;1797     } 
;;;1798     
;;;1799     /* Enable the write protection for RTC registers */
;;;1800     RTC->WPR = 0xFF; 
000030  20ff              MOVS     r0,#0xff
000032  6028              STR      r0,[r5,#0]
;;;1801     
;;;1802     return status;
000034  4620              MOV      r0,r4
;;;1803   }
000036  bd70              POP      {r4-r6,pc}
;;;1804   
                          ENDP

                  |L11.56|
                          DCD      0x40002824

                          AREA ||i.RTC_CoarseCalibConfig||, CODE, READONLY, ALIGN=2

                  RTC_CoarseCalibConfig PROC
;;;1723     */
;;;1724   ErrorStatus RTC_CoarseCalibConfig(uint32_t RTC_CalibSign, uint32_t Value)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1725   {
;;;1726     ErrorStatus status = ERROR;
;;;1727      
;;;1728     /* Check the parameters */
;;;1729     assert_param(IS_RTC_CALIB_SIGN(RTC_CalibSign));
;;;1730     assert_param(IS_RTC_CALIB_VALUE(Value)); 
;;;1731   
;;;1732     /* Disable the write protection for RTC registers */
;;;1733     RTC->WPR = 0xCA;
000002  4d0b              LDR      r5,|L12.48|
000004  4606              MOV      r6,r0                 ;1725
000006  2400              MOVS     r4,#0                 ;1726
000008  20ca              MOVS     r0,#0xca
00000a  460f              MOV      r7,r1                 ;1725
00000c  6028              STR      r0,[r5,#0]
;;;1734     RTC->WPR = 0x53;
00000e  2053              MOVS     r0,#0x53
000010  6028              STR      r0,[r5,#0]
;;;1735   
;;;1736     /* Set Initialization mode */
;;;1737     if (RTC_EnterInitMode() == ERROR)
000012  f7fffffe          BL       RTC_EnterInitMode
000016  b130              CBZ      r0,|L12.38|
;;;1738     {
;;;1739       status = ERROR;
;;;1740     } 
;;;1741     else
;;;1742     {
;;;1743       /* Set the coarse calibration value */
;;;1744       RTC->CALIBR = (uint32_t)(RTC_CalibSign | Value);
000018  4805              LDR      r0,|L12.48|
00001a  433e              ORRS     r6,r6,r7
00001c  380c              SUBS     r0,r0,#0xc
00001e  6006              STR      r6,[r0,#0]
;;;1745       /* Exit Initialization mode */
;;;1746       RTC_ExitInitMode();
000020  f7fffffe          BL       RTC_ExitInitMode
;;;1747       
;;;1748       status = SUCCESS;
000024  2401              MOVS     r4,#1
                  |L12.38|
;;;1749     } 
;;;1750   
;;;1751     /* Enable the write protection for RTC registers */
;;;1752     RTC->WPR = 0xFF; 
000026  20ff              MOVS     r0,#0xff
000028  6028              STR      r0,[r5,#0]
;;;1753     
;;;1754     return status;
00002a  4620              MOV      r0,r4
;;;1755   }
00002c  bdf0              POP      {r4-r7,pc}
;;;1756   
                          ENDP

00002e  0000              DCW      0x0000
                  |L12.48|
                          DCD      0x40002824

                          AREA ||i.RTC_DateStructInit||, CODE, READONLY, ALIGN=1

                  RTC_DateStructInit PROC
;;;1008     */
;;;1009   void RTC_DateStructInit(RTC_DateTypeDef* RTC_DateStruct)
000000  2101              MOVS     r1,#1
;;;1010   {
;;;1011     /* Monday, January 01 xx00 */
;;;1012     RTC_DateStruct->RTC_WeekDay = RTC_Weekday_Monday;
000002  7001              STRB     r1,[r0,#0]
;;;1013     RTC_DateStruct->RTC_Date = 1;
000004  7081              STRB     r1,[r0,#2]
;;;1014     RTC_DateStruct->RTC_Month = RTC_Month_January;
000006  7041              STRB     r1,[r0,#1]
;;;1015     RTC_DateStruct->RTC_Year = 0;
000008  2100              MOVS     r1,#0
00000a  70c1              STRB     r1,[r0,#3]
;;;1016   }
00000c  4770              BX       lr
;;;1017   
                          ENDP


                          AREA ||i.RTC_DayLightSavingConfig||, CODE, READONLY, ALIGN=2

                  RTC_DayLightSavingConfig PROC
;;;1603     */
;;;1604   void RTC_DayLightSavingConfig(uint32_t RTC_DayLightSaving, uint32_t RTC_StoreOperation)
000000  4b09              LDR      r3,|L14.40|
;;;1605   {
000002  b510              PUSH     {r4,lr}
;;;1606     /* Check the parameters */
;;;1607     assert_param(IS_RTC_DAYLIGHT_SAVING(RTC_DayLightSaving));
;;;1608     assert_param(IS_RTC_STORE_OPERATION(RTC_StoreOperation));
;;;1609   
;;;1610     /* Disable the write protection for RTC registers */
;;;1611     RTC->WPR = 0xCA;
000004  22ca              MOVS     r2,#0xca
000006  601a              STR      r2,[r3,#0]
;;;1612     RTC->WPR = 0x53;
000008  2253              MOVS     r2,#0x53
00000a  601a              STR      r2,[r3,#0]
;;;1613   
;;;1614     /* Clear the bits to be configured */
;;;1615     RTC->CR &= (uint32_t)~(RTC_CR_BCK);
00000c  4a06              LDR      r2,|L14.40|
00000e  3a1c              SUBS     r2,r2,#0x1c
000010  6814              LDR      r4,[r2,#0]
000012  f4242480          BIC      r4,r4,#0x40000
000016  6014              STR      r4,[r2,#0]
;;;1616   
;;;1617     /* Configure the RTC_CR register */
;;;1618     RTC->CR |= (uint32_t)(RTC_DayLightSaving | RTC_StoreOperation);
000018  6814              LDR      r4,[r2,#0]
00001a  4308              ORRS     r0,r0,r1
00001c  4304              ORRS     r4,r4,r0
00001e  6014              STR      r4,[r2,#0]
;;;1619   
;;;1620     /* Enable the write protection for RTC registers */
;;;1621     RTC->WPR = 0xFF; 
000020  20ff              MOVS     r0,#0xff
000022  6018              STR      r0,[r3,#0]
;;;1622   }
000024  bd10              POP      {r4,pc}
;;;1623   
                          ENDP

000026  0000              DCW      0x0000
                  |L14.40|
                          DCD      0x40002824

                          AREA ||i.RTC_DeInit||, CODE, READONLY, ALIGN=2

                  RTC_DeInit PROC
;;;366      */
;;;367    ErrorStatus RTC_DeInit(void)
000000  b578              PUSH     {r3-r6,lr}
;;;368    {
;;;369      __IO uint32_t wutcounter = 0x00;
000002  2500              MOVS     r5,#0
;;;370      uint32_t wutwfstatus = 0x00;
;;;371      ErrorStatus status = ERROR;
;;;372      
;;;373      /* Disable the write protection for RTC registers */
;;;374      RTC->WPR = 0xCA;
000004  4e22              LDR      r6,|L15.144|
000006  20ca              MOVS     r0,#0xca
000008  9500              STR      r5,[sp,#0]
00000a  462c              MOV      r4,r5                 ;371
00000c  6030              STR      r0,[r6,#0]
;;;375      RTC->WPR = 0x53;
00000e  2053              MOVS     r0,#0x53
000010  6030              STR      r0,[r6,#0]
;;;376    
;;;377      /* Set Initialization mode */
;;;378      if (RTC_EnterInitMode() == ERROR)
000012  f7fffffe          BL       RTC_EnterInitMode
000016  b3a0              CBZ      r0,|L15.130|
;;;379      {
;;;380        status = ERROR;
;;;381      }  
;;;382      else
;;;383      {
;;;384        /* Reset TR, DR and CR registers */
;;;385        RTC->TR = (uint32_t)0x00000000;
000018  481d              LDR      r0,|L15.144|
00001a  3824              SUBS     r0,r0,#0x24
00001c  6005              STR      r5,[r0,#0]
;;;386        RTC->DR = (uint32_t)0x00002101;
00001e  491c              LDR      r1,|L15.144|
000020  f2421001          MOV      r0,#0x2101
000024  3920              SUBS     r1,r1,#0x20
000026  6008              STR      r0,[r1,#0]
;;;387        /* Reset All CR bits except CR[2:0] */
;;;388        RTC->CR &= (uint32_t)0x00000007;
000028  1d0b              ADDS     r3,r1,#4
00002a  6818              LDR      r0,[r3,#0]
00002c  f0000007          AND      r0,r0,#7
000030  6018              STR      r0,[r3,#0]
;;;389      
;;;390        /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;391        do
;;;392        {
;;;393          wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
;;;394          wutcounter++;  
;;;395        } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
000032  138c              ASRS     r4,r1,#14
000034  1d19              ADDS     r1,r3,#4              ;393
                  |L15.54|
000036  6808              LDR      r0,[r1,#0]            ;393
000038  9a00              LDR      r2,[sp,#0]            ;394
00003a  f0000004          AND      r0,r0,#4              ;393
00003e  1c52              ADDS     r2,r2,#1              ;394
000040  9200              STR      r2,[sp,#0]
000042  42a2              CMP      r2,r4
000044  d001              BEQ      |L15.74|
000046  2800              CMP      r0,#0
000048  d0f5              BEQ      |L15.54|
                  |L15.74|
;;;396        
;;;397        if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
00004a  6808              LDR      r0,[r1,#0]
00004c  0740              LSLS     r0,r0,#29
00004e  d51c              BPL      |L15.138|
;;;398        {
;;;399          status = ERROR;
;;;400        }
;;;401        else
;;;402        {
;;;403          /* Reset all RTC CR register bits */
;;;404          RTC->CR &= (uint32_t)0x00000000;
000050  6818              LDR      r0,[r3,#0]
000052  601d              STR      r5,[r3,#0]
;;;405          RTC->WUTR = (uint32_t)0x0000FFFF;
000054  4a0e              LDR      r2,|L15.144|
000056  f64f70ff          MOV      r0,#0xffff
00005a  3a10              SUBS     r2,r2,#0x10
00005c  6010              STR      r0,[r2,#0]
;;;406          RTC->PRER = (uint32_t)0x007F00FF;
00005e  1f12              SUBS     r2,r2,#4
000060  480c              LDR      r0,|L15.148|
000062  6010              STR      r0,[r2,#0]
;;;407          RTC->CALIBR = (uint32_t)0x00000000;
000064  480a              LDR      r0,|L15.144|
000066  380c              SUBS     r0,r0,#0xc
000068  6005              STR      r5,[r0,#0]
;;;408          RTC->ALRMAR = (uint32_t)0x00000000;        
00006a  1d00              ADDS     r0,r0,#4
00006c  6005              STR      r5,[r0,#0]
;;;409          RTC->ALRMBR = (uint32_t)0x00000000;
00006e  1d00              ADDS     r0,r0,#4
000070  6005              STR      r5,[r0,#0]
;;;410          
;;;411          /* Reset ISR register and exit initialization mode */
;;;412          RTC->ISR = (uint32_t)0x00000000;
000072  600d              STR      r5,[r1,#0]
;;;413          
;;;414          /* Reset Tamper and alternate functions configuration register */
;;;415          RTC->TAFCR = 0x00000000;
000074  4806              LDR      r0,|L15.144|
000076  301c              ADDS     r0,r0,#0x1c
000078  6005              STR      r5,[r0,#0]
;;;416      
;;;417          if(RTC_WaitForSynchro() == ERROR)
00007a  f7fffffe          BL       RTC_WaitForSynchro
00007e  b120              CBZ      r0,|L15.138|
;;;418          {
;;;419            status = ERROR;
;;;420          }
;;;421          else
;;;422          {
;;;423            status = SUCCESS;      
000080  2401              MOVS     r4,#1
                  |L15.130|
;;;424          }
;;;425        }
;;;426      }
;;;427      
;;;428      /* Enable the write protection for RTC registers */
;;;429      RTC->WPR = 0xFF;  
000082  20ff              MOVS     r0,#0xff
000084  6030              STR      r0,[r6,#0]
;;;430      
;;;431      return status;
000086  4620              MOV      r0,r4
;;;432    }
000088  bd78              POP      {r3-r6,pc}
                  |L15.138|
00008a  2400              MOVS     r4,#0                 ;419
00008c  e7f9              B        |L15.130|
;;;433    
                          ENDP

00008e  0000              DCW      0x0000
                  |L15.144|
                          DCD      0x40002824
                  |L15.148|
                          DCD      0x007f00ff

                          AREA ||i.RTC_EnterInitMode||, CODE, READONLY, ALIGN=2

                  RTC_EnterInitMode PROC
;;;539      */
;;;540    ErrorStatus RTC_EnterInitMode(void)
000000  b508              PUSH     {r3,lr}
;;;541    {
;;;542      __IO uint32_t initcounter = 0x00;
;;;543      ErrorStatus status = ERROR;
;;;544      uint32_t initstatus = 0x00;
;;;545         
;;;546      /* Check if the Initialization mode is set */
;;;547      if ((RTC->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
000002  490d              LDR      r1,|L16.56|
000004  2000              MOVS     r0,#0                 ;542
000006  9000              STR      r0,[sp,#0]
000008  6808              LDR      r0,[r1,#0]
00000a  0640              LSLS     r0,r0,#25
00000c  d412              BMI      |L16.52|
;;;548      {
;;;549        /* Set the Initialization mode */
;;;550        RTC->ISR = (uint32_t)RTC_INIT_MASK;
00000e  f04f30ff          MOV      r0,#0xffffffff
000012  6008              STR      r0,[r1,#0]
;;;551        
;;;552        /* Wait till RTC is in INIT state and if Time out is reached exit */
;;;553        do
;;;554        {
;;;555          initstatus = RTC->ISR & RTC_ISR_INITF;
;;;556          initcounter++;  
;;;557        } while((initcounter != INITMODE_TIMEOUT) && (initstatus == 0x00));
000014  138b              ASRS     r3,r1,#14
                  |L16.22|
000016  6808              LDR      r0,[r1,#0]            ;555
000018  9a00              LDR      r2,[sp,#0]            ;556
00001a  f0000040          AND      r0,r0,#0x40           ;555
00001e  1c52              ADDS     r2,r2,#1              ;556
000020  9200              STR      r2,[sp,#0]
000022  429a              CMP      r2,r3
000024  d001              BEQ      |L16.42|
000026  2800              CMP      r0,#0
000028  d0f5              BEQ      |L16.22|
                  |L16.42|
;;;558        
;;;559        if ((RTC->ISR & RTC_ISR_INITF) != RESET)
00002a  6808              LDR      r0,[r1,#0]
00002c  0640              LSLS     r0,r0,#25
00002e  d401              BMI      |L16.52|
;;;560        {
;;;561          status = SUCCESS;
;;;562        }
;;;563        else
;;;564        {
;;;565          status = ERROR;
000030  2000              MOVS     r0,#0
;;;566        }        
;;;567      }
;;;568      else
;;;569      {
;;;570        status = SUCCESS;  
;;;571      } 
;;;572        
;;;573      return (status);  
;;;574    }
000032  bd08              POP      {r3,pc}
                  |L16.52|
000034  2001              MOVS     r0,#1                 ;570
000036  bd08              POP      {r3,pc}
;;;575    
                          ENDP

                  |L16.56|
                          DCD      0x4000280c

                          AREA ||i.RTC_ExitInitMode||, CODE, READONLY, ALIGN=2

                  RTC_ExitInitMode PROC
;;;584      */
;;;585    void RTC_ExitInitMode(void)
000000  4802              LDR      r0,|L17.12|
;;;586    { 
;;;587      /* Exit Initialization mode */
;;;588      RTC->ISR &= (uint32_t)~RTC_ISR_INIT;  
000002  6801              LDR      r1,[r0,#0]
000004  f0210180          BIC      r1,r1,#0x80
000008  6001              STR      r1,[r0,#0]
;;;589    }
00000a  4770              BX       lr
;;;590    
                          ENDP

                  |L17.12|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarm PROC
;;;1228     */
;;;1229   void RTC_GetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  b510              PUSH     {r4,lr}
;;;1230   {
000002  4614              MOV      r4,r2
000004  4602              MOV      r2,r0
;;;1231     uint32_t tmpreg = 0;
;;;1232   
;;;1233     /* Check the parameters */
;;;1234     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1235     assert_param(IS_RTC_ALARM(RTC_Alarm)); 
;;;1236   
;;;1237     /* Get the RTC_ALRMxR register */
;;;1238     if (RTC_Alarm == RTC_Alarm_A)
000006  f5b17f80          CMP      r1,#0x100
00000a  d029              BEQ      |L18.96|
;;;1239     {
;;;1240       tmpreg = (uint32_t)(RTC->ALRMAR);
;;;1241     }
;;;1242     else
;;;1243     {
;;;1244       tmpreg = (uint32_t)(RTC->ALRMBR);
00000c  4816              LDR      r0,|L18.104|
                  |L18.14|
00000e  6801              LDR      r1,[r0,#0]
;;;1245     }
;;;1246   
;;;1247     /* Fill the structure with the read parameters */
;;;1248     RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = (uint32_t)((tmpreg & (RTC_ALRMAR_HT | \
000010  f3c14005          UBFX     r0,r1,#16,#6
000014  7020              STRB     r0,[r4,#0]
;;;1249                                                        RTC_ALRMAR_HU)) >> 16);
;;;1250     RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = (uint32_t)((tmpreg & (RTC_ALRMAR_MNT | \
000016  f3c12306          UBFX     r3,r1,#8,#7
00001a  7063              STRB     r3,[r4,#1]
;;;1251                                                        RTC_ALRMAR_MNU)) >> 8);
;;;1252     RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = (uint32_t)(tmpreg & (RTC_ALRMAR_ST | \
00001c  f001037f          AND      r3,r1,#0x7f
000020  70a3              STRB     r3,[r4,#2]
;;;1253                                                        RTC_ALRMAR_SU));
;;;1254     RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = (uint32_t)((tmpreg & RTC_ALRMAR_PM) >> 16);
000022  2340              MOVS     r3,#0x40
000024  ea034311          AND      r3,r3,r1,LSR #16
000028  70e3              STRB     r3,[r4,#3]
;;;1255     RTC_AlarmStruct->RTC_AlarmDateWeekDay = (uint32_t)((tmpreg & (RTC_ALRMAR_DT | RTC_ALRMAR_DU)) >> 24);
00002a  f3c16305          UBFX     r3,r1,#24,#6
00002e  7323              STRB     r3,[r4,#0xc]
;;;1256     RTC_AlarmStruct->RTC_AlarmDateWeekDaySel = (uint32_t)(tmpreg & RTC_ALRMAR_WDSEL);
000030  f0014380          AND      r3,r1,#0x40000000
;;;1257     RTC_AlarmStruct->RTC_AlarmMask = (uint32_t)(tmpreg & RTC_AlarmMask_All);
000034  f0013180          AND      r1,r1,#0x80808080
000038  e9c41301          STRD     r1,r3,[r4,#4]
00003c  2a00              CMP      r2,#0
00003e  d10e              BNE      |L18.94|
;;;1258   
;;;1259     if (RTC_Format == RTC_Format_BIN)
;;;1260     {
;;;1261       RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000040  f7fffffe          BL       RTC_Bcd2ToByte
000044  7020              STRB     r0,[r4,#0]
;;;1262                                                           RTC_AlarmTime.RTC_Hours);
;;;1263       RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
000046  7860              LDRB     r0,[r4,#1]
000048  f7fffffe          BL       RTC_Bcd2ToByte
00004c  7060              STRB     r0,[r4,#1]
;;;1264                                                           RTC_AlarmTime.RTC_Minutes);
;;;1265       RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds = RTC_Bcd2ToByte(RTC_AlarmStruct-> \
00004e  78a0              LDRB     r0,[r4,#2]
000050  f7fffffe          BL       RTC_Bcd2ToByte
000054  70a0              STRB     r0,[r4,#2]
;;;1266                                                           RTC_AlarmTime.RTC_Seconds);
;;;1267       RTC_AlarmStruct->RTC_AlarmDateWeekDay = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
000056  7b20              LDRB     r0,[r4,#0xc]
000058  f7fffffe          BL       RTC_Bcd2ToByte
00005c  7320              STRB     r0,[r4,#0xc]
                  |L18.94|
;;;1268     }  
;;;1269   }
00005e  bd10              POP      {r4,pc}
                  |L18.96|
000060  4801              LDR      r0,|L18.104|
000062  1f00              SUBS     r0,r0,#4              ;1240
000064  e7d3              B        |L18.14|
;;;1270   
                          ENDP

000066  0000              DCW      0x0000
                  |L18.104|
                          DCD      0x40002820

                          AREA ||i.RTC_GetAlarmSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetAlarmSubSecond PROC
;;;1417     */
;;;1418   uint32_t RTC_GetAlarmSubSecond(uint32_t RTC_Alarm)
000000  f5b07f80          CMP      r0,#0x100
;;;1419   {
000004  d004              BEQ      |L19.16|
;;;1420     uint32_t tmpreg = 0;
;;;1421     
;;;1422     /* Get the RTC_ALRMxR register */
;;;1423     if (RTC_Alarm == RTC_Alarm_A)
;;;1424     {
;;;1425       tmpreg = (uint32_t)((RTC->ALRMASSR) & RTC_ALRMASSR_SS);
;;;1426     }
;;;1427     else
;;;1428     {
;;;1429       tmpreg = (uint32_t)((RTC->ALRMBSSR) & RTC_ALRMBSSR_SS);
000006  4804              LDR      r0,|L19.24|
                  |L19.8|
000008  6800              LDR      r0,[r0,#0]            ;1425
00000a  f3c0000e          UBFX     r0,r0,#0,#15          ;1425
;;;1430     } 
;;;1431     
;;;1432     return (tmpreg);
;;;1433   }
00000e  4770              BX       lr
                  |L19.16|
000010  4801              LDR      r0,|L19.24|
000012  1f00              SUBS     r0,r0,#4              ;1425
000014  e7f8              B        |L19.8|
;;;1434   
                          ENDP

000016  0000              DCW      0x0000
                  |L19.24|
                          DCD      0x40002848

                          AREA ||i.RTC_GetDate||, CODE, READONLY, ALIGN=2

                  RTC_GetDate PROC
;;;1027     */
;;;1028   void RTC_GetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  0002              MOVS     r2,r0
;;;1029   {
000002  b510              PUSH     {r4,lr}
;;;1030     uint32_t tmpreg = 0;
;;;1031   
;;;1032     /* Check the parameters */
;;;1033     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1034     
;;;1035     /* Get the RTC_TR register */
;;;1036     tmpreg = (uint32_t)(RTC->DR & RTC_DR_RESERVED_MASK); 
000004  480f              LDR      r0,|L20.68|
000006  460c              MOV      r4,r1                 ;1029
000008  6801              LDR      r1,[r0,#0]
00000a  480f              LDR      r0,|L20.72|
00000c  ea010100          AND      r1,r1,r0
;;;1037   
;;;1038     /* Fill the structure fields with the read parameters */
;;;1039     RTC_DateStruct->RTC_Year = (uint8_t)((tmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
000010  ea4f4011          LSR      r0,r1,#16
000014  70e0              STRB     r0,[r4,#3]
;;;1040     RTC_DateStruct->RTC_Month = (uint8_t)((tmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000016  f3c12304          UBFX     r3,r1,#8,#5
00001a  7063              STRB     r3,[r4,#1]
;;;1041     RTC_DateStruct->RTC_Date = (uint8_t)(tmpreg & (RTC_DR_DT | RTC_DR_DU));
00001c  f001033f          AND      r3,r1,#0x3f
000020  70a3              STRB     r3,[r4,#2]
;;;1042     RTC_DateStruct->RTC_WeekDay = (uint8_t)((tmpreg & (RTC_DR_WDU)) >> 13);
000022  f3c13142          UBFX     r1,r1,#13,#3
000026  7021              STRB     r1,[r4,#0]
000028  d10a              BNE      |L20.64|
;;;1043   
;;;1044     /* Check the input parameters format */
;;;1045     if (RTC_Format == RTC_Format_BIN)
;;;1046     {
;;;1047       /* Convert the structure parameters to Binary format */
;;;1048       RTC_DateStruct->RTC_Year = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year);
00002a  f7fffffe          BL       RTC_Bcd2ToByte
00002e  70e0              STRB     r0,[r4,#3]
;;;1049       RTC_DateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
000030  7860              LDRB     r0,[r4,#1]
000032  f7fffffe          BL       RTC_Bcd2ToByte
000036  7060              STRB     r0,[r4,#1]
;;;1050       RTC_DateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
000038  78a0              LDRB     r0,[r4,#2]
00003a  f7fffffe          BL       RTC_Bcd2ToByte
00003e  70a0              STRB     r0,[r4,#2]
                  |L20.64|
;;;1051     }
;;;1052   }
000040  bd10              POP      {r4,pc}
;;;1053   
                          ENDP

000042  0000              DCW      0x0000
                  |L20.68|
                          DCD      0x40002804
                  |L20.72|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetFlagStatus PROC
;;;2575     */
;;;2576   FlagStatus RTC_GetFlagStatus(uint32_t RTC_FLAG)
000000  4905              LDR      r1,|L21.24|
;;;2577   {
000002  4602              MOV      r2,r0
;;;2578     FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;2579     uint32_t tmpreg = 0;
;;;2580     
;;;2581     /* Check the parameters */
;;;2582     assert_param(IS_RTC_GET_FLAG(RTC_FLAG));
;;;2583     
;;;2584     /* Get all the flags */
;;;2585     tmpreg = (uint32_t)(RTC->ISR & RTC_FLAGS_MASK);
000006  6809              LDR      r1,[r1,#0]
000008  f6437377          MOV      r3,#0x3f77
00000c  4019              ANDS     r1,r1,r3
;;;2586     
;;;2587     /* Return the status of the flag */
;;;2588     if ((tmpreg & RTC_FLAG) != (uint32_t)RESET)
00000e  4211              TST      r1,r2
000010  d000              BEQ      |L21.20|
;;;2589     {
;;;2590       bitstatus = SET;
000012  2001              MOVS     r0,#1
                  |L21.20|
;;;2591     }
;;;2592     else
;;;2593     {
;;;2594       bitstatus = RESET;
;;;2595     }
;;;2596     return bitstatus;
;;;2597   }
000014  4770              BX       lr
;;;2598   
                          ENDP

000016  0000              DCW      0x0000
                  |L21.24|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetITStatus PROC
;;;2631     */
;;;2632   ITStatus RTC_GetITStatus(uint32_t RTC_IT)
000000  4a0b              LDR      r2,|L22.48|
;;;2633   {
;;;2634     ITStatus bitstatus = RESET;
000002  2100              MOVS     r1,#0
;;;2635     uint32_t tmpreg = 0, enablestatus = 0;
;;;2636    
;;;2637     /* Check the parameters */
;;;2638     assert_param(IS_RTC_GET_IT(RTC_IT));
;;;2639     
;;;2640     /* Get the TAMPER Interrupt enable bit and pending bit */
;;;2641     tmpreg = (uint32_t)(RTC->TAFCR & (RTC_TAFCR_TAMPIE));
000004  6812              LDR      r2,[r2,#0]
000006  f0020304          AND      r3,r2,#4
;;;2642    
;;;2643     /* Get the Interrupt enable Status */
;;;2644     enablestatus = (uint32_t)((RTC->CR & RTC_IT) | (tmpreg & (RTC_IT >> 15)));
00000a  4a09              LDR      r2,|L22.48|
00000c  3a38              SUBS     r2,r2,#0x38
00000e  6812              LDR      r2,[r2,#0]
000010  ea0333d0          AND      r3,r3,r0,LSR #15
000014  4002              ANDS     r2,r2,r0
000016  431a              ORRS     r2,r2,r3
;;;2645     
;;;2646     /* Get the Interrupt pending bit */
;;;2647     tmpreg = (uint32_t)((RTC->ISR & (uint32_t)(RTC_IT >> 4)));
000018  4b06              LDR      r3,|L22.52|
00001a  681b              LDR      r3,[r3,#0]
00001c  ea031010          AND      r0,r3,r0,LSR #4
000020  d003              BEQ      |L22.42|
;;;2648     
;;;2649     /* Get the status of the Interrupt */
;;;2650     if ((enablestatus != (uint32_t)RESET) && ((tmpreg & 0x0000FFFF) != (uint32_t)RESET))
000022  0400              LSLS     r0,r0,#16
000024  0c00              LSRS     r0,r0,#16
000026  d000              BEQ      |L22.42|
;;;2651     {
;;;2652       bitstatus = SET;
000028  2101              MOVS     r1,#1
                  |L22.42|
;;;2653     }
;;;2654     else
;;;2655     {
;;;2656       bitstatus = RESET;
;;;2657     }
;;;2658     return bitstatus;
00002a  4608              MOV      r0,r1
;;;2659   }
00002c  4770              BX       lr
;;;2660   
                          ENDP

00002e  0000              DCW      0x0000
                  |L22.48|
                          DCD      0x40002840
                  |L22.52|
                          DCD      0x4000280c

                          AREA ||i.RTC_GetStoreOperation||, CODE, READONLY, ALIGN=2

                  RTC_GetStoreOperation PROC
;;;1630     */
;;;1631   uint32_t RTC_GetStoreOperation(void)
000000  4802              LDR      r0,|L23.12|
;;;1632   {
;;;1633     return (RTC->CR & RTC_CR_BCK);
000002  6800              LDR      r0,[r0,#0]
000004  f4002080          AND      r0,r0,#0x40000
;;;1634   }
000008  4770              BX       lr
;;;1635   
                          ENDP

00000a  0000              DCW      0x0000
                  |L23.12|
                          DCD      0x40002808

                          AREA ||i.RTC_GetSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetSubSecond PROC
;;;900      */
;;;901    uint32_t RTC_GetSubSecond(void)
000000  4802              LDR      r0,|L24.12|
;;;902    {
;;;903      uint32_t tmpreg = 0;
;;;904      
;;;905      /* Get subseconds values from the correspondent registers*/
;;;906      tmpreg = (uint32_t)(RTC->SSR);
000002  6800              LDR      r0,[r0,#0]
;;;907      
;;;908      /* Read DR register to unfroze calendar registers */
;;;909      (void) (RTC->DR);
000004  4901              LDR      r1,|L24.12|
000006  3924              SUBS     r1,r1,#0x24
000008  6809              LDR      r1,[r1,#0]
;;;910      
;;;911      return (tmpreg);
;;;912    }
00000a  4770              BX       lr
;;;913    
                          ENDP

                  |L24.12|
                          DCD      0x40002828

                          AREA ||i.RTC_GetTime||, CODE, READONLY, ALIGN=2

                  RTC_GetTime PROC
;;;867      */
;;;868    void RTC_GetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  0002              MOVS     r2,r0
;;;869    {
000002  b510              PUSH     {r4,lr}
;;;870      uint32_t tmpreg = 0;
;;;871    
;;;872      /* Check the parameters */
;;;873      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;874    
;;;875      /* Get the RTC_TR register */
;;;876      tmpreg = (uint32_t)(RTC->TR & RTC_TR_RESERVED_MASK); 
000004  4810              LDR      r0,|L25.72|
000006  460c              MOV      r4,r1                 ;869
000008  6801              LDR      r1,[r0,#0]
00000a  4810              LDR      r0,|L25.76|
00000c  ea010100          AND      r1,r1,r0
;;;877      
;;;878      /* Fill the structure fields with the read parameters */
;;;879      RTC_TimeStruct->RTC_Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
000010  f3c14005          UBFX     r0,r1,#16,#6
000014  7020              STRB     r0,[r4,#0]
;;;880      RTC_TimeStruct->RTC_Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
000016  f3c12306          UBFX     r3,r1,#8,#7
00001a  7063              STRB     r3,[r4,#1]
;;;881      RTC_TimeStruct->RTC_Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
00001c  f001037f          AND      r3,r1,#0x7f
000020  70a3              STRB     r3,[r4,#2]
;;;882      RTC_TimeStruct->RTC_H12 = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);  
000022  f04f0340          MOV      r3,#0x40
000026  ea034111          AND      r1,r3,r1,LSR #16
00002a  70e1              STRB     r1,[r4,#3]
00002c  d10a              BNE      |L25.68|
;;;883    
;;;884      /* Check the input parameters format */
;;;885      if (RTC_Format == RTC_Format_BIN)
;;;886      {
;;;887        /* Convert the structure parameters to Binary format */
;;;888        RTC_TimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00002e  f7fffffe          BL       RTC_Bcd2ToByte
000032  7020              STRB     r0,[r4,#0]
;;;889        RTC_TimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes);
000034  7860              LDRB     r0,[r4,#1]
000036  f7fffffe          BL       RTC_Bcd2ToByte
00003a  7060              STRB     r0,[r4,#1]
;;;890        RTC_TimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds);   
00003c  78a0              LDRB     r0,[r4,#2]
00003e  f7fffffe          BL       RTC_Bcd2ToByte
000042  70a0              STRB     r0,[r4,#2]
                  |L25.68|
;;;891      }
;;;892    }
000044  bd10              POP      {r4,pc}
;;;893    
                          ENDP

000046  0000              DCW      0x0000
                  |L25.72|
                          DCD      0x40002800
                  |L25.76|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_GetTimeStamp||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStamp PROC
;;;1998     */
;;;1999   void RTC_GetTimeStamp(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_StampTimeStruct, 
000000  b570              PUSH     {r4-r6,lr}
;;;2000                                         RTC_DateTypeDef* RTC_StampDateStruct)
;;;2001   {
000002  460d              MOV      r5,r1
;;;2002     uint32_t tmptime = 0, tmpdate = 0;
;;;2003   
;;;2004     /* Check the parameters */
;;;2005     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;2006   
;;;2007     /* Get the TimeStamp time and date registers values */
;;;2008     tmptime = (uint32_t)(RTC->TSTR & RTC_TR_RESERVED_MASK);
000004  491e              LDR      r1,|L26.128|
000006  4614              MOV      r4,r2                 ;2001
000008  6809              LDR      r1,[r1,#0]
00000a  4a1e              LDR      r2,|L26.132|
00000c  4011              ANDS     r1,r1,r2
;;;2009     tmpdate = (uint32_t)(RTC->TSDR & RTC_DR_RESERVED_MASK);
00000e  4a1c              LDR      r2,|L26.128|
000010  1d12              ADDS     r2,r2,#4
000012  6812              LDR      r2,[r2,#0]
000014  f64f733f          MOV      r3,#0xff3f
000018  401a              ANDS     r2,r2,r3
;;;2010   
;;;2011     /* Fill the Time structure fields with the read parameters */
;;;2012     RTC_StampTimeStruct->RTC_Hours = (uint8_t)((tmptime & (RTC_TR_HT | RTC_TR_HU)) >> 16);
00001a  f3c14305          UBFX     r3,r1,#16,#6
00001e  702b              STRB     r3,[r5,#0]
;;;2013     RTC_StampTimeStruct->RTC_Minutes = (uint8_t)((tmptime & (RTC_TR_MNT | RTC_TR_MNU)) >> 8);
000020  f3c12306          UBFX     r3,r1,#8,#7
000024  706b              STRB     r3,[r5,#1]
;;;2014     RTC_StampTimeStruct->RTC_Seconds = (uint8_t)(tmptime & (RTC_TR_ST | RTC_TR_SU));
000026  f001037f          AND      r3,r1,#0x7f
00002a  70ab              STRB     r3,[r5,#2]
;;;2015     RTC_StampTimeStruct->RTC_H12 = (uint8_t)((tmptime & (RTC_TR_PM)) >> 16);  
00002c  2340              MOVS     r3,#0x40
00002e  ea034111          AND      r1,r3,r1,LSR #16
000032  70e9              STRB     r1,[r5,#3]
;;;2016   
;;;2017     /* Fill the Date structure fields with the read parameters */
;;;2018     RTC_StampDateStruct->RTC_Year = 0;
000034  2100              MOVS     r1,#0
000036  70e1              STRB     r1,[r4,#3]
;;;2019     RTC_StampDateStruct->RTC_Month = (uint8_t)((tmpdate & (RTC_DR_MT | RTC_DR_MU)) >> 8);
000038  f3c22104          UBFX     r1,r2,#8,#5
00003c  7061              STRB     r1,[r4,#1]
;;;2020     RTC_StampDateStruct->RTC_Date = (uint8_t)(tmpdate & (RTC_DR_DT | RTC_DR_DU));
00003e  f002013f          AND      r1,r2,#0x3f
000042  70a1              STRB     r1,[r4,#2]
;;;2021     RTC_StampDateStruct->RTC_WeekDay = (uint8_t)((tmpdate & (RTC_DR_WDU)) >> 13);
000044  f3c23142          UBFX     r1,r2,#13,#3
000048  7021              STRB     r1,[r4,#0]
00004a  2800              CMP      r0,#0                 ;2001
00004c  d117              BNE      |L26.126|
;;;2022   
;;;2023     /* Check the input parameters format */
;;;2024     if (RTC_Format == RTC_Format_BIN)
;;;2025     {
;;;2026       /* Convert the Time structure parameters to Binary format */
;;;2027       RTC_StampTimeStruct->RTC_Hours = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Hours);
00004e  7828              LDRB     r0,[r5,#0]
000050  f7fffffe          BL       RTC_Bcd2ToByte
000054  7028              STRB     r0,[r5,#0]
;;;2028       RTC_StampTimeStruct->RTC_Minutes = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Minutes);
000056  7868              LDRB     r0,[r5,#1]
000058  f7fffffe          BL       RTC_Bcd2ToByte
00005c  7068              STRB     r0,[r5,#1]
;;;2029       RTC_StampTimeStruct->RTC_Seconds = (uint8_t)RTC_Bcd2ToByte(RTC_StampTimeStruct->RTC_Seconds);
00005e  78a8              LDRB     r0,[r5,#2]
000060  f7fffffe          BL       RTC_Bcd2ToByte
000064  70a8              STRB     r0,[r5,#2]
;;;2030   
;;;2031       /* Convert the Date structure parameters to Binary format */
;;;2032       RTC_StampDateStruct->RTC_Month = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Month);
000066  7860              LDRB     r0,[r4,#1]
000068  f7fffffe          BL       RTC_Bcd2ToByte
00006c  7060              STRB     r0,[r4,#1]
;;;2033       RTC_StampDateStruct->RTC_Date = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_Date);
00006e  78a0              LDRB     r0,[r4,#2]
000070  f7fffffe          BL       RTC_Bcd2ToByte
000074  70a0              STRB     r0,[r4,#2]
;;;2034       RTC_StampDateStruct->RTC_WeekDay = (uint8_t)RTC_Bcd2ToByte(RTC_StampDateStruct->RTC_WeekDay);
000076  7820              LDRB     r0,[r4,#0]
000078  f7fffffe          BL       RTC_Bcd2ToByte
00007c  7020              STRB     r0,[r4,#0]
                  |L26.126|
;;;2035     }
;;;2036   }
00007e  bd70              POP      {r4-r6,pc}
;;;2037   
                          ENDP

                  |L26.128|
                          DCD      0x40002830
                  |L26.132|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_GetTimeStampSubSecond||, CODE, READONLY, ALIGN=2

                  RTC_GetTimeStampSubSecond PROC
;;;2042     */
;;;2043   uint32_t RTC_GetTimeStampSubSecond(void)
000000  4801              LDR      r0,|L27.8|
;;;2044   {
;;;2045     /* Get timestamp subseconds values from the correspondent registers */
;;;2046     return (uint32_t)(RTC->TSSSR);
000002  6800              LDR      r0,[r0,#0]
;;;2047   }
000004  4770              BX       lr
;;;2048   
                          ENDP

000006  0000              DCW      0x0000
                  |L27.8|
                          DCD      0x40002838

                          AREA ||i.RTC_GetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_GetWakeUpCounter PROC
;;;1514     */
;;;1515   uint32_t RTC_GetWakeUpCounter(void)
000000  4801              LDR      r0,|L28.8|
;;;1516   {
;;;1517     /* Get the counter value */
;;;1518     return ((uint32_t)(RTC->WUTR & RTC_WUTR_WUT));
000002  6800              LDR      r0,[r0,#0]
000004  b280              UXTH     r0,r0
;;;1519   }
000006  4770              BX       lr
;;;1520   
                          ENDP

                  |L28.8|
                          DCD      0x40002814

                          AREA ||i.RTC_ITConfig||, CODE, READONLY, ALIGN=2

                  RTC_ITConfig PROC
;;;2529     */
;;;2530   void RTC_ITConfig(uint32_t RTC_IT, FunctionalState NewState)
000000  b530              PUSH     {r4,r5,lr}
;;;2531   {
;;;2532     /* Check the parameters */
;;;2533     assert_param(IS_RTC_CONFIG_IT(RTC_IT));
;;;2534     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2535   
;;;2536     /* Disable the write protection for RTC registers */
;;;2537     RTC->WPR = 0xCA;
000002  4d0e              LDR      r5,|L29.60|
000004  22ca              MOVS     r2,#0xca
000006  602a              STR      r2,[r5,#0]
;;;2538     RTC->WPR = 0x53;
000008  2253              MOVS     r2,#0x53
00000a  602a              STR      r2,[r5,#0]
;;;2539   
;;;2540     if (NewState != DISABLE)
;;;2541     {
;;;2542       /* Configure the Interrupts in the RTC_CR register */
;;;2543       RTC->CR |= (uint32_t)(RTC_IT & ~RTC_TAFCR_TAMPIE);
00000c  4c0b              LDR      r4,|L29.60|
;;;2544       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2545       RTC->TAFCR |= (uint32_t)(RTC_IT & RTC_TAFCR_TAMPIE);
00000e  4b0b              LDR      r3,|L29.60|
000010  3c1c              SUBS     r4,r4,#0x1c           ;2543
000012  331c              ADDS     r3,r3,#0x1c
000014  2900              CMP      r1,#0                 ;2540
000016  f0200204          BIC      r2,r0,#4              ;2543
;;;2546     }
;;;2547     else
;;;2548     {
;;;2549       /* Configure the Interrupts in the RTC_CR register */
;;;2550       RTC->CR &= (uint32_t)~(RTC_IT & (uint32_t)~RTC_TAFCR_TAMPIE);
00001a  6821              LDR      r1,[r4,#0]
00001c  f0000004          AND      r0,r0,#4              ;2545
000020  d004              BEQ      |L29.44|
000022  4311              ORRS     r1,r1,r2              ;2543
000024  6021              STR      r1,[r4,#0]            ;2543
000026  6819              LDR      r1,[r3,#0]            ;2545
000028  4301              ORRS     r1,r1,r0              ;2545
00002a  e003              B        |L29.52|
                  |L29.44|
00002c  4391              BICS     r1,r1,r2
00002e  6021              STR      r1,[r4,#0]
;;;2551       /* Configure the Tamper Interrupt in the RTC_TAFCR */
;;;2552       RTC->TAFCR &= (uint32_t)~(RTC_IT & RTC_TAFCR_TAMPIE);
000030  6819              LDR      r1,[r3,#0]
000032  4381              BICS     r1,r1,r0
                  |L29.52|
000034  6019              STR      r1,[r3,#0]
;;;2553     }
;;;2554     /* Enable the write protection for RTC registers */
;;;2555     RTC->WPR = 0xFF; 
000036  20ff              MOVS     r0,#0xff
000038  6028              STR      r0,[r5,#0]
;;;2556   }
00003a  bd30              POP      {r4,r5,pc}
;;;2557   
                          ENDP

                  |L29.60|
                          DCD      0x40002824

                          AREA ||i.RTC_Init||, CODE, READONLY, ALIGN=2

                  RTC_Init PROC
;;;444      */
;;;445    ErrorStatus RTC_Init(RTC_InitTypeDef* RTC_InitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;446    {
;;;447      ErrorStatus status = ERROR;
;;;448      
;;;449      /* Check the parameters */
;;;450      assert_param(IS_RTC_HOUR_FORMAT(RTC_InitStruct->RTC_HourFormat));
;;;451      assert_param(IS_RTC_ASYNCH_PREDIV(RTC_InitStruct->RTC_AsynchPrediv));
;;;452      assert_param(IS_RTC_SYNCH_PREDIV(RTC_InitStruct->RTC_SynchPrediv));
;;;453    
;;;454      /* Disable the write protection for RTC registers */
;;;455      RTC->WPR = 0xCA;
000002  4d12              LDR      r5,|L30.76|
000004  4604              MOV      r4,r0                 ;446
000006  2600              MOVS     r6,#0                 ;447
000008  20ca              MOVS     r0,#0xca
00000a  6028              STR      r0,[r5,#0]
;;;456      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6028              STR      r0,[r5,#0]
;;;457    
;;;458      /* Set Initialization mode */
;;;459      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b1a8              CBZ      r0,|L30.66|
;;;460      {
;;;461        status = ERROR;
;;;462      } 
;;;463      else
;;;464      {
;;;465        /* Clear RTC CR FMT Bit */
;;;466        RTC->CR &= ((uint32_t)~(RTC_CR_FMT));
000016  480d              LDR      r0,|L30.76|
000018  381c              SUBS     r0,r0,#0x1c
00001a  6801              LDR      r1,[r0,#0]
00001c  f0210140          BIC      r1,r1,#0x40
000020  6001              STR      r1,[r0,#0]
;;;467        /* Set RTC_CR register */
;;;468        RTC->CR |=  ((uint32_t)(RTC_InitStruct->RTC_HourFormat));
000022  6801              LDR      r1,[r0,#0]
000024  6822              LDR      r2,[r4,#0]
000026  4311              ORRS     r1,r1,r2
000028  6001              STR      r1,[r0,#0]
;;;469      
;;;470        /* Configure the RTC PRER */
;;;471        RTC->PRER = (uint32_t)(RTC_InitStruct->RTC_SynchPrediv);
00002a  4808              LDR      r0,|L30.76|
00002c  68a1              LDR      r1,[r4,#8]
00002e  3814              SUBS     r0,r0,#0x14
000030  6001              STR      r1,[r0,#0]
;;;472        RTC->PRER |= (uint32_t)(RTC_InitStruct->RTC_AsynchPrediv << 16);
000032  6801              LDR      r1,[r0,#0]
000034  88a2              LDRH     r2,[r4,#4]
000036  ea414102          ORR      r1,r1,r2,LSL #16
00003a  6001              STR      r1,[r0,#0]
;;;473    
;;;474        /* Exit Initialization mode */
;;;475        RTC_ExitInitMode();
00003c  f7fffffe          BL       RTC_ExitInitMode
;;;476    
;;;477        status = SUCCESS;    
000040  2601              MOVS     r6,#1
                  |L30.66|
;;;478      }
;;;479      /* Enable the write protection for RTC registers */
;;;480      RTC->WPR = 0xFF; 
000042  20ff              MOVS     r0,#0xff
000044  6028              STR      r0,[r5,#0]
;;;481      
;;;482      return status;
000046  4630              MOV      r0,r6
;;;483    }
000048  bd70              POP      {r4-r6,pc}
;;;484    
                          ENDP

00004a  0000              DCW      0x0000
                  |L30.76|
                          DCD      0x40002824

                          AREA ||i.RTC_OutputConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputConfig PROC
;;;1669     */
;;;1670   void RTC_OutputConfig(uint32_t RTC_Output, uint32_t RTC_OutputPolarity)
000000  4b09              LDR      r3,|L31.40|
;;;1671   {
000002  b510              PUSH     {r4,lr}
;;;1672     /* Check the parameters */
;;;1673     assert_param(IS_RTC_OUTPUT(RTC_Output));
;;;1674     assert_param(IS_RTC_OUTPUT_POL(RTC_OutputPolarity));
;;;1675   
;;;1676     /* Disable the write protection for RTC registers */
;;;1677     RTC->WPR = 0xCA;
000004  22ca              MOVS     r2,#0xca
000006  601a              STR      r2,[r3,#0]
;;;1678     RTC->WPR = 0x53;
000008  2253              MOVS     r2,#0x53
00000a  601a              STR      r2,[r3,#0]
;;;1679   
;;;1680     /* Clear the bits to be configured */
;;;1681     RTC->CR &= (uint32_t)~(RTC_CR_OSEL | RTC_CR_POL);
00000c  4a06              LDR      r2,|L31.40|
00000e  3a1c              SUBS     r2,r2,#0x1c
000010  6814              LDR      r4,[r2,#0]
000012  f42404e0          BIC      r4,r4,#0x700000
000016  6014              STR      r4,[r2,#0]
;;;1682   
;;;1683     /* Configure the output selection and polarity */
;;;1684     RTC->CR |= (uint32_t)(RTC_Output | RTC_OutputPolarity);
000018  6814              LDR      r4,[r2,#0]
00001a  4308              ORRS     r0,r0,r1
00001c  4304              ORRS     r4,r4,r0
00001e  6014              STR      r4,[r2,#0]
;;;1685   
;;;1686     /* Enable the write protection for RTC registers */
;;;1687     RTC->WPR = 0xFF; 
000020  20ff              MOVS     r0,#0xff
000022  6018              STR      r0,[r3,#0]
;;;1688   }
000024  bd10              POP      {r4,pc}
;;;1689   
                          ENDP

000026  0000              DCW      0x0000
                  |L31.40|
                          DCD      0x40002824

                          AREA ||i.RTC_OutputTypeConfig||, CODE, READONLY, ALIGN=2

                  RTC_OutputTypeConfig PROC
;;;2372     */
;;;2373   void RTC_OutputTypeConfig(uint32_t RTC_OutputType)
000000  4904              LDR      r1,|L32.20|
;;;2374   {
;;;2375     /* Check the parameters */
;;;2376     assert_param(IS_RTC_OUTPUT_TYPE(RTC_OutputType));
;;;2377     
;;;2378     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_ALARMOUTTYPE);
000002  680a              LDR      r2,[r1,#0]
000004  f4222280          BIC      r2,r2,#0x40000
000008  600a              STR      r2,[r1,#0]
;;;2379     RTC->TAFCR |= (uint32_t)(RTC_OutputType);  
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2380   }
000010  4770              BX       lr
;;;2381   
                          ENDP

000012  0000              DCW      0x0000
                  |L32.20|
                          DCD      0x40002840

                          AREA ||i.RTC_ReadBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_ReadBackupRegister PROC
;;;2296     */
;;;2297   uint32_t RTC_ReadBackupRegister(uint32_t RTC_BKP_DR)
000000  b508              PUSH     {r3,lr}
;;;2298   {
;;;2299     __IO uint32_t tmp = 0;
;;;2300     
;;;2301     /* Check the parameters */
;;;2302     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2303   
;;;2304     tmp = RTC_BASE + 0x50;
000002  4903              LDR      r1,|L33.16|
;;;2305     tmp += (RTC_BKP_DR * 4);
000004  eb010080          ADD      r0,r1,r0,LSL #2
;;;2306     
;;;2307     /* Read the specified register */
;;;2308     return (*(__IO uint32_t *)tmp);
000008  9000              STR      r0,[sp,#0]
00000a  6800              LDR      r0,[r0,#0]
;;;2309   }
00000c  bd08              POP      {r3,pc}
;;;2310   
                          ENDP

00000e  0000              DCW      0x0000
                  |L33.16|
                          DCD      0x40002850

                          AREA ||i.RTC_RefClockCmd||, CODE, READONLY, ALIGN=2

                  RTC_RefClockCmd PROC
;;;649      */
;;;650    ErrorStatus RTC_RefClockCmd(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;651    { 
;;;652      ErrorStatus status = ERROR;
;;;653      
;;;654      /* Check the parameters */
;;;655      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;656      
;;;657      /* Disable the write protection for RTC registers */
;;;658      RTC->WPR = 0xCA;
000002  4d0d              LDR      r5,|L34.56|
000004  4606              MOV      r6,r0                 ;651
000006  2400              MOVS     r4,#0                 ;652
000008  20ca              MOVS     r0,#0xca
00000a  6028              STR      r0,[r5,#0]
;;;659      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6028              STR      r0,[r5,#0]
;;;660        
;;;661      /* Set Initialization mode */
;;;662      if (RTC_EnterInitMode() == ERROR)
000010  f7fffffe          BL       RTC_EnterInitMode
000014  b160              CBZ      r0,|L34.48|
;;;663      {
;;;664        status = ERROR;
;;;665      } 
;;;666      else
;;;667      {  
;;;668        if (NewState != DISABLE)
;;;669        {
;;;670          /* Enable the RTC reference clock detection */
;;;671          RTC->CR |= RTC_CR_REFCKON;   
000016  4808              LDR      r0,|L34.56|
000018  381c              SUBS     r0,r0,#0x1c
;;;672        }
;;;673        else
;;;674        {
;;;675          /* Disable the RTC reference clock detection */
;;;676          RTC->CR &= ~RTC_CR_REFCKON;    
00001a  6801              LDR      r1,[r0,#0]
00001c  b116              CBZ      r6,|L34.36|
00001e  f0410110          ORR      r1,r1,#0x10           ;671
000022  e001              B        |L34.40|
                  |L34.36|
000024  f0210110          BIC      r1,r1,#0x10
                  |L34.40|
000028  6001              STR      r1,[r0,#0]
;;;677        }
;;;678        /* Exit Initialization mode */
;;;679        RTC_ExitInitMode();
00002a  f7fffffe          BL       RTC_ExitInitMode
;;;680        
;;;681        status = SUCCESS;
00002e  2401              MOVS     r4,#1
                  |L34.48|
;;;682      }
;;;683      
;;;684      /* Enable the write protection for RTC registers */
;;;685      RTC->WPR = 0xFF;  
000030  20ff              MOVS     r0,#0xff
000032  6028              STR      r0,[r5,#0]
;;;686      
;;;687      return status; 
000034  4620              MOV      r0,r4
;;;688    }
000036  bd70              POP      {r4-r6,pc}
;;;689    
                          ENDP

                  |L34.56|
                          DCD      0x40002824

                          AREA ||i.RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarm PROC
;;;1087     */
;;;1088   void RTC_SetAlarm(uint32_t RTC_Format, uint32_t RTC_Alarm, RTC_AlarmTypeDef* RTC_AlarmStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;1089   {
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
;;;1090     uint32_t tmpreg = 0;
;;;1091     
;;;1092     /* Check the parameters */
;;;1093     assert_param(IS_RTC_FORMAT(RTC_Format));
;;;1094     assert_param(IS_RTC_ALARM(RTC_Alarm));
;;;1095     assert_param(IS_ALARM_MASK(RTC_AlarmStruct->RTC_AlarmMask));
;;;1096     assert_param(IS_RTC_ALARM_DATE_WEEKDAY_SEL(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel));
;;;1097   
;;;1098     if (RTC_Format == RTC_Format_BIN)
;;;1099     {
;;;1100       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000006  4a26              LDR      r2,|L35.160|
000008  2100              MOVS     r1,#0                 ;1089
00000a  2800              CMP      r0,#0                 ;1098
;;;1101       {
;;;1102         assert_param(IS_RTC_HOUR12(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1103         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
;;;1104       } 
;;;1105       else
;;;1106       {
;;;1107         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
;;;1108         assert_param(IS_RTC_HOUR24(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours));
;;;1109       }
;;;1110       assert_param(IS_RTC_MINUTES(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes));
;;;1111       assert_param(IS_RTC_SECONDS(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds));
;;;1112       
;;;1113       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
;;;1114       {
;;;1115         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1116       }
;;;1117       else
;;;1118       {
;;;1119         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(RTC_AlarmStruct->RTC_AlarmDateWeekDay));
;;;1120       }
;;;1121     }
;;;1122     else
;;;1123     {
;;;1124       if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
00000c  6810              LDR      r0,[r2,#0]
00000e  ea4f6040          LSL      r0,r0,#25
000012  d005              BEQ      |L35.32|
000014  2800              CMP      r0,#0
000016  da1c              BGE      |L35.82|
;;;1125       {
;;;1126         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours);
000018  7820              LDRB     r0,[r4,#0]
00001a  f7fffffe          BL       RTC_Bcd2ToByte
;;;1127         assert_param(IS_RTC_HOUR12(tmpreg));
;;;1128         assert_param(IS_RTC_H12(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12));
00001e  e019              B        |L35.84|
                  |L35.32|
000020  2800              CMP      r0,#0                 ;1100
000022  db00              BLT      |L35.38|
000024  70e1              STRB     r1,[r4,#3]            ;1107
                  |L35.38|
;;;1129       } 
;;;1130       else
;;;1131       {
;;;1132         RTC_AlarmStruct->RTC_AlarmTime.RTC_H12 = 0x00;
;;;1133         assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours)));
;;;1134       }
;;;1135       
;;;1136       assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes)));
;;;1137       assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)));
;;;1138       
;;;1139       if(RTC_AlarmStruct->RTC_AlarmDateWeekDaySel == RTC_AlarmDateWeekDaySel_Date)
;;;1140       {
;;;1141         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1142         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_DATE(tmpreg));    
;;;1143       }
;;;1144       else
;;;1145       {
;;;1146         tmpreg = RTC_Bcd2ToByte(RTC_AlarmStruct->RTC_AlarmDateWeekDay);
;;;1147         assert_param(IS_RTC_ALARM_DATE_WEEKDAY_WEEKDAY(tmpreg));      
;;;1148       }    
;;;1149     }
;;;1150   
;;;1151     /* Check the input parameters format */
;;;1152     if (RTC_Format != RTC_Format_BIN)
;;;1153     {
;;;1154       tmpreg = (((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
;;;1155                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1156                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds) | \
;;;1157                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1158                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1159                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1160                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1161     }  
;;;1162     else
;;;1163     {
;;;1164       tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Hours) << 16) | \
000026  7820              LDRB     r0,[r4,#0]
000028  f7fffffe          BL       RTC_ByteToBcd2
00002c  0406              LSLS     r6,r0,#16
00002e  7860              LDRB     r0,[r4,#1]
000030  f7fffffe          BL       RTC_ByteToBcd2
000034  ea462600          ORR      r6,r6,r0,LSL #8
000038  78a0              LDRB     r0,[r4,#2]
00003a  f7fffffe          BL       RTC_ByteToBcd2
00003e  4306              ORRS     r6,r6,r0
000040  78e0              LDRB     r0,[r4,#3]
000042  ea464600          ORR      r6,r6,r0,LSL #16
000046  7b20              LDRB     r0,[r4,#0xc]
000048  f7fffffe          BL       RTC_ByteToBcd2
00004c  ea466000          ORR      r0,r6,r0,LSL #24
000050  e010              B        |L35.116|
                  |L35.82|
000052  70e1              STRB     r1,[r4,#3]            ;1132
                  |L35.84|
000054  7b20              LDRB     r0,[r4,#0xc]          ;1141
000056  f7fffffe          BL       RTC_Bcd2ToByte
00005a  78a0              LDRB     r0,[r4,#2]            ;1154
00005c  7821              LDRB     r1,[r4,#0]            ;1154
00005e  78e2              LDRB     r2,[r4,#3]            ;1154
000060  ea404001          ORR      r0,r0,r1,LSL #16      ;1154
000064  7861              LDRB     r1,[r4,#1]            ;1154
000066  0209              LSLS     r1,r1,#8              ;1154
000068  ea414102          ORR      r1,r1,r2,LSL #16      ;1154
00006c  4308              ORRS     r0,r0,r1              ;1154
00006e  7b21              LDRB     r1,[r4,#0xc]          ;1154
000070  ea406001          ORR      r0,r0,r1,LSL #24      ;1154
                  |L35.116|
000074  68a1              LDR      r1,[r4,#8]
;;;1165                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Minutes) << 8) | \
;;;1166                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmTime.RTC_Seconds)) | \
;;;1167                 ((uint32_t)(RTC_AlarmStruct->RTC_AlarmTime.RTC_H12) << 16) | \
;;;1168                 ((uint32_t)RTC_ByteToBcd2(RTC_AlarmStruct->RTC_AlarmDateWeekDay) << 24) | \
;;;1169                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmDateWeekDaySel) | \
;;;1170                 ((uint32_t)RTC_AlarmStruct->RTC_AlarmMask)); 
;;;1171     } 
;;;1172   
;;;1173     /* Disable the write protection for RTC registers */
;;;1174     RTC->WPR = 0xCA;
000076  22ca              MOVS     r2,#0xca
000078  4308              ORRS     r0,r0,r1              ;1164
00007a  6861              LDR      r1,[r4,#4]            ;1164
00007c  4308              ORRS     r0,r0,r1              ;1164
00007e  4908              LDR      r1,|L35.160|
000080  311c              ADDS     r1,r1,#0x1c
000082  600a              STR      r2,[r1,#0]
;;;1175     RTC->WPR = 0x53;
000084  2253              MOVS     r2,#0x53
000086  600a              STR      r2,[r1,#0]
;;;1176   
;;;1177     /* Configure the Alarm register */
;;;1178     if (RTC_Alarm == RTC_Alarm_A)
000088  f5b57f80          CMP      r5,#0x100
00008c  d004              BEQ      |L35.152|
;;;1179     {
;;;1180       RTC->ALRMAR = (uint32_t)tmpreg;
;;;1181     }
;;;1182     else
;;;1183     {
;;;1184       RTC->ALRMBR = (uint32_t)tmpreg;
00008e  1f0a              SUBS     r2,r1,#4
                  |L35.144|
000090  6010              STR      r0,[r2,#0]
;;;1185     }
;;;1186   
;;;1187     /* Enable the write protection for RTC registers */
;;;1188     RTC->WPR = 0xFF;   
000092  20ff              MOVS     r0,#0xff
000094  6008              STR      r0,[r1,#0]
;;;1189   }
000096  bd70              POP      {r4-r6,pc}
                  |L35.152|
000098  4a01              LDR      r2,|L35.160|
00009a  3214              ADDS     r2,r2,#0x14           ;1180
00009c  e7f8              B        |L35.144|
;;;1190   
                          ENDP

00009e  0000              DCW      0x0000
                  |L35.160|
                          DCD      0x40002808

                          AREA ||i.RTC_SetDate||, CODE, READONLY, ALIGN=2

                  RTC_SetDate PROC
;;;925      */
;;;926    ErrorStatus RTC_SetDate(uint32_t RTC_Format, RTC_DateTypeDef* RTC_DateStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;927    {
000002  460c              MOV      r4,r1
;;;928      uint32_t tmpreg = 0;
;;;929      ErrorStatus status = ERROR;
000004  2600              MOVS     r6,#0
;;;930      
;;;931      /* Check the parameters */
;;;932      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;933    
;;;934      if ((RTC_Format == RTC_Format_BIN) && ((RTC_DateStruct->RTC_Month & 0x10) == 0x10))
000006  0001              MOVS     r1,r0
000008  7860              LDRB     r0,[r4,#1]
00000a  d010              BEQ      |L36.46|
;;;935      {
;;;936        RTC_DateStruct->RTC_Month = (RTC_DateStruct->RTC_Month & (uint32_t)~(0x10)) + 0x0A;
;;;937      }  
;;;938      if (RTC_Format == RTC_Format_BIN)
;;;939      {
;;;940        assert_param(IS_RTC_YEAR(RTC_DateStruct->RTC_Year));
;;;941        assert_param(IS_RTC_MONTH(RTC_DateStruct->RTC_Month));
;;;942        assert_param(IS_RTC_DATE(RTC_DateStruct->RTC_Date));
;;;943      }
;;;944      else
;;;945      {
;;;946        assert_param(IS_RTC_YEAR(RTC_Bcd2ToByte(RTC_DateStruct->RTC_Year)));
;;;947        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Month);
00000c  f7fffffe          BL       RTC_Bcd2ToByte
;;;948        assert_param(IS_RTC_MONTH(tmpreg));
;;;949        tmpreg = RTC_Bcd2ToByte(RTC_DateStruct->RTC_Date);
000010  78a0              LDRB     r0,[r4,#2]
000012  f7fffffe          BL       RTC_Bcd2ToByte
;;;950        assert_param(IS_RTC_DATE(tmpreg));
;;;951      }
;;;952      assert_param(IS_RTC_WEEKDAY(RTC_DateStruct->RTC_WeekDay));
;;;953    
;;;954      /* Check the input parameters format */
;;;955      if (RTC_Format != RTC_Format_BIN)
;;;956      {
;;;957        tmpreg = ((((uint32_t)RTC_DateStruct->RTC_Year) << 16) | \
000016  78a0              LDRB     r0,[r4,#2]
000018  78e1              LDRB     r1,[r4,#3]
00001a  ea404501          ORR      r5,r0,r1,LSL #16
00001e  7860              LDRB     r0,[r4,#1]
000020  7821              LDRB     r1,[r4,#0]
000022  ea4f2000          LSL      r0,r0,#8
000026  ea403041          ORR      r0,r0,r1,LSL #13
00002a  4305              ORRS     r5,r5,r0
00002c  e015              B        |L36.90|
                  |L36.46|
00002e  06c1              LSLS     r1,r0,#27             ;934
000030  d503              BPL      |L36.58|
000032  f0200010          BIC      r0,r0,#0x10           ;936
000036  300a              ADDS     r0,r0,#0xa            ;936
000038  7060              STRB     r0,[r4,#1]            ;936
                  |L36.58|
;;;958                  (((uint32_t)RTC_DateStruct->RTC_Month) << 8) | \
;;;959                  ((uint32_t)RTC_DateStruct->RTC_Date) | \
;;;960                  (((uint32_t)RTC_DateStruct->RTC_WeekDay) << 13)); 
;;;961      }  
;;;962      else
;;;963      {
;;;964        tmpreg = (((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Year) << 16) | \
00003a  78e0              LDRB     r0,[r4,#3]
00003c  f7fffffe          BL       RTC_ByteToBcd2
000040  0405              LSLS     r5,r0,#16
000042  7860              LDRB     r0,[r4,#1]
000044  f7fffffe          BL       RTC_ByteToBcd2
000048  ea452500          ORR      r5,r5,r0,LSL #8
00004c  78a0              LDRB     r0,[r4,#2]
00004e  f7fffffe          BL       RTC_ByteToBcd2
000052  4305              ORRS     r5,r5,r0
000054  7820              LDRB     r0,[r4,#0]
000056  ea453540          ORR      r5,r5,r0,LSL #13
                  |L36.90|
;;;965                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Month) << 8) | \
;;;966                  ((uint32_t)RTC_ByteToBcd2(RTC_DateStruct->RTC_Date)) | \
;;;967                  ((uint32_t)RTC_DateStruct->RTC_WeekDay << 13));
;;;968      }
;;;969    
;;;970      /* Disable the write protection for RTC registers */
;;;971      RTC->WPR = 0xCA;
00005a  4c0b              LDR      r4,|L36.136|
00005c  20ca              MOVS     r0,#0xca
00005e  6020              STR      r0,[r4,#0]
;;;972      RTC->WPR = 0x53;
000060  2053              MOVS     r0,#0x53
000062  6020              STR      r0,[r4,#0]
;;;973    
;;;974      /* Set Initialization mode */
;;;975      if (RTC_EnterInitMode() == ERROR)
000064  f7fffffe          BL       RTC_EnterInitMode
000068  b150              CBZ      r0,|L36.128|
;;;976      {
;;;977        status = ERROR;
;;;978      } 
;;;979      else
;;;980      {
;;;981        /* Set the RTC_DR register */
;;;982        RTC->DR = (uint32_t)(tmpreg & RTC_DR_RESERVED_MASK);
00006a  4808              LDR      r0,|L36.140|
00006c  4005              ANDS     r5,r5,r0
00006e  4806              LDR      r0,|L36.136|
000070  3820              SUBS     r0,r0,#0x20
000072  6005              STR      r5,[r0,#0]
;;;983    
;;;984        /* Exit Initialization mode */
;;;985        RTC_ExitInitMode(); 
000074  f7fffffe          BL       RTC_ExitInitMode
;;;986    
;;;987        if(RTC_WaitForSynchro() == ERROR)
000078  f7fffffe          BL       RTC_WaitForSynchro
00007c  b100              CBZ      r0,|L36.128|
;;;988        {
;;;989          status = ERROR;
;;;990        }
;;;991        else
;;;992        {
;;;993          status = SUCCESS;
00007e  2601              MOVS     r6,#1
                  |L36.128|
;;;994        }
;;;995      }
;;;996      /* Enable the write protection for RTC registers */
;;;997      RTC->WPR = 0xFF;   
000080  20ff              MOVS     r0,#0xff
000082  6020              STR      r0,[r4,#0]
;;;998      
;;;999      return status;
000084  4630              MOV      r0,r6
;;;1000   }
000086  bd70              POP      {r4-r6,pc}
;;;1001   
                          ENDP

                  |L36.136|
                          DCD      0x40002824
                  |L36.140|
                          DCD      0x00ffff3f

                          AREA ||i.RTC_SetTime||, CODE, READONLY, ALIGN=2

                  RTC_SetTime PROC
;;;752      */
;;;753    ErrorStatus RTC_SetTime(uint32_t RTC_Format, RTC_TimeTypeDef* RTC_TimeStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;754    {
000002  460c              MOV      r4,r1
;;;755      uint32_t tmpreg = 0;
;;;756      ErrorStatus status = ERROR;
000004  2600              MOVS     r6,#0
;;;757        
;;;758      /* Check the parameters */
;;;759      assert_param(IS_RTC_FORMAT(RTC_Format));
;;;760      
;;;761      if (RTC_Format == RTC_Format_BIN)
;;;762      {
;;;763        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
000006  4b21              LDR      r3,|L37.140|
000008  0001              MOVS     r1,r0                 ;761
;;;764        {
;;;765          assert_param(IS_RTC_HOUR12(RTC_TimeStruct->RTC_Hours));
;;;766          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12));
;;;767        } 
;;;768        else
;;;769        {
;;;770          RTC_TimeStruct->RTC_H12 = 0x00;
;;;771          assert_param(IS_RTC_HOUR24(RTC_TimeStruct->RTC_Hours));
;;;772        }
;;;773        assert_param(IS_RTC_MINUTES(RTC_TimeStruct->RTC_Minutes));
;;;774        assert_param(IS_RTC_SECONDS(RTC_TimeStruct->RTC_Seconds));
;;;775      }
;;;776      else
;;;777      {
;;;778        if ((RTC->CR & RTC_CR_FMT) != (uint32_t)RESET)
;;;779        {
;;;780          tmpreg = RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours);
00000a  7820              LDRB     r0,[r4,#0]
00000c  6819              LDR      r1,[r3,#0]            ;778
00000e  4632              MOV      r2,r6                 ;761
000010  ea4f6141          LSL      r1,r1,#25             ;778
000014  d004              BEQ      |L37.32|
000016  2900              CMP      r1,#0                 ;778
000018  da2c              BGE      |L37.116|
00001a  f7fffffe          BL       RTC_Bcd2ToByte
;;;781          assert_param(IS_RTC_HOUR12(tmpreg));
;;;782          assert_param(IS_RTC_H12(RTC_TimeStruct->RTC_H12)); 
00001e  e02a              B        |L37.118|
                  |L37.32|
000020  2900              CMP      r1,#0                 ;763
000022  db00              BLT      |L37.38|
000024  70e2              STRB     r2,[r4,#3]            ;770
                  |L37.38|
;;;783        } 
;;;784        else
;;;785        {
;;;786          RTC_TimeStruct->RTC_H12 = 0x00;
;;;787          assert_param(IS_RTC_HOUR24(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Hours)));
;;;788        }
;;;789        assert_param(IS_RTC_MINUTES(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Minutes)));
;;;790        assert_param(IS_RTC_SECONDS(RTC_Bcd2ToByte(RTC_TimeStruct->RTC_Seconds)));
;;;791      }
;;;792      
;;;793      /* Check the input parameters format */
;;;794      if (RTC_Format != RTC_Format_BIN)
;;;795      {
;;;796        tmpreg = (((uint32_t)(RTC_TimeStruct->RTC_Hours) << 16) | \
;;;797                 ((uint32_t)(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;798                 ((uint32_t)RTC_TimeStruct->RTC_Seconds) | \
;;;799                 ((uint32_t)(RTC_TimeStruct->RTC_H12) << 16)); 
;;;800      }  
;;;801      else
;;;802      {
;;;803        tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Hours) << 16) | \
000026  f7fffffe          BL       RTC_ByteToBcd2
00002a  0405              LSLS     r5,r0,#16
00002c  7860              LDRB     r0,[r4,#1]
00002e  f7fffffe          BL       RTC_ByteToBcd2
000032  ea452500          ORR      r5,r5,r0,LSL #8
000036  78a0              LDRB     r0,[r4,#2]
000038  f7fffffe          BL       RTC_ByteToBcd2
00003c  4305              ORRS     r5,r5,r0
00003e  78e0              LDRB     r0,[r4,#3]
000040  ea454500          ORR      r5,r5,r0,LSL #16
                  |L37.68|
;;;804                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Minutes) << 8) | \
;;;805                       ((uint32_t)RTC_ByteToBcd2(RTC_TimeStruct->RTC_Seconds)) | \
;;;806                       (((uint32_t)RTC_TimeStruct->RTC_H12) << 16));
;;;807      }  
;;;808    
;;;809      /* Disable the write protection for RTC registers */
;;;810      RTC->WPR = 0xCA;
000044  4c11              LDR      r4,|L37.140|
000046  20ca              MOVS     r0,#0xca
000048  341c              ADDS     r4,r4,#0x1c
00004a  6020              STR      r0,[r4,#0]
;;;811      RTC->WPR = 0x53;
00004c  2053              MOVS     r0,#0x53
00004e  6020              STR      r0,[r4,#0]
;;;812    
;;;813      /* Set Initialization mode */
;;;814      if (RTC_EnterInitMode() == ERROR)
000050  f7fffffe          BL       RTC_EnterInitMode
000054  b150              CBZ      r0,|L37.108|
;;;815      {
;;;816        status = ERROR;
;;;817      } 
;;;818      else
;;;819      {
;;;820        /* Set the RTC_TR register */
;;;821        RTC->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
000056  480e              LDR      r0,|L37.144|
000058  4005              ANDS     r5,r5,r0
00005a  480c              LDR      r0,|L37.140|
00005c  3808              SUBS     r0,r0,#8
00005e  6005              STR      r5,[r0,#0]
;;;822    
;;;823        /* Exit Initialization mode */
;;;824        RTC_ExitInitMode(); 
000060  f7fffffe          BL       RTC_ExitInitMode
;;;825    
;;;826        if(RTC_WaitForSynchro() == ERROR)
000064  f7fffffe          BL       RTC_WaitForSynchro
000068  b100              CBZ      r0,|L37.108|
;;;827        {
;;;828          status = ERROR;
;;;829        }
;;;830        else
;;;831        {
;;;832          status = SUCCESS;
00006a  2601              MOVS     r6,#1
                  |L37.108|
;;;833        }
;;;834      
;;;835      }
;;;836      /* Enable the write protection for RTC registers */
;;;837      RTC->WPR = 0xFF; 
00006c  20ff              MOVS     r0,#0xff
00006e  6020              STR      r0,[r4,#0]
;;;838        
;;;839      return status;
000070  4630              MOV      r0,r6
;;;840    }
000072  bd70              POP      {r4-r6,pc}
                  |L37.116|
000074  70e2              STRB     r2,[r4,#3]            ;786
                  |L37.118|
000076  78a0              LDRB     r0,[r4,#2]            ;796
000078  7821              LDRB     r1,[r4,#0]            ;796
00007a  ea404501          ORR      r5,r0,r1,LSL #16      ;796
00007e  7860              LDRB     r0,[r4,#1]            ;796
000080  78e1              LDRB     r1,[r4,#3]            ;796
000082  0200              LSLS     r0,r0,#8              ;796
000084  ea404001          ORR      r0,r0,r1,LSL #16      ;796
000088  4305              ORRS     r5,r5,r0              ;796
00008a  e7db              B        |L37.68|
;;;841    
                          ENDP

                  |L37.140|
                          DCD      0x40002808
                  |L37.144|
                          DCD      0x007f7f7f

                          AREA ||i.RTC_SetWakeUpCounter||, CODE, READONLY, ALIGN=2

                  RTC_SetWakeUpCounter PROC
;;;1493     */
;;;1494   void RTC_SetWakeUpCounter(uint32_t RTC_WakeUpCounter)
000000  4905              LDR      r1,|L38.24|
;;;1495   {
;;;1496     /* Check the parameters */
;;;1497     assert_param(IS_RTC_WAKEUP_COUNTER(RTC_WakeUpCounter));
;;;1498     
;;;1499     /* Disable the write protection for RTC registers */
;;;1500     RTC->WPR = 0xCA;
000002  22ca              MOVS     r2,#0xca
000004  600a              STR      r2,[r1,#0]
;;;1501     RTC->WPR = 0x53;
000006  2253              MOVS     r2,#0x53
000008  600a              STR      r2,[r1,#0]
;;;1502     
;;;1503     /* Configure the Wakeup Timer counter */
;;;1504     RTC->WUTR = (uint32_t)RTC_WakeUpCounter;
00000a  4a03              LDR      r2,|L38.24|
00000c  3a10              SUBS     r2,r2,#0x10
00000e  6010              STR      r0,[r2,#0]
;;;1505     
;;;1506     /* Enable the write protection for RTC registers */
;;;1507     RTC->WPR = 0xFF; 
000010  20ff              MOVS     r0,#0xff
000012  6008              STR      r0,[r1,#0]
;;;1508   }
000014  4770              BX       lr
;;;1509   
                          ENDP

000016  0000              DCW      0x0000
                  |L38.24|
                          DCD      0x40002824

                          AREA ||i.RTC_SmoothCalibConfig||, CODE, READONLY, ALIGN=2

                  RTC_SmoothCalibConfig PROC
;;;1878   */
;;;1879   ErrorStatus RTC_SmoothCalibConfig(uint32_t RTC_SmoothCalibPeriod,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1880                                     uint32_t RTC_SmoothCalibPlusPulses,
;;;1881                                     uint32_t RTC_SmouthCalibMinusPulsesValue)
;;;1882   {
;;;1883     ErrorStatus status = ERROR;
;;;1884     uint32_t recalpfcount = 0;
;;;1885   
;;;1886     /* Check the parameters */
;;;1887     assert_param(IS_RTC_SMOOTH_CALIB_PERIOD(RTC_SmoothCalibPeriod));
;;;1888     assert_param(IS_RTC_SMOOTH_CALIB_PLUS(RTC_SmoothCalibPlusPulses));
;;;1889     assert_param(IS_RTC_SMOOTH_CALIB_MINUS(RTC_SmouthCalibMinusPulsesValue));
;;;1890   
;;;1891     /* Disable the write protection for RTC registers */
;;;1892     RTC->WPR = 0xCA;
000002  4d11              LDR      r5,|L39.72|
000004  2300              MOVS     r3,#0                 ;1884
000006  24ca              MOVS     r4,#0xca
000008  602c              STR      r4,[r5,#0]
;;;1893     RTC->WPR = 0x53;
00000a  2453              MOVS     r4,#0x53
00000c  602c              STR      r4,[r5,#0]
;;;1894     
;;;1895     /* check if a calibration is pending*/
;;;1896     if ((RTC->ISR & RTC_ISR_RECALPF) != RESET)
00000e  4c0e              LDR      r4,|L39.72|
000010  3c18              SUBS     r4,r4,#0x18
000012  6826              LDR      r6,[r4,#0]
000014  03f6              LSLS     r6,r6,#15
000016  d509              BPL      |L39.44|
;;;1897     {
;;;1898       /* wait until the Calibration is completed*/
;;;1899       while (((RTC->ISR & RTC_ISR_RECALPF) != RESET) && (recalpfcount != RECALPF_TIMEOUT))
000018  f44f3600          MOV      r6,#0x20000
                  |L39.28|
00001c  6827              LDR      r7,[r4,#0]
00001e  03ff              LSLS     r7,r7,#15
000020  d504              BPL      |L39.44|
000022  42b3              CMP      r3,r6
000024  d002              BEQ      |L39.44|
;;;1900       {
;;;1901         recalpfcount++;
000026  f1030301          ADD      r3,r3,#1
00002a  e7f7              B        |L39.28|
                  |L39.44|
;;;1902       }
;;;1903     }
;;;1904   
;;;1905     /* check if the calibration pending is completed or if there is no calibration operation at all*/
;;;1906     if ((RTC->ISR & RTC_ISR_RECALPF) == RESET)
00002c  6823              LDR      r3,[r4,#0]
00002e  03db              LSLS     r3,r3,#15
000030  d406              BMI      |L39.64|
;;;1907     {
;;;1908       /* Configure the Smooth calibration settings */
;;;1909       RTC->CALR = (uint32_t)((uint32_t)RTC_SmoothCalibPeriod | (uint32_t)RTC_SmoothCalibPlusPulses | (uint32_t)RTC_SmouthCalibMinusPulsesValue);
000032  4308              ORRS     r0,r0,r1
000034  4904              LDR      r1,|L39.72|
000036  4310              ORRS     r0,r0,r2
000038  3118              ADDS     r1,r1,#0x18
00003a  6008              STR      r0,[r1,#0]
;;;1910   
;;;1911       status = SUCCESS;
00003c  2001              MOVS     r0,#1
00003e  e000              B        |L39.66|
                  |L39.64|
;;;1912     }
;;;1913     else
;;;1914     {
;;;1915       status = ERROR;
000040  2000              MOVS     r0,#0
                  |L39.66|
;;;1916     }
;;;1917   
;;;1918     /* Enable the write protection for RTC registers */
;;;1919     RTC->WPR = 0xFF;
000042  21ff              MOVS     r1,#0xff
000044  6029              STR      r1,[r5,#0]
;;;1920     
;;;1921     return (ErrorStatus)(status);
;;;1922   }
000046  bdf0              POP      {r4-r7,pc}
;;;1923   
                          ENDP

                  |L39.72|
                          DCD      0x40002824

                          AREA ||i.RTC_StructInit||, CODE, READONLY, ALIGN=1

                  RTC_StructInit PROC
;;;490      */
;;;491    void RTC_StructInit(RTC_InitTypeDef* RTC_InitStruct)
000000  2100              MOVS     r1,#0
;;;492    {
;;;493      /* Initialize the RTC_HourFormat member */
;;;494      RTC_InitStruct->RTC_HourFormat = RTC_HourFormat_24;
;;;495        
;;;496      /* Initialize the RTC_AsynchPrediv member */
;;;497      RTC_InitStruct->RTC_AsynchPrediv = (uint32_t)0x7F;
000002  6001              STR      r1,[r0,#0]
000004  217f              MOVS     r1,#0x7f
;;;498    
;;;499      /* Initialize the RTC_SynchPrediv member */
;;;500      RTC_InitStruct->RTC_SynchPrediv = (uint32_t)0xFF; 
000006  6041              STR      r1,[r0,#4]
000008  21ff              MOVS     r1,#0xff
00000a  6081              STR      r1,[r0,#8]
;;;501    }
00000c  4770              BX       lr
;;;502    
                          ENDP


                          AREA ||i.RTC_SynchroShiftConfig||, CODE, READONLY, ALIGN=2

                  RTC_SynchroShiftConfig PROC
;;;2410   */
;;;2411   ErrorStatus RTC_SynchroShiftConfig(uint32_t RTC_ShiftAdd1S, uint32_t RTC_ShiftSubFS)
000000  b570              PUSH     {r4-r6,lr}
;;;2412   {
;;;2413     ErrorStatus status = ERROR;
;;;2414     uint32_t shpfcount = 0;
;;;2415   
;;;2416     /* Check the parameters */
;;;2417     assert_param(IS_RTC_SHIFT_ADD1S(RTC_ShiftAdd1S));
;;;2418     assert_param(IS_RTC_SHIFT_SUBFS(RTC_ShiftSubFS));
;;;2419   
;;;2420     /* Disable the write protection for RTC registers */
;;;2421     RTC->WPR = 0xCA;
000002  4c14              LDR      r4,|L41.84|
000004  2200              MOVS     r2,#0                 ;2414
000006  23ca              MOVS     r3,#0xca
000008  6023              STR      r3,[r4,#0]
;;;2422     RTC->WPR = 0x53;
00000a  2353              MOVS     r3,#0x53
00000c  6023              STR      r3,[r4,#0]
;;;2423     
;;;2424     /* Check if a Shift is pending*/
;;;2425     if ((RTC->ISR & RTC_ISR_SHPF) != RESET)
00000e  4b11              LDR      r3,|L41.84|
000010  3b18              SUBS     r3,r3,#0x18
000012  681d              LDR      r5,[r3,#0]
000014  072d              LSLS     r5,r5,#28
000016  d508              BPL      |L41.42|
;;;2426     {
;;;2427       /* Wait until the shift is completed*/
;;;2428       while (((RTC->ISR & RTC_ISR_SHPF) != RESET) && (shpfcount != SHPF_TIMEOUT))
000018  149e              ASRS     r6,r3,#18
                  |L41.26|
00001a  681d              LDR      r5,[r3,#0]
00001c  072d              LSLS     r5,r5,#28
00001e  d504              BPL      |L41.42|
000020  42b2              CMP      r2,r6
000022  d002              BEQ      |L41.42|
;;;2429       {
;;;2430         shpfcount++;
000024  f1020201          ADD      r2,r2,#1
000028  e7f7              B        |L41.26|
                  |L41.42|
;;;2431       }
;;;2432     }
;;;2433   
;;;2434     /* Check if the Shift pending is completed or if there is no Shift operation at all*/
;;;2435     if ((RTC->ISR & RTC_ISR_SHPF) == RESET)
00002a  681a              LDR      r2,[r3,#0]
00002c  0712              LSLS     r2,r2,#28
00002e  d40d              BMI      |L41.76|
;;;2436     {
;;;2437       /* check if the reference clock detection is disabled */
;;;2438       if((RTC->CR & RTC_CR_REFCKON) == RESET)
000030  4a08              LDR      r2,|L41.84|
000032  3a1c              SUBS     r2,r2,#0x1c
000034  6812              LDR      r2,[r2,#0]
000036  06d2              LSLS     r2,r2,#27
000038  d408              BMI      |L41.76|
;;;2439       {
;;;2440         /* Configure the Shift settings */
;;;2441         RTC->SHIFTR = (uint32_t)(uint32_t)(RTC_ShiftSubFS) | (uint32_t)(RTC_ShiftAdd1S);
00003a  4301              ORRS     r1,r1,r0
00003c  4805              LDR      r0,|L41.84|
00003e  3008              ADDS     r0,r0,#8
000040  6001              STR      r1,[r0,#0]
;;;2442       
;;;2443         if(RTC_WaitForSynchro() == ERROR)
000042  f7fffffe          BL       RTC_WaitForSynchro
000046  b110              CBZ      r0,|L41.78|
;;;2444         {
;;;2445           status = ERROR;
;;;2446         }
;;;2447         else
;;;2448         {
;;;2449           status = SUCCESS;
000048  2001              MOVS     r0,#1
00004a  e000              B        |L41.78|
                  |L41.76|
;;;2450         }
;;;2451       }
;;;2452       else
;;;2453       {
;;;2454         status = ERROR;
00004c  2000              MOVS     r0,#0
                  |L41.78|
;;;2455       }
;;;2456     }
;;;2457     else
;;;2458     {
;;;2459       status = ERROR;
;;;2460     }
;;;2461   
;;;2462     /* Enable the write protection for RTC registers */
;;;2463     RTC->WPR = 0xFF;
00004e  21ff              MOVS     r1,#0xff
000050  6021              STR      r1,[r4,#0]
;;;2464     
;;;2465     return (ErrorStatus)(status);
;;;2466   }
000052  bd70              POP      {r4-r6,pc}
;;;2467   
                          ENDP

                  |L41.84|
                          DCD      0x40002824

                          AREA ||i.RTC_TamperCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperCmd PROC
;;;2103     */
;;;2104   void RTC_TamperCmd(uint32_t RTC_Tamper, FunctionalState NewState)
000000  4a04              LDR      r2,|L42.20|
;;;2105   {
;;;2106     /* Check the parameters */
;;;2107     assert_param(IS_RTC_TAMPER(RTC_Tamper));  
;;;2108     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2109     
;;;2110     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;2111     {
;;;2112       /* Enable the selected Tamper pin */
;;;2113       RTC->TAFCR |= (uint32_t)RTC_Tamper;
;;;2114     }
;;;2115     else
;;;2116     {
;;;2117       /* Disable the selected Tamper pin */
;;;2118       RTC->TAFCR &= (uint32_t)~RTC_Tamper;    
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L42.12|
000008  4301              ORRS     r1,r1,r0              ;2113
00000a  e000              B        |L42.14|
                  |L42.12|
00000c  4381              BICS     r1,r1,r0
                  |L42.14|
00000e  6011              STR      r1,[r2,#0]            ;2113
;;;2119     }  
;;;2120   }
000010  4770              BX       lr
;;;2121   
                          ENDP

000012  0000              DCW      0x0000
                  |L42.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperFilterConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperFilterConfig PROC
;;;2134     */
;;;2135   void RTC_TamperFilterConfig(uint32_t RTC_TamperFilter)
000000  4904              LDR      r1,|L43.20|
;;;2136   {
;;;2137     /* Check the parameters */
;;;2138     assert_param(IS_RTC_TAMPER_FILTER(RTC_TamperFilter));
;;;2139      
;;;2140     /* Clear TAMPFLT[1:0] bits in the RTC_TAFCR register */
;;;2141     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFLT);
000002  680a              LDR      r2,[r1,#0]
000004  f42252c0          BIC      r2,r2,#0x1800
000008  600a              STR      r2,[r1,#0]
;;;2142   
;;;2143     /* Configure the RTC_TAFCR register */
;;;2144     RTC->TAFCR |= (uint32_t)RTC_TamperFilter;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2145   }
000010  4770              BX       lr
;;;2146   
                          ENDP

000012  0000              DCW      0x0000
                  |L43.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPinSelection||, CODE, READONLY, ALIGN=2

                  RTC_TamperPinSelection PROC
;;;2336     */
;;;2337   void RTC_TamperPinSelection(uint32_t RTC_TamperPin)
000000  4904              LDR      r1,|L44.20|
;;;2338   {
;;;2339     /* Check the parameters */
;;;2340     assert_param(IS_RTC_TAMPER_PIN(RTC_TamperPin));
;;;2341     
;;;2342     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPINSEL);
000002  680a              LDR      r2,[r1,#0]
000004  f4223280          BIC      r2,r2,#0x10000
000008  600a              STR      r2,[r1,#0]
;;;2343     RTC->TAFCR |= (uint32_t)(RTC_TamperPin);  
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2344   }
000010  4770              BX       lr
;;;2345   
                          ENDP

000012  0000              DCW      0x0000
                  |L44.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPinsPrechargeDuration||, CODE, READONLY, ALIGN=2

                  RTC_TamperPinsPrechargeDuration PROC
;;;2191     */
;;;2192   void RTC_TamperPinsPrechargeDuration(uint32_t RTC_TamperPrechargeDuration)
000000  4904              LDR      r1,|L45.20|
;;;2193   {
;;;2194     /* Check the parameters */
;;;2195     assert_param(IS_RTC_TAMPER_PRECHARGE_DURATION(RTC_TamperPrechargeDuration));
;;;2196      
;;;2197     /* Clear TAMPPRCH[1:0] bits in the RTC_TAFCR register */
;;;2198     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPPRCH);
000002  680a              LDR      r2,[r1,#0]
000004  f42242c0          BIC      r2,r2,#0x6000
000008  600a              STR      r2,[r1,#0]
;;;2199   
;;;2200     /* Configure the RTC_TAFCR register */
;;;2201     RTC->TAFCR |= (uint32_t)RTC_TamperPrechargeDuration;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2202   }
000010  4770              BX       lr
;;;2203   
                          ENDP

000012  0000              DCW      0x0000
                  |L45.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperPullUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_TamperPullUpCmd PROC
;;;2234     */
;;;2235   void RTC_TamperPullUpCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L46.24|
;;;2236   {
;;;2237     /* Check the parameters */
;;;2238     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2239     
;;;2240    if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;2241     {
;;;2242       /* Enable precharge of the selected Tamper pin */
;;;2243       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPPUDIS; 
;;;2244     }
;;;2245     else
;;;2246     {
;;;2247       /* Disable precharge of the selected Tamper pin */
;;;2248       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPPUDIS;    
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L46.14|
000008  f4204000          BIC      r0,r0,#0x8000         ;2243
00000c  e001              B        |L46.18|
                  |L46.14|
00000e  f4404000          ORR      r0,r0,#0x8000
                  |L46.18|
000012  6008              STR      r0,[r1,#0]            ;2243
;;;2249     } 
;;;2250   }
000014  4770              BX       lr
;;;2251   
                          ENDP

000016  0000              DCW      0x0000
                  |L46.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperSamplingFreqConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperSamplingFreqConfig PROC
;;;2168     */
;;;2169   void RTC_TamperSamplingFreqConfig(uint32_t RTC_TamperSamplingFreq)
000000  4904              LDR      r1,|L47.20|
;;;2170   {
;;;2171     /* Check the parameters */
;;;2172     assert_param(IS_RTC_TAMPER_SAMPLING_FREQ(RTC_TamperSamplingFreq));
;;;2173    
;;;2174     /* Clear TAMPFREQ[2:0] bits in the RTC_TAFCR register */
;;;2175     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TAMPFREQ);
000002  680a              LDR      r2,[r1,#0]
000004  f42262e0          BIC      r2,r2,#0x700
000008  600a              STR      r2,[r1,#0]
;;;2176   
;;;2177     /* Configure the RTC_TAFCR register */
;;;2178     RTC->TAFCR |= (uint32_t)RTC_TamperSamplingFreq;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2179   }
000010  4770              BX       lr
;;;2180   
                          ENDP

000012  0000              DCW      0x0000
                  |L47.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TamperTriggerConfig||, CODE, READONLY, ALIGN=2

                  RTC_TamperTriggerConfig PROC
;;;2077     */
;;;2078   void RTC_TamperTriggerConfig(uint32_t RTC_Tamper, uint32_t RTC_TamperTrigger)
000000  4a05              LDR      r2,|L48.24|
;;;2079   {
;;;2080     /* Check the parameters */
;;;2081     assert_param(IS_RTC_TAMPER(RTC_Tamper)); 
;;;2082     assert_param(IS_RTC_TAMPER_TRIGGER(RTC_TamperTrigger));
;;;2083    
;;;2084     if (RTC_TamperTrigger == RTC_TamperTrigger_RisingEdge)
000002  2900              CMP      r1,#0
;;;2085     {  
;;;2086       /* Configure the RTC_TAFCR register */
;;;2087       RTC->TAFCR &= (uint32_t)((uint32_t)~(RTC_Tamper << 1));	
;;;2088     }
;;;2089     else
;;;2090     { 
;;;2091       /* Configure the RTC_TAFCR register */
;;;2092       RTC->TAFCR |= (uint32_t)(RTC_Tamper << 1);  
000004  6811              LDR      r1,[r2,#0]
000006  d003              BEQ      |L48.16|
000008  ea410040          ORR      r0,r1,r0,LSL #1
                  |L48.12|
00000c  6010              STR      r0,[r2,#0]            ;2087
;;;2093     }  
;;;2094   }
00000e  4770              BX       lr
                  |L48.16|
000010  ea210040          BIC      r0,r1,r0,LSL #1       ;2087
000014  e7fa              B        |L48.12|
;;;2095   
                          ENDP

000016  0000              DCW      0x0000
                  |L48.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStampCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampCmd PROC
;;;1954     */
;;;1955   void RTC_TimeStampCmd(uint32_t RTC_TimeStampEdge, FunctionalState NewState)
000000  4b0a              LDR      r3,|L49.44|
;;;1956   {
000002  b510              PUSH     {r4,lr}
;;;1957     uint32_t tmpreg = 0;
;;;1958   
;;;1959     /* Check the parameters */
;;;1960     assert_param(IS_RTC_TIMESTAMP_EDGE(RTC_TimeStampEdge));
;;;1961     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1962   
;;;1963     /* Get the RTC_CR register and clear the bits to be configured */
;;;1964     tmpreg = (uint32_t)(RTC->CR & (uint32_t)~(RTC_CR_TSEDGE | RTC_CR_TSE));
000004  681a              LDR      r2,[r3,#0]
000006  f6400408          MOV      r4,#0x808
00000a  43a2              BICS     r2,r2,r4
;;;1965   
;;;1966     /* Get the new configuration */
;;;1967     if (NewState != DISABLE)
;;;1968     {
;;;1969       tmpreg |= (uint32_t)(RTC_TimeStampEdge | RTC_CR_TSE);
;;;1970     }
;;;1971     else
;;;1972     {
;;;1973       tmpreg |= (uint32_t)(RTC_TimeStampEdge);
00000c  ea420200          ORR      r2,r2,r0
000010  b109              CBZ      r1,|L49.22|
000012  f4426200          ORR      r2,r2,#0x800          ;1969
                  |L49.22|
;;;1974     }
;;;1975   
;;;1976     /* Disable the write protection for RTC registers */
;;;1977     RTC->WPR = 0xCA;
000016  4805              LDR      r0,|L49.44|
000018  21ca              MOVS     r1,#0xca
00001a  301c              ADDS     r0,r0,#0x1c
00001c  6001              STR      r1,[r0,#0]
;;;1978     RTC->WPR = 0x53;
00001e  2153              MOVS     r1,#0x53
000020  6001              STR      r1,[r0,#0]
;;;1979   
;;;1980     /* Configure the Time Stamp TSEDGE and Enable bits */
;;;1981     RTC->CR = (uint32_t)tmpreg;
000022  601a              STR      r2,[r3,#0]
;;;1982   
;;;1983     /* Enable the write protection for RTC registers */
;;;1984     RTC->WPR = 0xFF; 
000024  21ff              MOVS     r1,#0xff
000026  6001              STR      r1,[r0,#0]
;;;1985   }
000028  bd10              POP      {r4,pc}
;;;1986   
                          ENDP

00002a  0000              DCW      0x0000
                  |L49.44|
                          DCD      0x40002808

                          AREA ||i.RTC_TimeStampOnTamperDetectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampOnTamperDetectionCmd PROC
;;;2211     */
;;;2212   void RTC_TimeStampOnTamperDetectionCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L50.24|
;;;2213   {
;;;2214     /* Check the parameters */
;;;2215     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2216      
;;;2217     if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;2218     {
;;;2219       /* Save timestamp on tamper detection event */
;;;2220       RTC->TAFCR |= (uint32_t)RTC_TAFCR_TAMPTS;
;;;2221     }
;;;2222     else
;;;2223     {
;;;2224       /* Tamper detection does not cause a timestamp to be saved */
;;;2225       RTC->TAFCR &= (uint32_t)~RTC_TAFCR_TAMPTS;    
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L50.14|
000008  f0400080          ORR      r0,r0,#0x80           ;2220
00000c  e001              B        |L50.18|
                  |L50.14|
00000e  f0200080          BIC      r0,r0,#0x80
                  |L50.18|
000012  6008              STR      r0,[r1,#0]            ;2220
;;;2226     }
;;;2227   }
000014  4770              BX       lr
;;;2228   
                          ENDP

000016  0000              DCW      0x0000
                  |L50.24|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStampPinSelection||, CODE, READONLY, ALIGN=2

                  RTC_TimeStampPinSelection PROC
;;;2353     */
;;;2354   void RTC_TimeStampPinSelection(uint32_t RTC_TimeStampPin)
000000  4904              LDR      r1,|L51.20|
;;;2355   {
;;;2356     /* Check the parameters */
;;;2357     assert_param(IS_RTC_TIMESTAMP_PIN(RTC_TimeStampPin));
;;;2358     
;;;2359     RTC->TAFCR &= (uint32_t)~(RTC_TAFCR_TSINSEL);
000002  680a              LDR      r2,[r1,#0]
000004  f4223200          BIC      r2,r2,#0x20000
000008  600a              STR      r2,[r1,#0]
;;;2360     RTC->TAFCR |= (uint32_t)(RTC_TimeStampPin);  
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;2361   }
000010  4770              BX       lr
;;;2362   
                          ENDP

000012  0000              DCW      0x0000
                  |L51.20|
                          DCD      0x40002840

                          AREA ||i.RTC_TimeStructInit||, CODE, READONLY, ALIGN=1

                  RTC_TimeStructInit PROC
;;;848      */
;;;849    void RTC_TimeStructInit(RTC_TimeTypeDef* RTC_TimeStruct)
000000  2100              MOVS     r1,#0
;;;850    {
;;;851      /* Time = 00h:00min:00sec */
;;;852      RTC_TimeStruct->RTC_H12 = RTC_H12_AM;
000002  70c1              STRB     r1,[r0,#3]
;;;853      RTC_TimeStruct->RTC_Hours = 0;
000004  7001              STRB     r1,[r0,#0]
;;;854      RTC_TimeStruct->RTC_Minutes = 0;
000006  7041              STRB     r1,[r0,#1]
;;;855      RTC_TimeStruct->RTC_Seconds = 0; 
000008  7081              STRB     r1,[r0,#2]
;;;856    }
00000a  4770              BX       lr
;;;857    
                          ENDP


                          AREA ||i.RTC_WaitForSynchro||, CODE, READONLY, ALIGN=2

                  RTC_WaitForSynchro PROC
;;;606      */
;;;607    ErrorStatus RTC_WaitForSynchro(void)
000000  b518              PUSH     {r3,r4,lr}
;;;608    {
;;;609      __IO uint32_t synchrocounter = 0;
000002  2000              MOVS     r0,#0
;;;610      ErrorStatus status = ERROR;
;;;611      uint32_t synchrostatus = 0x00;
;;;612    
;;;613      /* Disable the write protection for RTC registers */
;;;614      RTC->WPR = 0xCA;
000004  4b10              LDR      r3,|L53.72|
000006  9000              STR      r0,[sp,#0]
000008  20ca              MOVS     r0,#0xca
00000a  6018              STR      r0,[r3,#0]
;;;615      RTC->WPR = 0x53;
00000c  2053              MOVS     r0,#0x53
00000e  6018              STR      r0,[r3,#0]
;;;616        
;;;617      /* Clear RSF flag */
;;;618      RTC->ISR &= (uint32_t)RTC_RSF_MASK;
000010  490d              LDR      r1,|L53.72|
000012  3918              SUBS     r1,r1,#0x18
000014  6808              LDR      r0,[r1,#0]
000016  f02000a0          BIC      r0,r0,#0xa0
00001a  6008              STR      r0,[r1,#0]
;;;619        
;;;620      /* Wait the registers to be synchronised */
;;;621      do
;;;622      {
;;;623        synchrostatus = RTC->ISR & RTC_ISR_RSF;
;;;624        synchrocounter++;  
;;;625      } while((synchrocounter != SYNCHRO_TIMEOUT) && (synchrostatus == 0x00));
00001c  f44f3400          MOV      r4,#0x20000
                  |L53.32|
000020  6808              LDR      r0,[r1,#0]            ;623
000022  9a00              LDR      r2,[sp,#0]            ;624
000024  f0000020          AND      r0,r0,#0x20           ;623
000028  1c52              ADDS     r2,r2,#1              ;624
00002a  9200              STR      r2,[sp,#0]
00002c  42a2              CMP      r2,r4
00002e  d001              BEQ      |L53.52|
000030  2800              CMP      r0,#0
000032  d0f5              BEQ      |L53.32|
                  |L53.52|
;;;626        
;;;627      if ((RTC->ISR & RTC_ISR_RSF) != RESET)
000034  6808              LDR      r0,[r1,#0]
000036  0680              LSLS     r0,r0,#26
000038  d501              BPL      |L53.62|
;;;628      {
;;;629        status = SUCCESS;
00003a  2001              MOVS     r0,#1
00003c  e000              B        |L53.64|
                  |L53.62|
;;;630      }
;;;631      else
;;;632      {
;;;633        status = ERROR;
00003e  2000              MOVS     r0,#0
                  |L53.64|
;;;634      }        
;;;635    
;;;636      /* Enable the write protection for RTC registers */
;;;637      RTC->WPR = 0xFF; 
000040  21ff              MOVS     r1,#0xff
000042  6019              STR      r1,[r3,#0]
;;;638        
;;;639      return (status); 
;;;640    }
000044  bd18              POP      {r3,r4,pc}
;;;641    
                          ENDP

000046  0000              DCW      0x0000
                  |L53.72|
                          DCD      0x40002824

                          AREA ||i.RTC_WakeUpClockConfig||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpClockConfig PROC
;;;1466     */
;;;1467   void RTC_WakeUpClockConfig(uint32_t RTC_WakeUpClock)
000000  4a08              LDR      r2,|L54.36|
;;;1468   {
;;;1469     /* Check the parameters */
;;;1470     assert_param(IS_RTC_WAKEUP_CLOCK(RTC_WakeUpClock));
;;;1471   
;;;1472     /* Disable the write protection for RTC registers */
;;;1473     RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6011              STR      r1,[r2,#0]
;;;1474     RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6011              STR      r1,[r2,#0]
;;;1475   
;;;1476     /* Clear the Wakeup Timer clock source bits in CR register */
;;;1477     RTC->CR &= (uint32_t)~RTC_CR_WUCKSEL;
00000a  4906              LDR      r1,|L54.36|
00000c  391c              SUBS     r1,r1,#0x1c
00000e  680b              LDR      r3,[r1,#0]
000010  f0230307          BIC      r3,r3,#7
000014  600b              STR      r3,[r1,#0]
;;;1478   
;;;1479     /* Configure the clock source */
;;;1480     RTC->CR |= (uint32_t)RTC_WakeUpClock;
000016  680b              LDR      r3,[r1,#0]
000018  4303              ORRS     r3,r3,r0
00001a  600b              STR      r3,[r1,#0]
;;;1481     
;;;1482     /* Enable the write protection for RTC registers */
;;;1483     RTC->WPR = 0xFF; 
00001c  20ff              MOVS     r0,#0xff
00001e  6010              STR      r0,[r2,#0]
;;;1484   }
000020  4770              BX       lr
;;;1485   
                          ENDP

000022  0000              DCW      0x0000
                  |L54.36|
                          DCD      0x40002824

                          AREA ||i.RTC_WakeUpCmd||, CODE, READONLY, ALIGN=2

                  RTC_WakeUpCmd PROC
;;;1526     */
;;;1527   ErrorStatus RTC_WakeUpCmd(FunctionalState NewState)
000000  b518              PUSH     {r3,r4,lr}
;;;1528   {
;;;1529     __IO uint32_t wutcounter = 0x00;
000002  2100              MOVS     r1,#0
;;;1530     uint32_t wutwfstatus = 0x00;
;;;1531     ErrorStatus status = ERROR;
;;;1532     
;;;1533     /* Check the parameters */
;;;1534     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1535   
;;;1536     /* Disable the write protection for RTC registers */
;;;1537     RTC->WPR = 0xCA;
000004  4b13              LDR      r3,|L55.84|
000006  9100              STR      r1,[sp,#0]
000008  21ca              MOVS     r1,#0xca
00000a  6019              STR      r1,[r3,#0]
;;;1538     RTC->WPR = 0x53;
00000c  2153              MOVS     r1,#0x53
00000e  6019              STR      r1,[r3,#0]
;;;1539   
;;;1540     if (NewState != DISABLE)
;;;1541     {
;;;1542       /* Enable the Wakeup Timer */
;;;1543       RTC->CR |= (uint32_t)RTC_CR_WUTE;
000010  4910              LDR      r1,|L55.84|
000012  391c              SUBS     r1,r1,#0x1c
000014  2800              CMP      r0,#0                 ;1540
;;;1544       status = SUCCESS;    
;;;1545     }
;;;1546     else
;;;1547     {
;;;1548       /* Disable the Wakeup Timer */
;;;1549       RTC->CR &= (uint32_t)~RTC_CR_WUTE;
000016  6808              LDR      r0,[r1,#0]
000018  d003              BEQ      |L55.34|
00001a  f4406080          ORR      r0,r0,#0x400          ;1543
00001e  6008              STR      r0,[r1,#0]            ;1543
000020  e014              B        |L55.76|
                  |L55.34|
000022  f4206080          BIC      r0,r0,#0x400
000026  6008              STR      r0,[r1,#0]
;;;1550       /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
;;;1551       do
;;;1552       {
;;;1553         wutwfstatus = RTC->ISR & RTC_ISR_WUTWF;
000028  490a              LDR      r1,|L55.84|
00002a  3918              SUBS     r1,r1,#0x18
;;;1554         wutcounter++;  
;;;1555       } while((wutcounter != INITMODE_TIMEOUT) && (wutwfstatus == 0x00));
00002c  138c              ASRS     r4,r1,#14
                  |L55.46|
00002e  6808              LDR      r0,[r1,#0]            ;1553
000030  9a00              LDR      r2,[sp,#0]            ;1554
000032  f0000004          AND      r0,r0,#4              ;1553
000036  1c52              ADDS     r2,r2,#1              ;1554
000038  9200              STR      r2,[sp,#0]
00003a  42a2              CMP      r2,r4
00003c  d001              BEQ      |L55.66|
00003e  2800              CMP      r0,#0
000040  d0f5              BEQ      |L55.46|
                  |L55.66|
;;;1556       
;;;1557       if ((RTC->ISR & RTC_ISR_WUTWF) == RESET)
000042  6808              LDR      r0,[r1,#0]
000044  0740              LSLS     r0,r0,#29
000046  d401              BMI      |L55.76|
;;;1558       {
;;;1559         status = ERROR;
000048  2000              MOVS     r0,#0
00004a  e000              B        |L55.78|
                  |L55.76|
;;;1560       }
;;;1561       else
;;;1562       {
;;;1563         status = SUCCESS;
00004c  2001              MOVS     r0,#1
                  |L55.78|
;;;1564       }    
;;;1565     }
;;;1566   
;;;1567     /* Enable the write protection for RTC registers */
;;;1568     RTC->WPR = 0xFF; 
00004e  21ff              MOVS     r1,#0xff
000050  6019              STR      r1,[r3,#0]
;;;1569     
;;;1570     return status;
;;;1571   }
000052  bd18              POP      {r3,r4,pc}
;;;1572   
                          ENDP

                  |L55.84|
                          DCD      0x40002824

                          AREA ||i.RTC_WriteBackupRegister||, CODE, READONLY, ALIGN=2

                  RTC_WriteBackupRegister PROC
;;;2275     */
;;;2276   void RTC_WriteBackupRegister(uint32_t RTC_BKP_DR, uint32_t Data)
000000  b508              PUSH     {r3,lr}
;;;2277   {
;;;2278     __IO uint32_t tmp = 0;
;;;2279     
;;;2280     /* Check the parameters */
;;;2281     assert_param(IS_RTC_BKP(RTC_BKP_DR));
;;;2282   
;;;2283     tmp = RTC_BASE + 0x50;
000002  4a03              LDR      r2,|L56.16|
;;;2284     tmp += (RTC_BKP_DR * 4);
000004  eb020080          ADD      r0,r2,r0,LSL #2
;;;2285   
;;;2286     /* Write the specified register */
;;;2287     *(__IO uint32_t *)tmp = (uint32_t)Data;
000008  9000              STR      r0,[sp,#0]
00000a  6001              STR      r1,[r0,#0]
;;;2288   }
00000c  bd08              POP      {r3,pc}
;;;2289   
                          ENDP

00000e  0000              DCW      0x0000
                  |L56.16|
                          DCD      0x40002850

                          AREA ||i.RTC_WriteProtectionCmd||, CODE, READONLY, ALIGN=2

                  RTC_WriteProtectionCmd PROC
;;;512      */
;;;513    void RTC_WriteProtectionCmd(FunctionalState NewState)
000000  4904              LDR      r1,|L57.20|
;;;514    {
000002  b108              CBZ      r0,|L57.8|
;;;515      /* Check the parameters */
;;;516      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;517        
;;;518      if (NewState != DISABLE)
;;;519      {
;;;520        /* Enable the write protection for RTC registers */
;;;521        RTC->WPR = 0xFF;   
000004  20ff              MOVS     r0,#0xff
000006  e002              B        |L57.14|
                  |L57.8|
;;;522      }
;;;523      else
;;;524      {
;;;525        /* Disable the write protection for RTC registers */
;;;526        RTC->WPR = 0xCA;
000008  20ca              MOVS     r0,#0xca
00000a  6008              STR      r0,[r1,#0]
;;;527        RTC->WPR = 0x53;    
00000c  2053              MOVS     r0,#0x53
                  |L57.14|
00000e  6008              STR      r0,[r1,#0]            ;521
;;;528      }
;;;529    }
000010  4770              BX       lr
;;;530    
                          ENDP

000012  0000              DCW      0x0000
                  |L57.20|
                          DCD      0x40002824

;*** Start embedded assembler ***

#line 1 "Libraries\\CMSIS\\stm32f4xx_rtc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_rtc_c_81435638____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___15_stm32f4xx_rtc_c_81435638____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_rtc_c_81435638____REVSH|
#line 128
|__asm___15_stm32f4xx_rtc_c_81435638____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
