; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\media_usb_key\usb_hcd.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\media_usb_key\usb_hcd.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\media_usb_key\usb_hcd.crf Libraries\STM32_USB_OTG_Driver\usb_hcd.c]
                          THUMB

                          AREA ||i.HCD_GetCurrentFrame||, CODE, READONLY, ALIGN=1

                  HCD_GetCurrentFrame PROC
;;;172      */
;;;173    uint32_t HCD_GetCurrentFrame (USB_OTG_CORE_HANDLE *pdev) 
000000  6940              LDR      r0,[r0,#0x14]
;;;174    {
;;;175     return (USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0xFFFF) ;
000002  6880              LDR      r0,[r0,#8]
000004  b280              UXTH     r0,r0
;;;176    }
000006  4770              BX       lr
;;;177    
                          ENDP


                          AREA ||i.HCD_GetCurrentSpeed||, CODE, READONLY, ALIGN=1

                  HCD_GetCurrentSpeed PROC
;;;126    
;;;127    uint32_t HCD_GetCurrentSpeed (USB_OTG_CORE_HANDLE *pdev)
000000  f8d000cc          LDR      r0,[r0,#0xcc]
;;;128    {    
;;;129        USB_OTG_HPRT0_TypeDef  HPRT0;
;;;130        HPRT0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
000004  6800              LDR      r0,[r0,#0]
;;;131        
;;;132        return HPRT0.b.prtspd;
000006  f3c04041          UBFX     r0,r0,#17,#2
;;;133    }
00000a  4770              BX       lr
;;;134    
                          ENDP


                          AREA ||i.HCD_GetHCState||, CODE, READONLY, ALIGN=1

                  HCD_GetHCState PROC
;;;210      */
;;;211    HC_STATUS HCD_GetHCState (USB_OTG_CORE_HANDLE *pdev ,  uint8_t ch_num) 
000000  4408              ADD      r0,r0,r1
;;;212    {
;;;213      return pdev->host.HC_Status[ch_num] ;
000002  f890028c          LDRB     r0,[r0,#0x28c]
;;;214    }
000006  4770              BX       lr
;;;215    
                          ENDP


                          AREA ||i.HCD_GetURB_State||, CODE, READONLY, ALIGN=1

                  HCD_GetURB_State PROC
;;;184      */
;;;185    URB_STATE HCD_GetURB_State (USB_OTG_CORE_HANDLE *pdev , uint8_t ch_num) 
000000  4408              ADD      r0,r0,r1
;;;186    {
;;;187      return pdev->host.URB_State[ch_num] ;
000002  f890029b          LDRB     r0,[r0,#0x29b]
;;;188    }
000006  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||i.HCD_GetXferCnt||, CODE, READONLY, ALIGN=1

                  HCD_GetXferCnt PROC
;;;196      */
;;;197    uint32_t HCD_GetXferCnt (USB_OTG_CORE_HANDLE *pdev, uint8_t ch_num) 
000000  eb000081          ADD      r0,r0,r1,LSL #2
;;;198    {
;;;199      return pdev->host.XferCnt[ch_num] ;
000004  f8d00250          LDR      r0,[r0,#0x250]
;;;200    }
000008  4770              BX       lr
;;;201    
                          ENDP


                          AREA ||i.HCD_HC_Init||, CODE, READONLY, ALIGN=1

                  HCD_HC_Init PROC
;;;222      */
;;;223    uint32_t HCD_HC_Init (USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num) 
000000  f7ffbffe          B.W      USB_OTG_HC_Init
;;;224    {
;;;225      return USB_OTG_HC_Init(pdev, hc_num);  
;;;226    }
;;;227    
                          ENDP


                          AREA ||i.HCD_Init||, CODE, READONLY, ALIGN=1

                  HCD_Init PROC
;;;90       */
;;;91     uint32_t HCD_Init(USB_OTG_CORE_HANDLE *pdev , 
000000  b510              PUSH     {r4,lr}
;;;92                       USB_OTG_CORE_ID_TypeDef coreID)
;;;93     {
;;;94       uint8_t i = 0;
000002  2200              MOVS     r2,#0
000004  4604              MOV      r4,r0                 ;93
;;;95       pdev->host.ConnSts = 0;
000006  4613              MOV      r3,r2
000008  f8c02210          STR      r2,[r0,#0x210]
                  |L7.12|
;;;96       
;;;97       for (i= 0; i< USB_OTG_MAX_TX_FIFOS; i++)
;;;98       {
;;;99       pdev->host.ErrCnt[i]  = 0;
00000c  eb040082          ADD      r0,r4,r2,LSL #2
000010  f8c03214          STR      r3,[r0,#0x214]
;;;100      pdev->host.XferCnt[i]   = 0;
000014  f8c03250          STR      r3,[r0,#0x250]
;;;101      pdev->host.HC_Status[i]   = HC_IDLE;
000018  18a0              ADDS     r0,r4,r2
00001a  f880328c          STRB     r3,[r0,#0x28c]
00001e  1c52              ADDS     r2,r2,#1              ;97
000020  b2d2              UXTB     r2,r2                 ;97
000022  2a0f              CMP      r2,#0xf               ;97
000024  d3f2              BCC      |L7.12|
;;;102      }
;;;103      pdev->host.hc[0].max_packet  = 8; 
000026  2008              MOVS     r0,#8
000028  f8a402b2          STRH     r0,[r4,#0x2b2]
;;;104    
;;;105      USB_OTG_SelectCore(pdev, coreID);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       USB_OTG_SelectCore
;;;106    #ifndef DUAL_ROLE_MODE_ENABLED
;;;107      USB_OTG_DisableGlobalInt(pdev);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       USB_OTG_DisableGlobalInt
;;;108      USB_OTG_CoreInit(pdev);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       USB_OTG_CoreInit
;;;109    
;;;110      /* Force Host Mode*/
;;;111      USB_OTG_SetCurrentMode(pdev , HOST_MODE);
00003e  2101              MOVS     r1,#1
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       USB_OTG_SetCurrentMode
;;;112      USB_OTG_CoreInitHost(pdev);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       USB_OTG_CoreInitHost
;;;113      USB_OTG_EnableGlobalInt(pdev);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       USB_OTG_EnableGlobalInt
;;;114    #endif
;;;115       
;;;116      return 0;
000052  2000              MOVS     r0,#0
;;;117    }
000054  bd10              POP      {r4,pc}
;;;118    
                          ENDP


                          AREA ||i.HCD_IsDeviceConnected||, CODE, READONLY, ALIGN=1

                  HCD_IsDeviceConnected PROC
;;;160      */
;;;161    uint32_t HCD_IsDeviceConnected(USB_OTG_CORE_HANDLE *pdev)
000000  f8d00210          LDR      r0,[r0,#0x210]
;;;162    {
;;;163      return (pdev->host.ConnSts);
;;;164    }
000004  4770              BX       lr
;;;165    
                          ENDP


                          AREA ||i.HCD_ResetPort||, CODE, READONLY, ALIGN=1

                  HCD_ResetPort PROC
;;;140      */
;;;141    uint32_t HCD_ResetPort(USB_OTG_CORE_HANDLE *pdev)
000000  b510              PUSH     {r4,lr}
;;;142    {
;;;143      /*
;;;144      Before starting to drive a USB reset, the application waits for the OTG 
;;;145      interrupt triggered by the debounce done bit (DBCDNE bit in OTG_FS_GOTGINT), 
;;;146      which indicates that the bus is stable again after the electrical debounce 
;;;147      caused by the attachment of a pull-up resistor on DP (FS) or DM (LS).
;;;148      */
;;;149      
;;;150      USB_OTG_ResetPort(pdev); 
000002  f7fffffe          BL       USB_OTG_ResetPort
;;;151      return 0;
000006  2000              MOVS     r0,#0
;;;152    }
000008  bd10              POP      {r4,pc}
;;;153    
                          ENDP


                          AREA ||i.HCD_SubmitRequest||, CODE, READONLY, ALIGN=1

                  HCD_SubmitRequest PROC
;;;234      */
;;;235    uint32_t HCD_SubmitRequest (USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num) 
000000  2200              MOVS     r2,#0
;;;236    {
;;;237      
;;;238      pdev->host.URB_State[hc_num] =   URB_IDLE;  
000002  1843              ADDS     r3,r0,r1
000004  f883229b          STRB     r2,[r3,#0x29b]
;;;239      pdev->host.hc[hc_num].xfer_count = 0 ;
000008  eb001341          ADD      r3,r0,r1,LSL #5
;;;240      return USB_OTG_HC_StartXfer(pdev, hc_num);
00000c  f8c322c0          STR      r2,[r3,#0x2c0]
000010  f7ffbffe          B.W      USB_OTG_HC_StartXfer
;;;241    }
;;;242    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Libraries\\STM32_USB_OTG_Driver\\usb_hcd.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_usb_hcd_c_HCD_Init____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___9_usb_hcd_c_HCD_Init____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_usb_hcd_c_HCD_Init____REVSH|
#line 128
|__asm___9_usb_hcd_c_HCD_Init____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
