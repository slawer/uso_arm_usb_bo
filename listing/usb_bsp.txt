; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\media_usb_key\usb_bsp.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\media_usb_key\usb_bsp.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\media_usb_key\usb_bsp.crf src\usb_bsp.c]
                          THUMB

                          AREA ||i.BSP_Delay||, CODE, READONLY, ALIGN=2

                  BSP_Delay PROC
;;;434      */
;;;435    static void BSP_Delay(uint32_t nTime, uint8_t unit)
000000  b510              PUSH     {r4,lr}
;;;436    {
;;;437    
;;;438      BSP_delay = nTime;
000002  4c07              LDR      r4,|L1.32|
000004  6020              STR      r0,[r4,#0]  ; BSP_delay
;;;439      BSP_SetTime(unit);
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       BSP_SetTime
                  |L1.12|
;;;440      while (BSP_delay != 0);
00000c  6820              LDR      r0,[r4,#0]  ; BSP_delay
00000e  2800              CMP      r0,#0
000010  d1fc              BNE      |L1.12|
;;;441      TIM_Cmd(TIM2, DISABLE);
000012  e8bd4010          POP      {r4,lr}
000016  2100              MOVS     r1,#0
000018  f04f4080          MOV      r0,#0x40000000
00001c  f7ffbffe          B.W      TIM_Cmd
;;;442    }
;;;443    
                          ENDP

                  |L1.32|
                          DCD      ||.data||

                          AREA ||i.BSP_Init||, CODE, READONLY, ALIGN=1

                  BSP_Init PROC
;;;70       */
;;;71     void BSP_Init(void)
000000  2100              MOVS     r1,#0
;;;72     {
;;;73       /* Configure PA0 pin: User Key pin */
;;;74       STM_EVAL_PBInit(BUTTON_USER, BUTTON_MODE_GPIO);
000002  4608              MOV      r0,r1
000004  f7ffbffe          B.W      STM_EVAL_PBInit
;;;75     }
;;;76     
                          ENDP


                          AREA ||i.BSP_SetTime||, CODE, READONLY, ALIGN=1

                  BSP_SetTime PROC
;;;449      */
;;;450    static void BSP_SetTime(uint8_t unit)
000000  b53e              PUSH     {r1-r5,lr}
;;;451    {
000002  4604              MOV      r4,r0
;;;452      TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;453    
;;;454      TIM_Cmd(TIM2, DISABLE);
000004  f04f4580          MOV      r5,#0x40000000
000008  2100              MOVS     r1,#0
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       TIM_Cmd
;;;455      TIM_ITConfig(TIM2, TIM_IT_Update, DISABLE);
000010  2200              MOVS     r2,#0
000012  2101              MOVS     r1,#1
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       TIM_ITConfig
;;;456    
;;;457    
;;;458      if (unit == TIM_USEC_DELAY)
00001a  2c02              CMP      r4,#2
00001c  d002              BEQ      |L3.36|
;;;459      {
;;;460        TIM_TimeBaseStructure.TIM_Period = 11;
;;;461      }
;;;462      else if (unit == TIM_MSEC_DELAY)
00001e  2c01              CMP      r4,#1
000020  d002              BEQ      |L3.40|
000022  e004              B        |L3.46|
                  |L3.36|
000024  200b              MOVS     r0,#0xb               ;460
000026  e001              B        |L3.44|
                  |L3.40|
;;;463      {
;;;464        TIM_TimeBaseStructure.TIM_Period = 11999;
000028  f64260df          MOV      r0,#0x2edf
                  |L3.44|
00002c  9001              STR      r0,[sp,#4]
                  |L3.46|
;;;465      }
;;;466      TIM_TimeBaseStructure.TIM_Prescaler = 5;
00002e  2005              MOVS     r0,#5
000030  f8ad0000          STRH     r0,[sp,#0]
;;;467      TIM_TimeBaseStructure.TIM_ClockDivision = 0;
000034  2000              MOVS     r0,#0
000036  f8ad0008          STRH     r0,[sp,#8]
;;;468      TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
00003a  f8ad0002          STRH     r0,[sp,#2]
;;;469    
;;;470      TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
00003e  4669              MOV      r1,sp
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       TIM_TimeBaseInit
;;;471      TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
000046  2101              MOVS     r1,#1
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       TIM_ClearITPendingBit
;;;472    
;;;473      TIM_ARRPreloadConfig(TIM2, ENABLE);
00004e  2101              MOVS     r1,#1
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       TIM_ARRPreloadConfig
;;;474    
;;;475      /* TIM IT enable */
;;;476      TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);
000056  2201              MOVS     r2,#1
000058  4611              MOV      r1,r2
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       TIM_ITConfig
;;;477    
;;;478      /* TIM2 enable counter */
;;;479      TIM_Cmd(TIM2, ENABLE);
000060  2101              MOVS     r1,#1
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       TIM_Cmd
;;;480    }
000068  bd3e              POP      {r1-r5,pc}
;;;481    
                          ENDP


                          AREA ||i.USB_OTG_BSP_ConfigVBUS||, CODE, READONLY, ALIGN=2

                  USB_OTG_BSP_ConfigVBUS PROC
;;;305      */
;;;306    void  USB_OTG_BSP_ConfigVBUS(USB_OTG_CORE_HANDLE *pdev)
000000  b51c              PUSH     {r2-r4,lr}
;;;307    {
;;;308      GPIO_InitTypeDef GPIO_InitStructure;
;;;309    
;;;310    
;;;311      RCC_AHB1PeriphClockCmd(HOST_POWERSW_PORT_RCC, ENABLE);
000002  2101              MOVS     r1,#1
000004  2004              MOVS     r0,#4
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;312    
;;;313    
;;;314      /* Configure Power Switch Vbus Pin */
;;;315      GPIO_InitStructure.GPIO_Pin = HOST_POWERSW_VBUS;
;;;316      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2102              MOVS     r1,#2
00000c  2001              MOVS     r0,#1                 ;315
00000e  f88d1005          STRB     r1,[sp,#5]
000012  9000              STR      r0,[sp,#0]
;;;317      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
000014  f88d0004          STRB     r0,[sp,#4]
;;;318      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
000018  2000              MOVS     r0,#0
00001a  f88d0006          STRB     r0,[sp,#6]
;;;319      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;  
;;;320      
;;;321      GPIO_Init(HOST_POWERSW_PORT, &GPIO_InitStructure);
00001e  4c07              LDR      r4,|L4.60|
000020  f88d0007          STRB     r0,[sp,#7]            ;319
000024  4669              MOV      r1,sp
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       GPIO_Init
;;;322    
;;;323      /* By Default, DISABLE is needed on output of the Power Switch */
;;;324      GPIO_SetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
00002c  2101              MOVS     r1,#1
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_SetBits
;;;325    
;;;326      USB_OTG_BSP_mDelay(200);   /* Delay is need for stabilising the Vbus Low
000034  20c8              MOVS     r0,#0xc8
000036  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;327          in Reset Condition, when Vbus=1 and Reset-button is pressed by user */
;;;328    
;;;329    }
00003a  bd1c              POP      {r2-r4,pc}
;;;330    
                          ENDP

                  |L4.60|
                          DCD      0x40020800

                          AREA ||i.USB_OTG_BSP_DriveVBUS||, CODE, READONLY, ALIGN=2

                  USB_OTG_BSP_DriveVBUS PROC
;;;273      */
;;;274    void USB_OTG_BSP_DriveVBUS(USB_OTG_CORE_HANDLE *pdev, uint8_t state)
000000  4804              LDR      r0,|L5.20|
;;;275    {
;;;276      /*
;;;277      On-chip 5 V VBUS generation is not supported. For this reason, a charge pump 
;;;278      or, if 5 V are available on the application board, a basic power switch, must 
;;;279      be added externally to drive the 5 V VBUS line. The external charge pump can 
;;;280      be driven by any GPIO output. When the application decides to power on VBUS 
;;;281      using the chosen GPIO, it must also set the port power bit in the host port 
;;;282      control and status register (PPWR bit in OTG_FS_HPRT).
;;;283    
;;;284      Bit 12 PPWR: Port power
;;;285      The application uses this field to control power to this port, and the core 
;;;286      clears this bit on an overcurrent condition.
;;;287      */
;;;288      if (0 == state)
000002  2900              CMP      r1,#0
;;;289      {
;;;290        /* DISABLE is needed on output of the Power Switch */
;;;291        GPIO_SetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
;;;292      }
;;;293      else
;;;294      {
;;;295        /*ENABLE the Power Switch by driving the Enable LOW */
;;;296        GPIO_ResetBits(HOST_POWERSW_PORT, HOST_POWERSW_VBUS);
000004  f04f0101          MOV      r1,#1
000008  d001              BEQ      |L5.14|
00000a  f7ffbffe          B.W      GPIO_ResetBits
                  |L5.14|
00000e  f7ffbffe          B.W      GPIO_SetBits
;;;297      }
;;;298    }
;;;299    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40020800

                          AREA ||i.USB_OTG_BSP_EnableInterrupt||, CODE, READONLY, ALIGN=1

                  USB_OTG_BSP_EnableInterrupt PROC
;;;245      */
;;;246    void USB_OTG_BSP_EnableInterrupt(USB_OTG_CORE_HANDLE *pdev)
000000  b538              PUSH     {r3-r5,lr}
;;;247    {
;;;248    
;;;249      NVIC_InitTypeDef NVIC_InitStructure;
;;;250      /* Enable USB Interrupt */
;;;251      NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
000002  f44f60c0          MOV      r0,#0x600
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;252    
;;;253      NVIC_InitStructure.NVIC_IRQChannel = OTG_FS_IRQn;
00000a  2043              MOVS     r0,#0x43
00000c  f88d0000          STRB     r0,[sp,#0]
;;;254      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
000010  2401              MOVS     r4,#1
000012  f88d4001          STRB     r4,[sp,#1]
;;;255      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
000016  f88d4002          STRB     r4,[sp,#2]
;;;256      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00001a  f88d4003          STRB     r4,[sp,#3]
;;;257      NVIC_Init(&NVIC_InitStructure);
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       NVIC_Init
;;;258    
;;;259      /* Enable the Overcurrent Interrupt */
;;;260      NVIC_InitStructure.NVIC_IRQChannel = HOST_OVRCURR_IRQn;
000024  2017              MOVS     r0,#0x17
000026  f88d0000          STRB     r0,[sp,#0]
;;;261      NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
00002a  f88d4001          STRB     r4,[sp,#1]
;;;262      NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
00002e  2002              MOVS     r0,#2
000030  f88d0002          STRB     r0,[sp,#2]
;;;263      NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000034  f88d4003          STRB     r4,[sp,#3]
;;;264    
;;;265      NVIC_Init(&NVIC_InitStructure);
000038  4668              MOV      r0,sp
00003a  f7fffffe          BL       NVIC_Init
;;;266    }
00003e  bd38              POP      {r3-r5,pc}
;;;267    
                          ENDP


                          AREA ||i.USB_OTG_BSP_Init||, CODE, READONLY, ALIGN=2

                  USB_OTG_BSP_Init PROC
;;;83       */
;;;84     void USB_OTG_BSP_Init(USB_OTG_CORE_HANDLE *pdev)
000000  b5fe              PUSH     {r1-r7,lr}
;;;85     {
;;;86      /* Note: On STM32F4-Discovery board only USB OTG FS core is supported. */
;;;87     
;;;88       GPIO_InitTypeDef GPIO_InitStructure;
;;;89      #ifdef USE_USB_OTG_FS 
;;;90     
;;;91       RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA , ENABLE);  
000002  2101              MOVS     r1,#1
000004  4608              MOV      r0,r1
000006  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;92       
;;;93       /* Configure SOF VBUS ID DM DP Pins */
;;;94       GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9  | 
00000a  f44f50d0          MOV      r0,#0x1a00
;;;95           GPIO_Pin_11 | 
;;;96             GPIO_Pin_12;
;;;97       
;;;98       GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
00000e  2603              MOVS     r6,#3
000010  9000              STR      r0,[sp,#0]
000012  f88d6005          STRB     r6,[sp,#5]
;;;99       GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
000016  2002              MOVS     r0,#2
000018  f88d0004          STRB     r0,[sp,#4]
;;;100      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
00001c  2500              MOVS     r5,#0
;;;101      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
;;;102      GPIO_Init(GPIOA, &GPIO_InitStructure);  
00001e  4f25              LDR      r7,|L7.180|
000020  f88d5006          STRB     r5,[sp,#6]            ;100
000024  f88d5007          STRB     r5,[sp,#7]            ;101
000028  4669              MOV      r1,sp
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       GPIO_Init
;;;103      
;;;104      GPIO_PinAFConfig(GPIOA,GPIO_PinSource9,GPIO_AF_OTG1_FS) ; 
000030  220a              MOVS     r2,#0xa
000032  2109              MOVS     r1,#9
000034  4638              MOV      r0,r7
000036  f7fffffe          BL       GPIO_PinAFConfig
;;;105      GPIO_PinAFConfig(GPIOA,GPIO_PinSource11,GPIO_AF_OTG1_FS) ; 
00003a  220a              MOVS     r2,#0xa
00003c  210b              MOVS     r1,#0xb
00003e  4638              MOV      r0,r7
000040  f7fffffe          BL       GPIO_PinAFConfig
;;;106      GPIO_PinAFConfig(GPIOA,GPIO_PinSource12,GPIO_AF_OTG1_FS) ;
000044  220a              MOVS     r2,#0xa
000046  210c              MOVS     r1,#0xc
000048  4638              MOV      r0,r7
00004a  f7fffffe          BL       GPIO_PinAFConfig
;;;107      
;;;108      /* this for ID line debug */
;;;109      
;;;110      
;;;111      GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_10;
;;;112      GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
00004e  2401              MOVS     r4,#1
000050  1538              ASRS     r0,r7,#20             ;111
000052  f88d4006          STRB     r4,[sp,#6]
000056  9000              STR      r0,[sp,#0]
;;;113      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP ;  
000058  f88d4007          STRB     r4,[sp,#7]
;;;114      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
00005c  f88d6005          STRB     r6,[sp,#5]
;;;115      GPIO_Init(GPIOA, &GPIO_InitStructure);  
000060  4669              MOV      r1,sp
000062  4638              MOV      r0,r7
000064  f7fffffe          BL       GPIO_Init
;;;116      GPIO_PinAFConfig(GPIOA,GPIO_PinSource10,GPIO_AF_OTG1_FS) ;   
000068  220a              MOVS     r2,#0xa
00006a  4611              MOV      r1,r2
00006c  4638              MOV      r0,r7
00006e  f7fffffe          BL       GPIO_PinAFConfig
;;;117    
;;;118    
;;;119      RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);
000072  2101              MOVS     r1,#1
000074  0388              LSLS     r0,r1,#14
000076  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;120      RCC_AHB2PeriphClockCmd(RCC_AHB2Periph_OTG_FS, ENABLE) ; 
00007a  2101              MOVS     r1,#1
00007c  2080              MOVS     r0,#0x80
00007e  f7fffffe          BL       RCC_AHB2PeriphClockCmd
000082  2100              MOVS     r1,#0
000084  06e0              LSLS     r0,r4,#27
000086  f7fffffe          BL       NVIC_SetVectorTable
00008a  f44f60a0          MOV      r0,#0x500
00008e  f7fffffe          BL       NVIC_PriorityGroupConfig
000092  201c              MOVS     r0,#0x1c
000094  f88d0008          STRB     r0,[sp,#8]
000098  f88d5009          STRB     r5,[sp,#9]
00009c  f88d400a          STRB     r4,[sp,#0xa]
0000a0  f88d400b          STRB     r4,[sp,#0xb]
0000a4  a802              ADD      r0,sp,#8
0000a6  f7fffffe          BL       NVIC_Init
0000aa  2101              MOVS     r1,#1
0000ac  4608              MOV      r0,r1
0000ae  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;121     #else // USE_USB_OTG_HS 
;;;122    
;;;123      #ifdef USE_ULPI_PHY // ULPI
;;;124      RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOA | RCC_AHB1Periph_GPIOB | 
;;;125                             RCC_AHB1Periph_GPIOC | RCC_AHB1Periph_GPIOH | 
;;;126                               RCC_AHB1Periph_GPIOI, ENABLE);    
;;;127      
;;;128      
;;;129      GPIO_PinAFConfig(GPIOA,GPIO_PinSource3, GPIO_AF_OTG2_HS) ; // D0
;;;130      GPIO_PinAFConfig(GPIOA,GPIO_PinSource5, GPIO_AF_OTG2_HS) ; // CLK
;;;131      GPIO_PinAFConfig(GPIOB,GPIO_PinSource0, GPIO_AF_OTG2_HS) ; // D1
;;;132      GPIO_PinAFConfig(GPIOB,GPIO_PinSource1, GPIO_AF_OTG2_HS) ; // D2
;;;133      GPIO_PinAFConfig(GPIOB,GPIO_PinSource5, GPIO_AF_OTG2_HS) ; // D7
;;;134      GPIO_PinAFConfig(GPIOB,GPIO_PinSource10,GPIO_AF_OTG2_HS) ; // D3
;;;135      GPIO_PinAFConfig(GPIOB,GPIO_PinSource11,GPIO_AF_OTG2_HS) ; // D4
;;;136      GPIO_PinAFConfig(GPIOB,GPIO_PinSource12,GPIO_AF_OTG2_HS) ; // D5
;;;137      GPIO_PinAFConfig(GPIOB,GPIO_PinSource13,GPIO_AF_OTG2_HS) ; // D6
;;;138      GPIO_PinAFConfig(GPIOH,GPIO_PinSource4, GPIO_AF_OTG2_HS) ; // NXT
;;;139      GPIO_PinAFConfig(GPIOI,GPIO_PinSource11,GPIO_AF_OTG2_HS) ; // DIR
;;;140      GPIO_PinAFConfig(GPIOC,GPIO_PinSource0, GPIO_AF_OTG2_HS) ; // STP
;;;141      
;;;142      // CLK
;;;143      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 ; 
;;;144      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;145      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;146      GPIO_Init(GPIOA, &GPIO_InitStructure);  
;;;147      
;;;148      // D0
;;;149      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3  ; 
;;;150      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;151      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;152      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;153      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
;;;154      GPIO_Init(GPIOA, &GPIO_InitStructure);  
;;;155      
;;;156      
;;;157      
;;;158      // D1 D2 D3 D4 D5 D6 D7
;;;159      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1  |
;;;160        GPIO_Pin_5 | GPIO_Pin_10 | 
;;;161          GPIO_Pin_11| GPIO_Pin_12 | 
;;;162            GPIO_Pin_13 ;
;;;163      
;;;164      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;165      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;166      GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
;;;167      GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL ;
;;;168      GPIO_Init(GPIOB, &GPIO_InitStructure);  
;;;169      
;;;170      
;;;171      // STP
;;;172      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  ;
;;;173      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;174      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;175      GPIO_Init(GPIOC, &GPIO_InitStructure);  
;;;176      
;;;177      //NXT  
;;;178      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
;;;179      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;180      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;181      GPIO_Init(GPIOH, &GPIO_InitStructure);  
;;;182      
;;;183      
;;;184      //DIR
;;;185      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 ; 
;;;186      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;187      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;188      GPIO_Init(GPIOI, &GPIO_InitStructure);  
;;;189      
;;;190      
;;;191      RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_OTG_HS | 
;;;192                             RCC_AHB1Periph_OTG_HS_ULPI, ENABLE) ;    
;;;193       
;;;194      #else
;;;195      
;;;196       #ifdef USE_I2C_PHY    
;;;197      RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_GPIOB , ENABLE);  
;;;198      /* Configure RESET INTN SCL SDA (Phy/I2C) Pins */
;;;199      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | 
;;;200        GPIO_Pin_1 | 
;;;201          GPIO_Pin_10 | 
;;;202            GPIO_Pin_11;
;;;203      
;;;204      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;205      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;206      GPIO_Init(GPIOB, &GPIO_InitStructure);  
;;;207      
;;;208      GPIO_PinAFConfig(GPIOB,GPIO_PinSource0,GPIO_AF_OTG2_FS) ; 
;;;209      GPIO_PinAFConfig(GPIOB,GPIO_PinSource1,GPIO_AF_OTG2_FS) ; 
;;;210      GPIO_PinAFConfig(GPIOB,GPIO_PinSource10,GPIO_AF_OTG2_FS) ; 
;;;211      GPIO_PinAFConfig(GPIOB,GPIO_PinSource11,GPIO_AF_OTG2_FS);
;;;212      RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_OTG_HS, ENABLE) ;  
;;;213      
;;;214       #else
;;;215    
;;;216      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB , ENABLE);
;;;217      
;;;218      GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12  | 
;;;219        GPIO_Pin_13 |
;;;220          GPIO_Pin_14 | 
;;;221            GPIO_Pin_15;
;;;222      
;;;223      GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
;;;224      GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
;;;225      GPIO_Init(GPIOB, &GPIO_InitStructure);  
;;;226      
;;;227      GPIO_PinAFConfig(GPIOB,GPIO_PinSource12, GPIO_AF_OTG2_FS) ; 
;;;228      GPIO_PinAFConfig(GPIOB,GPIO_PinSource13,GPIO_AF_OTG2_FS) ; 
;;;229      GPIO_PinAFConfig(GPIOB,GPIO_PinSource14,GPIO_AF_OTG2_FS) ; 
;;;230      GPIO_PinAFConfig(GPIOB,GPIO_PinSource15,GPIO_AF_OTG2_FS) ;
;;;231      RCC_AHB1PeriphClockCmd( RCC_AHB1Periph_OTG_HS, ENABLE) ;  
;;;232       #endif    
;;;233      #endif
;;;234     #endif //USB_OTG_HS
;;;235    
;;;236      /* Intialize Timer for delay function */
;;;237      USB_OTG_BSP_TimeInit(); 
;;;238    }
0000b2  bdfe              POP      {r1-r7,pc}
;;;239    
                          ENDP

                  |L7.180|
                          DCD      0x40020000

                          AREA ||i.USB_OTG_BSP_TimerIRQ||, CODE, READONLY, ALIGN=2

                  USB_OTG_BSP_TimerIRQ PROC
;;;407      */
;;;408    void USB_OTG_BSP_TimerIRQ (void)
000000  b510              PUSH     {r4,lr}
;;;409    {
;;;410    #ifdef USE_ACCURATE_TIME
;;;411      if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
000002  2101              MOVS     r1,#1
000004  078c              LSLS     r4,r1,#30
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       TIM_GetITStatus
00000c  2800              CMP      r0,#0
00000e  d009              BEQ      |L8.36|
;;;412      {
;;;413        TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
000010  2101              MOVS     r1,#1
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       TIM_ClearITPendingBit
;;;414        if (BSP_delay > 0x00)
000018  4906              LDR      r1,|L8.52|
00001a  680a              LDR      r2,[r1,#0]  ; BSP_delay
00001c  b11a              CBZ      r2,|L8.38|
;;;415        {
;;;416          BSP_delay--;
00001e  6808              LDR      r0,[r1,#0]  ; BSP_delay
000020  1e40              SUBS     r0,r0,#1
000022  6008              STR      r0,[r1,#0]  ; BSP_delay
                  |L8.36|
;;;417        }
;;;418        else
;;;419        {
;;;420          TIM_Cmd(TIM2, DISABLE);
;;;421        }
;;;422      }
;;;423    #endif
;;;424    }
000024  bd10              POP      {r4,pc}
                  |L8.38|
000026  4620              MOV      r0,r4                 ;420
000028  e8bd4010          POP      {r4,lr}               ;420
00002c  2100              MOVS     r1,#0                 ;420
00002e  f7ffbffe          B.W      TIM_Cmd
;;;425    
                          ENDP

000032  0000              DCW      0x0000
                  |L8.52|
                          DCD      ||.data||

                          AREA ||i.USB_OTG_BSP_mDelay||, CODE, READONLY, ALIGN=1

                  USB_OTG_BSP_mDelay PROC
;;;391      */
;;;392    void USB_OTG_BSP_mDelay (const uint32_t msec)
000000  2101              MOVS     r1,#1
;;;393    {
;;;394    #ifdef USE_ACCURATE_TIME
;;;395      BSP_Delay(msec, TIM_MSEC_DELAY);
000002  f7ffbffe          B.W      BSP_Delay
;;;396    #else
;;;397      USB_OTG_BSP_uDelay(msec * 1000);
;;;398    #endif
;;;399    
;;;400    }
;;;401    
                          ENDP


                          AREA ||i.USB_OTG_BSP_uDelay||, CODE, READONLY, ALIGN=1

                  USB_OTG_BSP_uDelay PROC
;;;365      */
;;;366    void USB_OTG_BSP_uDelay (const uint32_t usec)
000000  2102              MOVS     r1,#2
;;;367    {
;;;368    
;;;369    #ifdef USE_ACCURATE_TIME
;;;370      BSP_Delay(usec, TIM_USEC_DELAY);
000002  f7ffbffe          B.W      BSP_Delay
;;;371    #else
;;;372      __IO uint32_t count = 0;
;;;373      const uint32_t utime = (120 * usec / 7);
;;;374      do
;;;375      {
;;;376        if ( ++count > utime )
;;;377        {
;;;378          return ;
;;;379        }
;;;380      }
;;;381      while (1);
;;;382    #endif
;;;383    
;;;384    }
;;;385    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  BSP_delay
                          DCD      0x00000000

                          AREA ||area_number.14||, DATA, ALIGN=0

                          EXPORTAS ||area_number.14||, ||.data||
                  HSEStartUpStatus
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "src\\usb_bsp.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_usb_bsp_c_6771ef19____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___9_usb_bsp_c_6771ef19____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___9_usb_bsp_c_6771ef19____REVSH|
#line 128
|__asm___9_usb_bsp_c_6771ef19____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
