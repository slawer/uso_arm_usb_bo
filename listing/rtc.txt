; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\MEDIA_USB_KEY\rtc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\MEDIA_USB_KEY\rtc.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\MEDIA_USB_KEY\rtc.crf src\rtc.c]
                          THUMB

                          AREA ||i.rtc_Get||, CODE, READONLY, ALIGN=2

                  rtc_Get PROC
;;;755    // Получить текущее время
;;;756    void rtc_Get(TDateTime * DateTime)
000000  4921              LDR      r1,|L1.136|
;;;757    {
000002  b510              PUSH     {r4,lr}
;;;758        uint32_t Date = RTC->DR;
000004  6809              LDR      r1,[r1,#0]
;;;759        uint32_t Time = RTC->TR;
000006  4a20              LDR      r2,|L1.136|
000008  1f12              SUBS     r2,r2,#4
00000a  6812              LDR      r2,[r2,#0]
;;;760        
;;;761        // Очистим
;;;762        memset(DateTime, 0, sizeof(*DateTime));
00000c  2300              MOVS     r3,#0
00000e  6003              STR      r3,[r0,#0]
000010  8083              STRH     r3,[r0,#4]
;;;763        
;;;764        // Год
;;;765        DateTime->Year      = ((Date >> 20) & 0x0f) * 10 + ((Date >> 16) & 0x0f);
000012  f3c15303          UBFX     r3,r1,#20,#4
000016  eb030383          ADD      r3,r3,r3,LSL #2
00001a  f3c14403          UBFX     r4,r1,#16,#4
00001e  eb040343          ADD      r3,r4,r3,LSL #1
000022  7003              STRB     r3,[r0,#0]
;;;766        // Месяц
;;;767        DateTime->Month     = ((Date >> 12) & 0x01) * 10 + ((Date >>  8) & 0x0f);
000024  f3c13300          UBFX     r3,r1,#12,#1
000028  eb030383          ADD      r3,r3,r3,LSL #2
00002c  f3c12403          UBFX     r4,r1,#8,#4
000030  eb040343          ADD      r3,r4,r3,LSL #1
000034  7043              STRB     r3,[r0,#1]
;;;768        // День
;;;769        DateTime->Day       = ((Date >>  4) & 0x03) * 10 + ((Date >>  0) & 0x0f);
000036  f3c11301          UBFX     r3,r1,#4,#2
00003a  f001040f          AND      r4,r1,#0xf
00003e  eb030383          ADD      r3,r3,r3,LSL #2
000042  eb040343          ADD      r3,r4,r3,LSL #1
000046  7083              STRB     r3,[r0,#2]
;;;770        // День недели
;;;771        DateTime->DayOfWeek = ((Date >> 13) & 0x07);
000048  f3c13142          UBFX     r1,r1,#13,#3
00004c  70c1              STRB     r1,[r0,#3]
;;;772        
;;;773        // Час
;;;774        DateTime->Hours     = ((Time >> 20) & 0x03) * 10 + ((Time >> 16) & 0x0f);
00004e  f3c25101          UBFX     r1,r2,#20,#2
000052  eb010181          ADD      r1,r1,r1,LSL #2
000056  f3c24303          UBFX     r3,r2,#16,#4
00005a  eb030141          ADD      r1,r3,r1,LSL #1
00005e  7101              STRB     r1,[r0,#4]
;;;775        // Минуты
;;;776        DateTime->Minutes   = ((Time >> 12) & 0x07) * 10 + ((Time >> 8) & 0x0f);
000060  f3c23102          UBFX     r1,r2,#12,#3
000064  eb010181          ADD      r1,r1,r1,LSL #2
000068  f3c22303          UBFX     r3,r2,#8,#4
00006c  eb030141          ADD      r1,r3,r1,LSL #1
000070  7141              STRB     r1,[r0,#5]
;;;777        // Секунды
;;;778        DateTime->Seconds   = ((Time >> 4) & 0x07) * 10 + ((Time >> 0) & 0x0f);
000072  f3c21102          UBFX     r1,r2,#4,#3
000076  f002030f          AND      r3,r2,#0xf
00007a  eb010181          ADD      r1,r1,r1,LSL #2
00007e  eb030141          ADD      r1,r3,r1,LSL #1
000082  7181              STRB     r1,[r0,#6]
;;;779    }
000084  bd10              POP      {r4,pc}
                          ENDP

000086  0000              DCW      0x0000
                  |L1.136|
                          DCD      0x40002804

                          AREA ||i.rtc_Init||, CODE, READONLY, ALIGN=2

                  rtc_Init PROC
;;;126    // Инициализация модуля
;;;127    void rtc_Init(void)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;128    {
;;;129    		u32 tmp=0;
;;;130    	
;;;131    	  GPIO_InitTypeDef      GPIO_InitStructure;
;;;132    	
;;;133        // Если часы запущены, делать тут нечего.
;;;134        if(RTC->ISR & RTC_ISR_INITS) return;
000004  4a66              LDR      r2,|L2.416|
000006  6810              LDR      r0,[r2,#0]
000008  06c0              LSLS     r0,r0,#27
00000a  d47c              BMI      |L2.262|
;;;135        
;;;136        // Включим тактирование PWR
;;;137        RCC->APB1ENR |= RCC_APB1ENR_PWREN;
00000c  4865              LDR      r0,|L2.420|
00000e  6801              LDR      r1,[r0,#0]
000010  f0415180          ORR      r1,r1,#0x10000000
000014  6001              STR      r1,[r0,#0]
;;;138        
;;;139        // Разрешим доступ к управляющим регистрам энергонезависимого домена
;;;140        PWR->CR |= PWR_CR_DBP;
000016  4864              LDR      r0,|L2.424|
000018  6801              LDR      r1,[r0,#0]
00001a  f4417180          ORR      r1,r1,#0x100
00001e  6001              STR      r1,[r0,#0]
;;;141       
;;;142    /*
;;;143    	//  Кварц MC306-G-06Q-32.768 (JFVNY)
;;;144    	 //  start LSE
;;;145    		RCC->BDCR |= RCC_BDCR_LSEON;
;;;146    		while ((RCC->BDCR & RCC_BDCR_LSEON) != RCC_BDCR_LSEON) {}
;;;147    		
;;;148    		RCC->BDCR |=  RCC_BDCR_BDRST;
;;;149        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;150    		
;;;151    	// Выберем его как источник тактирования RTC:
;;;152        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
;;;153        RCC->BDCR |= (RCC_BDCR_RTCSEL_0); // запишем 0b10
;;;154    		
;;;155    		   // Включим тактирование RTC
;;;156        RCC->BDCR |= RCC_BDCR_RTCEN;
;;;157    */
;;;158     
;;;159    /* RTC configuration set 
;;;160    PWR->CR |= (1<<8);	 // Access to RTC and RTC backup registers and backup SRAM enabled
;;;161    RCC->CSR &= (1<<0);	 // LSI Off
;;;162    RCC->BDCR = 0x00000000;	 // Reset BDCR register
;;;163    RCC->BDCR |= (1<<15);	 // RTC clock enable
;;;164    RCC->BDCR |= (1<<0);	 // LSE On
;;;165    RCC->BDCR &= ~(1<<2);	 // LSE not bypassed quartz On
;;;166    RCC->BDCR &= ~(1<<16);	 // Backup domain software reset not activated
;;;167    RCC->BDCR |= (0x1<<8);	 // LSE used as the RTC clock
;;;168    RTC->WPR = 0x000000CA;	 // Key protect 1
;;;169    RTC->WPR = 0x00000053;	 // Key protect 2
;;;170    RTC->ISR |= (1<<7);	 // Initialization mode On
;;;171    for(;((RTC->ISR & 0x40) == 0x00);)	// delay while initialization flag will be set
;;;172    {
;;;173    }
;;;174    */	
;;;175    	/* 
;;;176    	JFVNY MC306G06 6 50000 32768 2 9.3
;;;177    	PC14/OSC32_IN   (PC14)
;;;178    	PC15/OSC32_OUT (PC15)
;;;179    	PB2/BOOT1    (PB2)
;;;180    */
;;;181    
;;;182    
;;;183    /*
;;;184    	//     push pull out  in kvarc
;;;185    	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_14|GPIO_Pin_15;      		  //  vvod  knopka 1
;;;186    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    										// 	rezim vivoda
;;;187    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		//
;;;188    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 									//	speed
;;;189    	GPIO_Init(GPIOC, &GPIO_InitStructure); 
;;;190    
;;;191    	for(tmp=0;tmp<10000;tmp++)	// delay while initialization flag will be set
;;;192    	{ __ASM volatile ("nop"); 	}
;;;193    
;;;194    //	GPIOA->BSRR = GPIO_BSRR_BS14; // Boot the cristal 
;;;195    	GPIOA->BSRRL = GPIO_Pin_14;
;;;196    //	GPIOA->BSRRL = GPIO_Pin_15;
;;;197    	GPIOB->BSRRL = GPIO_Pin_2;
;;;198    	
;;;199    	for(tmp=0;tmp<1000000;tmp++)	
;;;200    	{ __ASM volatile ("nop"); 	}
;;;201    	
;;;202    //     analog in kvarc
;;;203    	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_14|GPIO_Pin_15;      		  //  vvod  knopka 1
;;;204    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AN;    										// 	rezim vivoda
;;;205    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;  										//GPIO_OType_PP		//
;;;206    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 									//	speed
;;;207    	GPIO_Init(GPIOC, &GPIO_InitStructure); 
;;;208    */
;;;209    
;;;210     /*
;;;211    		
;;;212    		RCC->BDCR |=  RCC_BDCR_BDRST;
;;;213        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;214    		
;;;215    	// Выберем его как источник тактирования RTC:
;;;216        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
;;;217        RCC->BDCR |= (RCC_BDCR_RTCSEL_0); // запишем 0b10
;;;218    		
;;;219    		   // Включим тактирование RTC
;;;220        RCC->BDCR |= RCC_BDCR_RTCEN;
;;;221    	*/	
;;;222    /*	
;;;223    
;;;224    Попробуйте дать ему пинка. Сконфигурируйте ноги на выход и подайте напряжение на кварц на четверть периода. Потом уже снова на вход и запускайте генератор. Заводились даже 12 пФ кварцы. Только работали нестабильно.
;;;225    	GPIOC->CRH |= GPIO_CRH_MODE14_1 |GPIO_CRH_MODE15_1; // Out 2 MHZ
;;;226    	GPIOC->CRH &= ~(GPIO_CRH_CNF14|GPIO_CRH_CNF15); // PUSH pull
;;;227    	Delay();
;;;228    	GPIOA->BSRR = GPIO_BSRR_BS14; // Boot the cristal 
;;;229    	Delay();
;;;230    	GPIOC->CRH &= ~(GPIO_CRH_MODE14_1|GPIO_CRH_MODE15_1); // Analog IN 
;;;231    	RCC->BDCR |= RCC_BDCR_LSEON;
;;;232    
;;;233    KX-38 32.768 kHz 6pF,
;;;234    		32.768kHz crystal, with 6pF CL and 50kOhm ESR. 
;;;235    		a 15MOhm parallel resistor.
;;;236    if (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
;;;237    {
;;;238    
;;;239        RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE); // Enable PWR clock 
;;;240     
;;;241     //   PWR_BackupAccessCmd(ENABLE); // Allow access to BKP Domain 
;;;242    		 RCC->CSR = RCC_CSR_LSION;
;;;243        RCC_LSEConfig(RCC_LSE_ON); // Enable the LSE oscillator 
;;;244     
;;;245        while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET) // Wait till LSE is ready
;;;246    		{
;;;247    		 __ASM volatile ("nop");   
;;;248    		}
;;;249    }
;;;250    */
;;;251    /*
;;;252        // Запускаем LSI:
;;;253        RCC->CSR |= RCC_CSR_LSION;
;;;254        
;;;255        // Ждём, когда он заведётся
;;;256        while(!(RCC->CSR & RCC_CSR_LSIRDY)) {}
;;;257        
;;;258        // Ок, генератор на 32 кГц завёлся.
;;;259        
;;;260        // Сбросим состояние энергонезависимого домена
;;;261        RCC->BDCR |=  RCC_BDCR_BDRST;
;;;262        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;263        
;;;264        // Выберем его как источник тактирования RTC:
;;;265        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
;;;266        RCC->BDCR |= (RCC_BDCR_RTCSEL_1); // запишем 0b10
;;;267          
;;;268        // Включим тактирование RTC
;;;269        RCC->BDCR |= RCC_BDCR_RTCEN;
;;;270     */
;;;271    
;;;272    /*
;;;273    ● Access to the backup SRAM
;;;274    1. Enable the power interface clock by setting the PWREN bits in the RCC APB1
;;;275    peripheral clock enable register (RCC_APB1ENR)
;;;276    2. Set the DBP bit in the PWR power control register (PWR_CR) to enable access to the
;;;277    backup domain
;;;278    3. Enable the backup SRAM clock by setting BKPSRAMEN bit in the RCC AHB1
;;;279    peripheral clock register (RCC_AHB1ENR)
;;;280    
;;;281    uint8_t *BKPRam = (uint8_t *)0x40024000;
;;;282    
;;;283    
;;;284    */	
;;;285    
;;;286       // Запускаем LSI:
;;;287        RCC->CSR |= RCC_CSR_LSION;
000020  4860              LDR      r0,|L2.420|
000022  3034              ADDS     r0,r0,#0x34
000024  6801              LDR      r1,[r0,#0]
000026  f0410101          ORR      r1,r1,#1
00002a  6001              STR      r1,[r0,#0]
                  |L2.44|
;;;288        
;;;289        // Ждём, когда он заведётся
;;;290        while(!(RCC->CSR & RCC_CSR_LSIRDY)) {}
00002c  6801              LDR      r1,[r0,#0]
00002e  0789              LSLS     r1,r1,#30
000030  d5fc              BPL      |L2.44|
;;;291        
;;;292        // Ок, генератор на 32 кГц завёлся.
;;;293        
;;;294        // Сбросим состояние энергонезависимого домена
;;;295        RCC->BDCR |=  RCC_BDCR_BDRST;
000032  485c              LDR      r0,|L2.420|
000034  3030              ADDS     r0,r0,#0x30
000036  6801              LDR      r1,[r0,#0]
000038  f4413180          ORR      r1,r1,#0x10000
00003c  6001              STR      r1,[r0,#0]
;;;296        RCC->BDCR &= ~RCC_BDCR_BDRST;
00003e  6801              LDR      r1,[r0,#0]
000040  f4213180          BIC      r1,r1,#0x10000
000044  6001              STR      r1,[r0,#0]
;;;297        
;;;298        // Выберем его как источник тактирования RTC:
;;;299        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
000046  6801              LDR      r1,[r0,#0]
000048  f4217140          BIC      r1,r1,#0x300
00004c  6001              STR      r1,[r0,#0]
;;;300        RCC->BDCR |= (RCC_BDCR_RTCSEL_1); // запишем 0b10
00004e  6801              LDR      r1,[r0,#0]
000050  f4417100          ORR      r1,r1,#0x200
000054  6001              STR      r1,[r0,#0]
;;;301          
;;;302        // Включим тактирование RTC
;;;303        RCC->BDCR |= RCC_BDCR_RTCEN;
000056  6801              LDR      r1,[r0,#0]
000058  f4414100          ORR      r1,r1,#0x8000
00005c  6001              STR      r1,[r0,#0]
;;;304    			
;;;305    /*
;;;306    		 //  start LSE
;;;307    		 RCC->BDCR |= RCC_BDCR_LSEON;
;;;308    		 while ((RCC->BDCR & RCC_BDCR_LSEON) != RCC_BDCR_LSEON) {}			
;;;309    		 while (!(RCC->BDCR & RCC_BDCR_LSERDY)) {}			
;;;310    		 RCC->BDCR |= RCC_BDCR_RTCEN | RCC_BDCR_RTCSEL_0;
;;;311    			
;;;312          // Снимем защиту от записи с регистров RTC
;;;313          rtc_Unlock();
;;;314            // Войдём в режим инициализации:
;;;315          RTC->ISR |= RTC_ISR_INIT;
;;;316    			while(!(RTC->ISR & RTC_ISR_INITF)) {}
;;;317    
;;;318    					RTC->PRER = 0x00000000; // RESET PRER register
;;;319    					RTC->PRER |= (0xFF<<0); // 255 + 1 Synchronous prescaler factor set
;;;320    					RTC->PRER |= (0x7F<<16); // 127 + 1 Asynchronous prescaler factor set
;;;321         */          
;;;322            // Устанавливаем дату: 30.05.13, пятница
;;;323    				//       rtc_SetDate(2, 6, 13, 7);       
;;;324            // Устанавливаем время: 15:00:00
;;;325    				//      rtc_SetTime(0, 0, 00);       
;;;326            // Переведём часы в 24-часовой формат
;;;327            RTC->CR |= RTC_CR_FMT;        
00005e  4850              LDR      r0,|L2.416|
000060  1f00              SUBS     r0,r0,#4
000062  6801              LDR      r1,[r0,#0]
000064  f0410140          ORR      r1,r1,#0x40
000068  6001              STR      r1,[r0,#0]
;;;328            // Инициализация закончилась
;;;329            RTC->ISR &= ~RTC_ISR_INIT;   
00006a  6810              LDR      r0,[r2,#0]
00006c  f0200080          BIC      r0,r0,#0x80
000070  6010              STR      r0,[r2,#0]
000072  494b              LDR      r1,|L2.416|
000074  20ff              MOVS     r0,#0xff
000076  3118              ADDS     r1,r1,#0x18
000078  6008              STR      r0,[r1,#0]
;;;330        rtc_Lock();
;;;331    		
;;;332    		// Allow access to BKP Domain 
;;;333    //PWR_BackupAccessCmd(ENABLE);
;;;334    
;;;335    // Write to the first RTC Backup Data Register 
;;;336    RTC_WriteBackupRegister(RTC_BKP_DR2,0xA5A5);
00007a  f24a51a5          MOV      r1,#0xa5a5
00007e  2002              MOVS     r0,#2
000080  f7fffffe          BL       RTC_WriteBackupRegister
;;;337    		
;;;338    		// Backup SRAM **************************************************************
;;;339    //Enable BKPRAM Clock 
;;;340    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
000084  2101              MOVS     r1,#1
000086  048e              LSLS     r6,r1,#18
000088  4630              MOV      r0,r6
00008a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;341    
;;;342    //Enable the Backup SRAM low power Regulator to retain it's content in VBAT mode 
;;;343    //PWR_BackupRegulatorCmd(ENABLE);
;;;344    
;;;345    // Wait until the Backup SRAM low power Regulator is ready 
;;;346    //while(PWR_GetFlagStatus(PWR_FLAG_BRR) == RESET)
;;;347    {
;;;348    }
;;;349    
;;;350     {
;;;351    	 
;;;352    	 extern st_conf conf;
;;;353    	 u32 i=0,i1=0, errorindex=0;
00008e  2400              MOVS     r4,#0
;;;354    	 
;;;355       bkp=RTC_ReadBackupRegister(RTC_BKP_DR2);
000090  2002              MOVS     r0,#2
000092  f7fffffe          BL       RTC_ReadBackupRegister
000096  4d45              LDR      r5,|L2.428|
;;;356    
;;;357    
;;;358    //  Backup SRAM ************************************************************
;;;359      // Enable BKPRAM Clock 
;;;360      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
000098  2101              MOVS     r1,#1
00009a  8028              STRH     r0,[r5,#0]            ;355
00009c  4630              MOV      r0,r6
00009e  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;361    
;;;362    /*
;;;363      // Write to Backup SRAM with 32-Bit Data 
;;;364      for (i = 0; i < 0x1000; i += 4)
;;;365      {
;;;366        *(__IO uint32_t *) (BKPSRAM_BASE + i) = i;
;;;367      }
;;;368    */
;;;369    //	sizeof
;;;370      // read config rrom backup SRAM
;;;371    	 
;;;372    	 
;;;373    
;;;374    	/*
;;;375      for (i = 0; i < size; i += 2)
;;;376      {
;;;377    		(*(__IO uint16_t *) ((__IO uint16_t *) (&conf) + i))=(u16)i; //(*(__IO uint32_t *) (BKPSRAM_BASE + i));
;;;378    	}	
;;;379    */
;;;380    /*
;;;381    	conf.address=1;
;;;382    	conf.ver_po_st=2;
;;;383    	conf.ver_po_ml=3;
;;;384    	conf.tek_gr_kal=4;
;;;385    	conf.tm_antidreb=5;
;;;386    	conf.revers_group_select=6;
;;;387    	conf.revers_peredacha_select=7;
;;;388    	conf.rez8=8;
;;;389    	
;;;390    	conf.per_usr=9;
;;;391    	conf.time_max=10;
;;;392    	conf.por_rele=11;
;;;393    	conf.tm_rele_on=12;
;;;394    	conf.tm_rele_off=13;
;;;395    	conf.rez16=14;
;;;396    	
;;;397    	conf.indicators[0].numb=15;
;;;398    	conf.indicators[0].kol_cifr=16;
;;;399    	conf.indicators[1].numb=17;
;;;400    	conf.indicators[1].kol_cifr=18;
;;;401    	conf.indicators[2].numb=19;
;;;402    	conf.indicators[2].kol_cifr=20;
;;;403    	conf.indicators[3].numb=21;
;;;404    	conf.indicators[3].kol_cifr=2;
;;;405    	conf.gr_kal1.tabl1.kod[0]=23;
;;;406    	conf.gr_kal1.tabl1.fz[0]=24;
;;;407    	conf.gr_kal1.tabl2.kod[0]=25;
;;;408    	conf.gr_kal1.tabl2.fz[0]=26;
;;;409    	conf.gr_kal2.tabl1.kod[0]=27;
;;;410    	conf.gr_kal2.tabl1.fz[0]=28;
;;;411    	conf.gr_kal2.tabl2.kod[0]=29;
;;;412    	conf.gr_kal2.tabl2.fz[0]=30;
;;;413    	conf.gr_kal2.tabl2.kod[9]=31;
;;;414    	conf.gr_kal2.tabl2.fz[9]=32;
;;;415    */
;;;416    	size=sizeof(st_conf);
0000a2  21be              MOVS     r1,#0xbe
0000a4  8069              STRH     r1,[r5,#2]
;;;417    	
;;;418    	for (i = 0; i < size; i += 1)
;;;419      {
;;;420    		(*(__IO uint8_t *) ((__IO uint8_t *) (&conf) + i))=(*(__IO uint8_t *) (BKPSRAM_BASE + i));
0000a6  4842              LDR      r0,|L2.432|
0000a8  4d42              LDR      r5,|L2.436|
                  |L2.170|
0000aa  5c22              LDRB     r2,[r4,r0]
0000ac  552a              STRB     r2,[r5,r4]
0000ae  1c64              ADDS     r4,r4,#1              ;418
0000b0  428c              CMP      r4,r1                 ;418
0000b2  d3fa              BCC      |L2.170|
;;;421    	}	
;;;422    	
;;;423    		kol_usr=conf.per_usr;
0000b4  4940              LDR      r1,|L2.440|
0000b6  8928              LDRH     r0,[r5,#8]  ; conf
0000b8  f04f0401          MOV      r4,#1                 ;340
0000bc  8008              STRH     r0,[r1,#0]
;;;424    		conf.tm_antidreb=conf.tm_antidreb*10;
0000be  7928              LDRB     r0,[r5,#4]  ; conf
0000c0  eb000080          ADD      r0,r0,r0,LSL #2
0000c4  0640              LSLS     r0,r0,#25
0000c6  0e00              LSRS     r0,r0,#24
0000c8  7128              STRB     r0,[r5,#4]
;;;425    	
;;;426    		if (conf.tm_antidreb==0)
0000ca  d100              BNE      |L2.206|
;;;427    				conf.tm_antidreb=1;
0000cc  712c              STRB     r4,[r5,#4]
                  |L2.206|
;;;428    
;;;429    //	RCC_APB2PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE); 
;;;430    	GPIO_InitStructure.GPIO_Pin   = PIN_RELE;      		//  vivod RELE
;;;431    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    // rezim vivoda
0000ce  f88d4004          STRB     r4,[sp,#4]
;;;432    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
;;;433    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //speed
;;;434    	GPIO_Init(PORT_RELE, &GPIO_InitStructure); 
0000d2  f8dfb0e8          LDR      r11,|L2.444|
0000d6  f04f0a10          MOV      r10,#0x10             ;430
0000da  f88d4006          STRB     r4,[sp,#6]            ;432
0000de  2602              MOVS     r6,#2                 ;433
0000e0  f8cda000          STR      r10,[sp,#0]           ;431
0000e4  f88d6005          STRB     r6,[sp,#5]            ;433
0000e8  4669              MOV      r1,sp
0000ea  4658              MOV      r0,r11
0000ec  f7fffffe          BL       GPIO_Init
;;;435    
;;;436    	GPIO_InitStructure.GPIO_Pin   = PIN_L1;      		//  vivod svetodiod knopka 1
;;;437    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    // rezim vivoda
0000f0  f88d4004          STRB     r4,[sp,#4]
0000f4  2740              MOVS     r7,#0x40              ;436
;;;438    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
0000f6  f88d4006          STRB     r4,[sp,#6]
0000fa  9700              STR      r7,[sp,#0]            ;437
;;;439    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //speed
0000fc  f88d6005          STRB     r6,[sp,#5]
;;;440    	GPIO_Init(PORT_L1, &GPIO_InitStructure); 
000100  4669              MOV      r1,sp
000102  482f              LDR      r0,|L2.448|
000104  e000              B        |L2.264|
                  |L2.262|
000106  e045              B        |L2.404|
                  |L2.264|
000108  f7fffffe          BL       GPIO_Init
;;;441    	
;;;442    	GPIO_InitStructure.GPIO_Pin   = PIN_L2;      		  //  vivod svetodiod knopka 2
;;;443    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    // rezim vivoda
00010c  f88d4004          STRB     r4,[sp,#4]
000110  f44f7880          MOV      r8,#0x100             ;442
;;;444    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
000114  f88d4006          STRB     r4,[sp,#6]
000118  f8cd8000          STR      r8,[sp,#0]            ;443
;;;445    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //speed
00011c  f88d6005          STRB     r6,[sp,#5]
;;;446    	GPIO_Init(PORT_L2, &GPIO_InitStructure); 
000120  4669              MOV      r1,sp
000122  4827              LDR      r0,|L2.448|
000124  f7fffffe          BL       GPIO_Init
;;;447    
;;;448    	GPIO_InitStructure.GPIO_Pin   = PIN_K1;      		  //  vvod  knopka 1
;;;449    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;    // 	rezim vivoda
000128  f04f0900          MOV      r9,#0
00012c  2080              MOVS     r0,#0x80              ;448
00012e  f88d9004          STRB     r9,[sp,#4]
000132  9000              STR      r0,[sp,#0]
;;;450    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
000134  f88d4006          STRB     r4,[sp,#6]
;;;451    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //	speed
000138  f88d6005          STRB     r6,[sp,#5]
;;;452    	GPIO_Init(PORT_K1, &GPIO_InitStructure); 
00013c  4669              MOV      r1,sp
00013e  4820              LDR      r0,|L2.448|
000140  f7fffffe          BL       GPIO_Init
;;;453    	
;;;454    	GPIO_InitStructure.GPIO_Pin   = PIN_K2;      		  //  vvod  knopka 2
000144  0230              LSLS     r0,r6,#8
;;;455    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;    // 	rezim vivoda
000146  f88d9004          STRB     r9,[sp,#4]
00014a  9000              STR      r0,[sp,#0]
;;;456    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
00014c  f88d4006          STRB     r4,[sp,#6]
;;;457    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //	speed
000150  f88d6005          STRB     r6,[sp,#5]
;;;458    	GPIO_Init(PORT_K2, &GPIO_InitStructure); 
000154  4669              MOV      r1,sp
000156  481a              LDR      r0,|L2.448|
000158  f7fffffe          BL       GPIO_Init
;;;459    	
;;;460    	if (conf.tek_gr_kal==0)
;;;461    	{
;;;462    		//  dr kal ==0 - pervaya
;;;463    		PORT_L1->BSRRL = PIN_L1;  // on  PIN_L1
00015c  4818              LDR      r0,|L2.448|
00015e  78ea              LDRB     r2,[r5,#3]            ;460  ; conf
000160  3018              ADDS     r0,r0,#0x18
;;;464    	  PORT_L2->BSRRH = PIN_L2;	// off PIN_L2
000162  1c81              ADDS     r1,r0,#2
000164  b1c2              CBZ      r2,|L2.408|
;;;465    	}
;;;466    	else
;;;467    	{
;;;468    		//  dr kal ==1 - vtoraya
;;;469    		PORT_L1->BSRRH = PIN_L1;  // off  PIN_L1
000166  800f              STRH     r7,[r1,#0]
;;;470    	  PORT_L2->BSRRL = PIN_L2;	// on   PIN_L2
000168  f8a08000          STRH     r8,[r0,#0]
                  |L2.364|
;;;471    	}
;;;472          
;;;473    		sost_flesh=0;	
00016c  4815              LDR      r0,|L2.452|
;;;474    		PORT_ZAP_EN->BSRRH = PIN_ZAP_EN;  // off  PORT_ZAP_EN
00016e  f44f5200          MOV      r2,#0x2000
000172  f8809000          STRB     r9,[r0,#0]            ;473
000176  f8ab201a          STRH     r2,[r11,#0x1a]
;;;475    		PORT_ZAP_DIS->BSRRL = PIN_ZAP_DIS;  // on  PORT_ZAP_DIS
00017a  0052              LSLS     r2,r2,#1
00017c  f8ab2018          STRH     r2,[r11,#0x18]
;;;476    		
;;;477    		avariya=0;
000180  4a11              LDR      r2,|L2.456|
;;;478    		PORT_AVARIYA->BSRRH = PIN_AVARIYA;   
000182  f44f4100          MOV      r1,#0x8000
000186  f8829000          STRB     r9,[r2,#0]            ;477
00018a  f8ab101a          STRH     r1,[r11,#0x1a]
;;;479    	
;;;480    		PORT_RELE->BSRRH = PIN_RELE;	// on PIN_RELE	
00018e  f8aba01a          STRH     r10,[r11,#0x1a]
;;;481    	
;;;482    	/*
;;;483    		conf.por_rele
;;;484    	  conf.time_max
;;;485    	  conf.tm_antidreb
;;;486    		conf.tm_rele_off
;;;487    		conf.tm_rele_on
;;;488    		conf.
;;;489    	*/	
;;;490    	
;;;491    	/*
;;;492    	for (i = 0; i < size; i += 1)
;;;493      {
;;;494        *(__IO uint8_t *) (BKPSRAM_BASE + i) = 0;
;;;495      }
;;;496    	*/
;;;497    	
;;;498    	/*
;;;499    	for (i = 0; i < size; i += 1)
;;;500      {
;;;501        *(__IO uint8_t *) (BKPSRAM_BASE + i) = *(__IO uint8_t *) ((__IO uint8_t *) (&conf) + i);
;;;502      }
;;;503    	*/
;;;504    	
;;;505    	
;;;506    /*
;;;507    	conf.address=255;
;;;508    	conf.ver_po_st=255;
;;;509    	conf.ver_po_ml=255;
;;;510    	conf.per_usr=255;
;;;511    	conf.time_max=255;
;;;512    	conf.tek_gr_kal=255;
;;;513    	conf.gr_kal1.tabl1.fz[0]=255;
;;;514    	conf.gr_kal1.tabl1.kod[0]=255;
;;;515    	conf.gr_kal1.tabl2.fz[0]=255;
;;;516    	conf.gr_kal1.tabl2.kod[0]=255;
;;;517    	
;;;518    	conf.gr_kal2.tabl1.fz[0]=255;
;;;519    	conf.gr_kal2.tabl1.kod[0]=255;
;;;520    	conf.gr_kal2.tabl2.fz[0]=255;
;;;521    	conf.gr_kal2.tabl2.kod[0]=255;
;;;522    	conf.revers_group_select=255;
;;;523    	conf.revers_peredacha_select=255;
;;;524    	conf.tm_antidreb=255;
;;;525    	conf.por_rele=255;
;;;526    	conf.tm_rele_on=255;
;;;527    	conf.tm_rele_off=255;
;;;528    	conf.indicators[0].numb=255;
;;;529    	conf.indicators[0].kol_cifr=255;
;;;530    	conf.indicators[1].numb=255;
;;;531    	conf.indicators[1].kol_cifr=255;
;;;532    	conf.indicators[2].numb=255;
;;;533    	conf.indicators[2].kol_cifr=255;
;;;534    	conf.indicators[3].numb=255;
;;;535    	conf.indicators[3].kol_cifr=255;
;;;536    	*/
;;;537    	/*
;;;538    	// test read config to comp
;;;539    	conf.address=1;
;;;540    	conf.ver_po_st=2;
;;;541    	conf.ver_po_ml=3;
;;;542    	conf.tek_gr_kal=4;
;;;543    	conf.tm_antidreb=5;
;;;544    	conf.revers_group_select=6;
;;;545    	conf.revers_peredacha_select=7;
;;;546    	conf.rez8=8;
;;;547    	
;;;548    	conf.per_usr=9;
;;;549    	conf.time_max=10;
;;;550    	conf.por_rele=11;
;;;551    	conf.tm_rele_on=12;
;;;552    	conf.tm_rele_off=13;
;;;553    	conf.rez16=14;
;;;554    	
;;;555    	conf.indicators[0].numb=15;
;;;556    	conf.indicators[0].kol_cifr=16;
;;;557    	conf.indicators[1].numb=17;
;;;558    	conf.indicators[1].kol_cifr=18;
;;;559    	conf.indicators[2].numb=19;
;;;560    	conf.indicators[2].kol_cifr=20;
;;;561    	conf.indicators[3].numb=21;
;;;562    	conf.indicators[3].kol_cifr=2;
;;;563    	conf.gr_kal1.tabl1.kod[0]=23;
;;;564    	conf.gr_kal1.tabl1.fz[0]=24;
;;;565    	conf.gr_kal1.tabl2.kod[0]=25;
;;;566    	conf.gr_kal1.tabl2.fz[0]=26;
;;;567    	conf.gr_kal2.tabl1.kod[0]=27;
;;;568    	conf.gr_kal2.tabl1.fz[0]=28;
;;;569    	conf.gr_kal2.tabl2.kod[0]=29;
;;;570    	conf.gr_kal2.tabl2.fz[0]=30;
;;;571    	conf.gr_kal2.tabl2.kod[9]=31;
;;;572    	conf.gr_kal2.tabl2.fz[9]=32;
;;;573    	
;;;574    */
;;;575    	
;;;576    }
;;;577    	
;;;578    __ASM volatile ("nop");
000192  bf00              NOP      
                  |L2.404|
;;;579    
;;;580        
;;;581        // Всё, часы запустились и считают время.
;;;582    		/*
;;;583    		
;;;584    		/разрешить тактирование модулей управления питанием и управлением резервной областью
;;;585      RCC->APB1ENR |= RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN;
;;;586      //разрешить доступ к области резервных данных
;;;587      PWR->CR |= PWR_CR_DBP;
;;;588      //если часы выключены - инициализировать их
;;;589      if ((RCC->BDCR & RCC_BDCR_RTCEN) != RCC_BDCR_RTCEN)
;;;590      {
;;;591        //выполнить сброс области резервных данных
;;;592        RCC->BDCR |=  RCC_BDCR_BDRST;
;;;593        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;594     
;;;595        //выбрать источником тактовых импульсов внешний кварц 32768 и подать тактирование
;;;596        RCC->BDCR |=  RCC_BDCR_RTCEN | RCC_BDCR_RTCSEL_LSE;
;;;597     
;;;598        RTC->CRL  |=  RTC_CRL_CNF;
;;;599        RTC->PRLL  = 0x7FFF;         //регистр деления на 32768
;;;600        RTC->CRL  &=  ~RTC_CRL_CNF;
;;;601     
;;;602        //установить бит разрешения работы и дождаться установки бита готовности
;;;603        RCC->BDCR |= RCC_BDCR_LSEON;
;;;604        while ((RCC->BDCR & RCC_BDCR_LSEON) != RCC_BDCR_LSEON){}
;;;605     
;;;606        RTC->CRL &= (uint16_t)~RTC_CRL_RSF;
;;;607        while((RTC->CRL & RTC_CRL_RSF) != RTC_CRL_RSF){}
;;;608     
;;;609        return 1;
;;;610      }
;;;611      return 0;
;;;612    	*/
;;;613    	
;;;614    	
;;;615    	/*
;;;616    	
;;;617    	// one more init кес
;;;618    	
;;;619    	RTC_InitTypeDef RTC_InitStructure;
;;;620    RTC_TimeTypeDef RTC_TimeStructure;
;;;621    RTC_DateTypeDef RTC_DateStructure;
;;;622    __IO uint32_t AsynchPrediv = 0, SynchPrediv = 0;
;;;623    __IO uint32_t TimeDisplay = 0;
;;;624    
;;;625    
;;;626    		// Enable the PWR APB1 Clock Interface 
;;;627    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
;;;628    
;;;629    //Allow access to BKP Domain 
;;;630    PWR_BackupAccessCmd(ENABLE);
;;;631      
;;;632    if (RTC_ReadBackupRegister(RTC_BKP_DR2) != 0xA5A5) {
;;;633    
;;;634    //Enable the PWR clock 
;;;635    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
;;;636    
;;;637    // Allow access to RTC 
;;;638    PWR_BackupAccessCmd(ENABLE);
;;;639    
;;;640    #if defined (RTC_CLOCK_SOURCE_LSI) // LSI used as RTC source clock
;;;641    // The RTC Clock may varies due to LSI frequency dispersion. 
;;;642    // Enable the LSI OSC 
;;;643    RCC_LSICmd(ENABLE);
;;;644    
;;;645    // Wait till LSI is ready 
;;;646    while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
;;;647    {
;;;648    }
;;;649    
;;;650    // Select the RTC Clock Source 
;;;651    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
;;;652    
;;;653    SynchPrediv = 0xFF;
;;;654    AsynchPrediv = 0x7F;
;;;655    
;;;656    #elif defined (RTC_CLOCK_SOURCE_LSE) // LSE used as RTC source clock 
;;;657    // Enable the LSE OSC 
;;;658    RCC_LSEConfig(RCC_LSE_ON);
;;;659    
;;;660    // Wait till LSE is ready 
;;;661    while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
;;;662    {
;;;663    }
;;;664    
;;;665    // Select the RTC Clock Source 
;;;666    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
;;;667    
;;;668    SynchPrediv = 0xFF;
;;;669    AsynchPrediv = 0x7F;
;;;670    
;;;671    #else
;;;672    #error Please select the RTC Clock source inside the main.c file
;;;673    #endif // RTC_CLOCK_SOURCE_LSI 
;;;674    
;;;675    // Enable the RTC Clock 
;;;676    RCC_RTCCLKCmd(ENABLE);
;;;677    
;;;678    // Wait for RTC APB registers synchronisation 
;;;679    RTC_WaitForSynchro();
;;;680    
;;;681    // Allow access to BKP Domain 
;;;682    PWR_BackupAccessCmd(ENABLE);
;;;683    
;;;684    // Write to the first RTC Backup Data Register 
;;;685    RTC_WriteBackupRegister(RTC_BKP_DR2,0xA5A5);
;;;686    
;;;687    //Set the Time 
;;;688    RTC_TimeStructure.RTC_Hours = 22;
;;;689    RTC_TimeStructure.RTC_Minutes = 11;
;;;690    RTC_TimeStructure.RTC_Seconds = 00;
;;;691    
;;;692    // Set the Date 
;;;693    RTC_DateStructure.RTC_Month = 4;
;;;694    RTC_DateStructure.RTC_Date = 29;
;;;695    RTC_DateStructure.RTC_Year = 11;
;;;696    RTC_DateStructure.RTC_WeekDay = RTC_Weekday_Friday;
;;;697    
;;;698    //Calendar Configuration 
;;;699    RTC_InitStructure.RTC_AsynchPrediv = AsynchPrediv;
;;;700    RTC_InitStructure.RTC_SynchPrediv = SynchPrediv;
;;;701    RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24;
;;;702    RTC_Init(&RTC_InitStructure);
;;;703    
;;;704    // Set Current Time and Date 
;;;705    RTC_SetTime(RTC_Format_BIN, &RTC_TimeStructure);
;;;706    RTC_SetDate(RTC_Format_BIN, &RTC_DateStructure);
;;;707    #if 0
;;;708    //Configure the RTC Wakeup Clock source and Counter (Wakeup event each 1 second) 
;;;709    RTC_WakeUpClockConfig(RTC_WakeUpClock_RTCCLK_Div16);
;;;710    RTC_SetWakeUpCounter(0x7FF);
;;;711    
;;;712    // Enable the Wakeup Interrupt 
;;;713    RTC_ITConfig(RTC_IT_WUT, ENABLE);
;;;714    
;;;715    //Enable Wakeup Counter 
;;;716    RTC_WakeUpCmd(ENABLE);
;;;717    #endif
;;;718    // Backup SRAM **************************************************************
;;;719    //Enable BKPRAM Clock 
;;;720    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
;;;721    
;;;722    //Enable the Backup SRAM low power Regulator to retain it's content in VBAT mode 
;;;723    PWR_BackupRegulatorCmd(ENABLE);
;;;724    
;;;725    // Wait until the Backup SRAM low power Regulator is ready 
;;;726    while(PWR_GetFlagStatus(PWR_FLAG_BRR) == RESET)
;;;727    {
;;;728    }
;;;729    
;;;730    }
;;;731    else{
;;;732    
;;;733    // Enable the PWR clock 
;;;734    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
;;;735    
;;;736    // Allow access to RTC 
;;;737    PWR_BackupAccessCmd(ENABLE);
;;;738    
;;;739    // Wait for RTC APB registers synchronisation 
;;;740    RTC_WaitForSynchro();
;;;741    // Clear the Wakeup Interrupt 
;;;742    RTC_ClearITPendingBit(RTC_IT_WUT);
;;;743    
;;;744    // Backup SRAM **************************************************************
;;;745    // Enable BKPSRAM Clock 
;;;746    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
;;;747    }
;;;748    
;;;749    
;;;750    	
;;;751    	*/
;;;752    	
;;;753    }
000194  e8bd9ffc          POP      {r2-r12,pc}
                  |L2.408|
000198  8007              STRH     r7,[r0,#0]            ;463
00019a  f8a18000          STRH     r8,[r1,#0]            ;464
00019e  e7e5              B        |L2.364|
;;;754    
                          ENDP

                  |L2.416|
                          DCD      0x4000280c
                  |L2.420|
                          DCD      0x40023840
                  |L2.424|
                          DCD      0x40007000
                  |L2.428|
                          DCD      ||.data||
                  |L2.432|
                          DCD      0x40024000
                  |L2.436|
                          DCD      conf
                  |L2.440|
                          DCD      kol_usr
                  |L2.444|
                          DCD      0x40020000
                  |L2.448|
                          DCD      0x40020800
                  |L2.452|
                          DCD      sost_flesh
                  |L2.456|
                          DCD      avariya

                          AREA ||i.rtc_Lock||, CODE, READONLY, ALIGN=2

                  rtc_Lock PROC
;;;24     // Включить защиту от записи
;;;25      void rtc_Lock(void)
000000  4901              LDR      r1,|L3.8|
;;;26     {
;;;27         // Запишем какую-нибудь фигню, главное, чтоб не правильную
;;;28         RTC->WPR = 0xFF;
000002  20ff              MOVS     r0,#0xff
000004  6008              STR      r0,[r1,#0]
;;;29     }
000006  4770              BX       lr
;;;30     
                          ENDP

                  |L3.8|
                          DCD      0x40002824

                          AREA ||i.rtc_Reset||, CODE, READONLY, ALIGN=2

                  rtc_Reset PROC
;;;112    // Сброс состояния часов
;;;113    void rtc_Reset(void)
000000  480a              LDR      r0,|L4.44|
;;;114    {
;;;115        // Включим тактирование PWR
;;;116        RCC->APB1ENR |= RCC_APB1ENR_PWREN;
000002  6801              LDR      r1,[r0,#0]
000004  f0415180          ORR      r1,r1,#0x10000000
000008  6001              STR      r1,[r0,#0]
;;;117        
;;;118        // Разрешим доступ к управляющим регистрам энергонезависимого домена
;;;119        PWR->CR |= PWR_CR_DBP;
00000a  4809              LDR      r0,|L4.48|
00000c  6801              LDR      r1,[r0,#0]
00000e  f4417180          ORR      r1,r1,#0x100
000012  6001              STR      r1,[r0,#0]
;;;120        
;;;121        // Выберем его как источник тактирования RTC:
;;;122        RCC->BDCR |=  RCC_BDCR_BDRST;
000014  4805              LDR      r0,|L4.44|
000016  3030              ADDS     r0,r0,#0x30
000018  6801              LDR      r1,[r0,#0]
00001a  f4413180          ORR      r1,r1,#0x10000
00001e  6001              STR      r1,[r0,#0]
;;;123        RCC->BDCR &= ~RCC_BDCR_BDRST;
000020  6801              LDR      r1,[r0,#0]
000022  f4213180          BIC      r1,r1,#0x10000
000026  6001              STR      r1,[r0,#0]
;;;124    }
000028  4770              BX       lr
;;;125    
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      0x40023840
                  |L4.48|
                          DCD      0x40007000

                          AREA ||i.rtc_SetDate||, CODE, READONLY, ALIGN=2

                  rtc_SetDate PROC
;;;31     // Установить дату
;;;32     void rtc_SetDate(uint8_t Day, uint8_t Month, uint8_t Year, uint8_t DayOfWeek)
000000  b5f0              PUSH     {r4-r7,lr}
;;;33     {
;;;34         uint32_t Tens, Units;
;;;35         uint32_t TempReg = 0;
;;;36         
;;;37         // Очистим поле даты
;;;38         TempReg = 0;
;;;39         
;;;40         // Запишем год
;;;41         {
;;;42             Tens  = (Year / 10) & 0x0f;          // Десятки лет
000002  260a              MOVS     r6,#0xa
000004  fbb2f4f6          UDIV     r4,r2,r6
000008  f004040f          AND      r4,r4,#0xf
;;;43             Units = (Year - (Tens * 10)) & 0x0f; // Единицы лет
00000c  4265              RSBS     r5,r4,#0
00000e  eb050585          ADD      r5,r5,r5,LSL #2
000012  2700              MOVS     r7,#0                 ;35
000014  eb020245          ADD      r2,r2,r5,LSL #1
000018  f002020f          AND      r2,r2,#0xf
;;;44             
;;;45             TempReg |= (Tens  << 20); // YT, 20
00001c  ea475404          ORR      r4,r7,r4,LSL #20
;;;46             TempReg |= (Units << 16); // YU, 16
000020  ea444502          ORR      r5,r4,r2,LSL #16
;;;47         }
;;;48         // Запишем месяц
;;;49         {
;;;50             Tens  = (Month / 10) & 0x01;          // Десятки месяцев
000024  fbb1f2f6          UDIV     r2,r1,r6
000028  f0020201          AND      r2,r2,#1
;;;51             Units = (Month - (Tens * 10)) & 0x0f; // Единицы месяцев
00002c  4254              RSBS     r4,r2,#0
00002e  eb040484          ADD      r4,r4,r4,LSL #2
000032  eb010144          ADD      r1,r1,r4,LSL #1
000036  f001010f          AND      r1,r1,#0xf
;;;52             
;;;53             TempReg |= (Tens  << 12); // MT, 12
00003a  ea453202          ORR      r2,r5,r2,LSL #12
;;;54             TempReg |= (Units << 8);  // MU, 8
00003e  ea422401          ORR      r4,r2,r1,LSL #8
;;;55         }
;;;56         // Запишем день
;;;57         {
;;;58             Tens  = (Day / 10) & 0x03;          // Десятки дней
000042  fbb0f1f6          UDIV     r1,r0,r6
000046  f0010103          AND      r1,r1,#3
;;;59             Units = (Day - (Tens * 10)) & 0x0f; // Единицы дней
00004a  424a              RSBS     r2,r1,#0
00004c  eb020282          ADD      r2,r2,r2,LSL #2
000050  eb000042          ADD      r0,r0,r2,LSL #1
000054  f000020f          AND      r2,r0,#0xf
;;;60             
;;;61             TempReg |= (Tens  << 4); // DT, 4
000058  ea441001          ORR      r0,r4,r1,LSL #4
;;;62             TempReg |= (Units << 0);  // DU, 0
00005c  4310              ORRS     r0,r0,r2
;;;63         }
;;;64         // День недели:
;;;65         {
;;;66             TempReg |= ((DayOfWeek & 0x07) << 13); // WDU, 13
00005e  f0030107          AND      r1,r3,#7
000062  ea403041          ORR      r0,r0,r1,LSL #13
;;;67         }
;;;68         
;;;69         // Записывать надо всё сразу
;;;70         RTC->DR = TempReg;
000066  4901              LDR      r1,|L5.108|
000068  6008              STR      r0,[r1,#0]
;;;71     }
00006a  bdf0              POP      {r4-r7,pc}
;;;72     
                          ENDP

                  |L5.108|
                          DCD      0x40002804

                          AREA ||i.rtc_SetTime||, CODE, READONLY, ALIGN=2

                  rtc_SetTime PROC
;;;74     //static void rtc_SetTime(uint8_t Hours, uint8_t Minutes, uint8_t Seconds)
;;;75     void rtc_SetTime(uint8_t Hours, uint8_t Minutes, uint8_t Seconds)
000000  b570              PUSH     {r4-r6,lr}
;;;76     {
;;;77         uint32_t Tens, Units;
;;;78         uint32_t TempReg = 0;
;;;79         
;;;80         // Очистим поле даты
;;;81         TempReg = 0;
;;;82         
;;;83         // Запишем часы
;;;84         {
;;;85             Tens  = (Hours / 10) & 0x03;          // Десятки часов
000002  250a              MOVS     r5,#0xa
000004  fbb0f3f5          UDIV     r3,r0,r5
000008  f0030303          AND      r3,r3,#3
;;;86             Units = (Hours - (Tens * 10)) & 0x0f; // Единицы часов
00000c  425c              RSBS     r4,r3,#0
00000e  eb040484          ADD      r4,r4,r4,LSL #2
000012  2600              MOVS     r6,#0                 ;78
000014  eb000044          ADD      r0,r0,r4,LSL #1
000018  f000000f          AND      r0,r0,#0xf
;;;87             
;;;88             TempReg |= (Tens  << 20); // HT, 20
00001c  ea465303          ORR      r3,r6,r3,LSL #20
;;;89             TempReg |= (Units << 16); // HU, 16
000020  ea434400          ORR      r4,r3,r0,LSL #16
;;;90         }
;;;91         // Запишем минуты
;;;92         {
;;;93             Tens  = (Minutes / 10) & 0x07;          // Десятки минут
000024  fbb1f0f5          UDIV     r0,r1,r5
000028  f0000007          AND      r0,r0,#7
;;;94             Units = (Minutes - (Tens * 10)) & 0x0f; // Единицы минут
00002c  4243              RSBS     r3,r0,#0
00002e  eb030383          ADD      r3,r3,r3,LSL #2
000032  eb010143          ADD      r1,r1,r3,LSL #1
000036  f001010f          AND      r1,r1,#0xf
;;;95             
;;;96             TempReg |= (Tens  << 12); // MNT, 12
00003a  ea443000          ORR      r0,r4,r0,LSL #12
;;;97             TempReg |= (Units << 8);  // MNU, 8
00003e  ea402301          ORR      r3,r0,r1,LSL #8
;;;98         }
;;;99         // Запишем секунды
;;;100        {
;;;101            Tens  = (Seconds / 10) & 0x07;          // Десятки секунд
000042  fbb2f0f5          UDIV     r0,r2,r5
000046  f0000007          AND      r0,r0,#7
;;;102            Units = (Seconds - (Tens * 10)) & 0x0f; // Единицы секунд
00004a  4241              RSBS     r1,r0,#0
00004c  eb010181          ADD      r1,r1,r1,LSL #2
000050  eb020141          ADD      r1,r2,r1,LSL #1
000054  f001010f          AND      r1,r1,#0xf
;;;103            
;;;104            TempReg |= (Tens  << 4); // ST, 4
000058  ea431000          ORR      r0,r3,r0,LSL #4
;;;105            TempReg |= (Units << 0);  // SU, 0
00005c  4308              ORRS     r0,r0,r1
;;;106        }
;;;107        
;;;108        // Записывать надо всё сразу
;;;109        RTC->TR = TempReg;
00005e  4901              LDR      r1,|L6.100|
000060  6008              STR      r0,[r1,#0]
;;;110    }
000062  bd70              POP      {r4-r6,pc}
;;;111    
                          ENDP

                  |L6.100|
                          DCD      0x40002800

                          AREA ||i.rtc_Unlock||, CODE, READONLY, ALIGN=2

                  rtc_Unlock PROC
;;;16     // Выключить защиту от записи
;;;17     void rtc_Unlock(void)
000000  4802              LDR      r0,|L7.12|
;;;18     {
;;;19         // Запишем эти значения по очереди
;;;20         RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6001              STR      r1,[r0,#0]
;;;21         RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6001              STR      r1,[r0,#0]
;;;22     }
00000a  4770              BX       lr
;;;23     
                          ENDP

                  |L7.12|
                          DCD      0x40002824

                          AREA ||.data||, DATA, ALIGN=1

                  bkp
000000  0000              DCW      0x0000
                  size
000002  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "src\\rtc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_rtc_c_bkp____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___5_rtc_c_bkp____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_rtc_c_bkp____REVSH|
#line 128
|__asm___5_rtc_c_bkp____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
