; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\MEDIA_USB_KEY\rtc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\MEDIA_USB_KEY\rtc.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\MEDIA_USB_KEY\rtc.crf src\rtc.c]
                          THUMB

                          AREA ||i.rtc_Get||, CODE, READONLY, ALIGN=2

                  rtc_Get PROC
;;;658    // Получить текущее время
;;;659    void rtc_Get(TDateTime * DateTime)
000000  4921              LDR      r1,|L1.136|
;;;660    {
000002  b510              PUSH     {r4,lr}
;;;661        uint32_t Date = RTC->DR;
000004  6809              LDR      r1,[r1,#0]
;;;662        uint32_t Time = RTC->TR;
000006  4a20              LDR      r2,|L1.136|
000008  1f12              SUBS     r2,r2,#4
00000a  6812              LDR      r2,[r2,#0]
;;;663        
;;;664        // Очистим
;;;665        memset(DateTime, 0, sizeof(*DateTime));
00000c  2300              MOVS     r3,#0
00000e  6003              STR      r3,[r0,#0]
000010  8083              STRH     r3,[r0,#4]
;;;666        
;;;667        // Год
;;;668        DateTime->Year      = ((Date >> 20) & 0x0f) * 10 + ((Date >> 16) & 0x0f);
000012  f3c15303          UBFX     r3,r1,#20,#4
000016  eb030383          ADD      r3,r3,r3,LSL #2
00001a  f3c14403          UBFX     r4,r1,#16,#4
00001e  eb040343          ADD      r3,r4,r3,LSL #1
000022  7003              STRB     r3,[r0,#0]
;;;669        // Месяц
;;;670        DateTime->Month     = ((Date >> 12) & 0x01) * 10 + ((Date >>  8) & 0x0f);
000024  f3c13300          UBFX     r3,r1,#12,#1
000028  eb030383          ADD      r3,r3,r3,LSL #2
00002c  f3c12403          UBFX     r4,r1,#8,#4
000030  eb040343          ADD      r3,r4,r3,LSL #1
000034  7043              STRB     r3,[r0,#1]
;;;671        // День
;;;672        DateTime->Day       = ((Date >>  4) & 0x03) * 10 + ((Date >>  0) & 0x0f);
000036  f3c11301          UBFX     r3,r1,#4,#2
00003a  f001040f          AND      r4,r1,#0xf
00003e  eb030383          ADD      r3,r3,r3,LSL #2
000042  eb040343          ADD      r3,r4,r3,LSL #1
000046  7083              STRB     r3,[r0,#2]
;;;673        // День недели
;;;674        DateTime->DayOfWeek = ((Date >> 13) & 0x07);
000048  f3c13142          UBFX     r1,r1,#13,#3
00004c  70c1              STRB     r1,[r0,#3]
;;;675        
;;;676        // Час
;;;677        DateTime->Hours     = ((Time >> 20) & 0x03) * 10 + ((Time >> 16) & 0x0f);
00004e  f3c25101          UBFX     r1,r2,#20,#2
000052  eb010181          ADD      r1,r1,r1,LSL #2
000056  f3c24303          UBFX     r3,r2,#16,#4
00005a  eb030141          ADD      r1,r3,r1,LSL #1
00005e  7101              STRB     r1,[r0,#4]
;;;678        // Минуты
;;;679        DateTime->Minutes   = ((Time >> 12) & 0x07) * 10 + ((Time >> 8) & 0x0f);
000060  f3c23102          UBFX     r1,r2,#12,#3
000064  eb010181          ADD      r1,r1,r1,LSL #2
000068  f3c22303          UBFX     r3,r2,#8,#4
00006c  eb030141          ADD      r1,r3,r1,LSL #1
000070  7141              STRB     r1,[r0,#5]
;;;680        // Секунды
;;;681        DateTime->Seconds   = ((Time >> 4) & 0x07) * 10 + ((Time >> 0) & 0x0f);
000072  f3c21102          UBFX     r1,r2,#4,#3
000076  f002030f          AND      r3,r2,#0xf
00007a  eb010181          ADD      r1,r1,r1,LSL #2
00007e  eb030141          ADD      r1,r3,r1,LSL #1
000082  7181              STRB     r1,[r0,#6]
;;;682    }
000084  bd10              POP      {r4,pc}
                          ENDP

000086  0000              DCW      0x0000
                  |L1.136|
                          DCD      0x40002804

                          AREA ||i.rtc_Init||, CODE, READONLY, ALIGN=2

                  rtc_Init PROC
;;;126    // Инициализация модуля
;;;127    void rtc_Init(void)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;128    {
;;;129    	  GPIO_InitTypeDef      GPIO_InitStructure;
;;;130    	
;;;131        // Если часы запущены, делать тут нечего.
;;;132        if(RTC->ISR & RTC_ISR_INITS) return;
000004  4a6d              LDR      r2,|L2.444|
000006  6810              LDR      r0,[r2,#0]
000008  06c0              LSLS     r0,r0,#27
00000a  d47d              BMI      |L2.264|
;;;133        
;;;134        // Включим тактирование PWR
;;;135        RCC->APB1ENR |= RCC_APB1ENR_PWREN;
00000c  486c              LDR      r0,|L2.448|
00000e  6801              LDR      r1,[r0,#0]
000010  f0415180          ORR      r1,r1,#0x10000000
000014  6001              STR      r1,[r0,#0]
;;;136        
;;;137        // Разрешим доступ к управляющим регистрам энергонезависимого домена
;;;138        PWR->CR |= PWR_CR_DBP;
000016  486b              LDR      r0,|L2.452|
000018  6801              LDR      r1,[r0,#0]
00001a  f4417180          ORR      r1,r1,#0x100
00001e  6001              STR      r1,[r0,#0]
;;;139       
;;;140    /*
;;;141    	 //  start LSE
;;;142    		RCC->BDCR |= RCC_BDCR_LSEON;
;;;143    		while ((RCC->BDCR & RCC_BDCR_LSEON) != RCC_BDCR_LSEON) {}
;;;144    		
;;;145    		RCC->BDCR |=  RCC_BDCR_BDRST;
;;;146        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;147    		
;;;148    	// Выберем его как источник тактирования RTC:
;;;149        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
;;;150        RCC->BDCR |= (RCC_BDCR_RTCSEL_0); // запишем 0b10
;;;151    		
;;;152    		   // Включим тактирование RTC
;;;153        RCC->BDCR |= RCC_BDCR_RTCEN;
;;;154    */
;;;155    
;;;156        // Запускаем LSI:
;;;157        RCC->CSR |= RCC_CSR_LSION;
000020  4867              LDR      r0,|L2.448|
000022  3034              ADDS     r0,r0,#0x34
000024  6801              LDR      r1,[r0,#0]
000026  f0410101          ORR      r1,r1,#1
00002a  6001              STR      r1,[r0,#0]
                  |L2.44|
;;;158        
;;;159        // Ждём, когда он заведётся
;;;160        while(!(RCC->CSR & RCC_CSR_LSIRDY)) {}
00002c  6801              LDR      r1,[r0,#0]
00002e  0789              LSLS     r1,r1,#30
000030  d5fc              BPL      |L2.44|
;;;161        
;;;162        // Ок, генератор на 32 кГц завёлся.
;;;163        
;;;164        // Сбросим состояние энергонезависимого домена
;;;165        RCC->BDCR |=  RCC_BDCR_BDRST;
000032  4863              LDR      r0,|L2.448|
000034  3030              ADDS     r0,r0,#0x30
000036  6801              LDR      r1,[r0,#0]
000038  f4413180          ORR      r1,r1,#0x10000
00003c  6001              STR      r1,[r0,#0]
;;;166        RCC->BDCR &= ~RCC_BDCR_BDRST;
00003e  6801              LDR      r1,[r0,#0]
000040  f4213180          BIC      r1,r1,#0x10000
000044  6001              STR      r1,[r0,#0]
;;;167        
;;;168        // Выберем его как источник тактирования RTC:
;;;169        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
000046  6801              LDR      r1,[r0,#0]
000048  f4217140          BIC      r1,r1,#0x300
00004c  6001              STR      r1,[r0,#0]
;;;170        RCC->BDCR |= (RCC_BDCR_RTCSEL_1); // запишем 0b10
00004e  6801              LDR      r1,[r0,#0]
000050  f4417100          ORR      r1,r1,#0x200
000054  6001              STR      r1,[r0,#0]
;;;171          
;;;172        // Включим тактирование RTC
;;;173        RCC->BDCR |= RCC_BDCR_RTCEN;
000056  6801              LDR      r1,[r0,#0]
000058  f4414100          ORR      r1,r1,#0x8000
00005c  6001              STR      r1,[r0,#0]
;;;174     
;;;175    
;;;176    /*
;;;177    ● Access to the backup SRAM
;;;178    1. Enable the power interface clock by setting the PWREN bits in the RCC APB1
;;;179    peripheral clock enable register (RCC_APB1ENR)
;;;180    2. Set the DBP bit in the PWR power control register (PWR_CR) to enable access to the
;;;181    backup domain
;;;182    3. Enable the backup SRAM clock by setting BKPSRAMEN bit in the RCC AHB1
;;;183    peripheral clock register (RCC_AHB1ENR)
;;;184    
;;;185    uint8_t *BKPRam = (uint8_t *)0x40024000;
;;;186    
;;;187    
;;;188    */			
;;;189        // Снимем защиту от записи с регистров RTC
;;;190        rtc_Unlock();
00005e  f7fffffe          BL       rtc_Unlock
;;;191        {
;;;192            // Здесь можем менять регистры RTC
;;;193    
;;;194            // Войдём в режим инициализации:
;;;195            RTC->ISR |= RTC_ISR_INIT;
000062  6810              LDR      r0,[r2,#0]
000064  f0400080          ORR      r0,r0,#0x80
000068  6010              STR      r0,[r2,#0]
                  |L2.106|
;;;196            
;;;197            // Ждём, когда это произойдёт
;;;198    
;;;199    
;;;200    
;;;201    			while(!(RTC->ISR & RTC_ISR_INITF)) {}
00006a  6810              LDR      r0,[r2,#0]
00006c  0640              LSLS     r0,r0,#25
00006e  d5fc              BPL      |L2.106|
;;;202            
;;;203            // Часы остановлены. Режим инициализации
;;;204            // Настроим предделитель для получения частоты 1 Гц.
;;;205            
;;;206            // LSI: 
;;;207            // LSE: нужно разделить на 0x7fff (кварцы так точно рассчитаны на это)
;;;208            {  //  32768Hz, а нам нужны
;;;209                uint32_t Sync = 263;   // 15 бит
;;;210                uint32_t Async =127;  // 7 бит
;;;211                
;;;212                // Сначала записываем величину для синхронного предделителя
;;;213                RTC->PRER = Sync;
000070  4952              LDR      r1,|L2.444|
000072  f2401007          MOV      r0,#0x107             ;209
000076  1d09              ADDS     r1,r1,#4
000078  6008              STR      r0,[r1,#0]
;;;214                
;;;215                // Теперь добавим для асинхронного предделителя
;;;216                RTC->PRER =Sync | (Async << 16);
00007a  4853              LDR      r0,|L2.456|
00007c  6008              STR      r0,[r1,#0]
;;;217    					
;;;218    			//		RTC->PRER = 0x00000000; // RESET PRER register
;;;219    			//		RTC->PRER |= (0xFF<<0); // 255 + 1 Synchronous prescaler factor set
;;;220    			//		RTC->PRER |= (0x7F<<16); // 127 + 1 Asynchronous prescaler factor set
;;;221            }
;;;222            
;;;223            // Устанавливаем дату: 30.05.13, пятница
;;;224     //       rtc_SetDate(2, 6, 13, 7);
;;;225            
;;;226            // Устанавливаем время: 15:00:00
;;;227      //      rtc_SetTime(0, 0, 00);
;;;228            
;;;229            // Переведём часы в 24-часовой формат
;;;230            RTC->CR |= RTC_CR_FMT;
00007e  484f              LDR      r0,|L2.444|
000080  1f00              SUBS     r0,r0,#4
000082  6801              LDR      r1,[r0,#0]
000084  f0410140          ORR      r1,r1,#0x40
000088  6001              STR      r1,[r0,#0]
;;;231            
;;;232            // Инициализация закончилась
;;;233            RTC->ISR &= ~RTC_ISR_INIT;
00008a  6810              LDR      r0,[r2,#0]
00008c  f0200080          BIC      r0,r0,#0x80
000090  6010              STR      r0,[r2,#0]
000092  494a              LDR      r1,|L2.444|
000094  20ff              MOVS     r0,#0xff
000096  3118              ADDS     r1,r1,#0x18
000098  6008              STR      r0,[r1,#0]
;;;234        }   
;;;235        rtc_Lock();
;;;236    		
;;;237    		// Allow access to BKP Domain 
;;;238    //PWR_BackupAccessCmd(ENABLE);
;;;239    
;;;240    // Write to the first RTC Backup Data Register 
;;;241    RTC_WriteBackupRegister(RTC_BKP_DR2,0xA5A5);
00009a  f24a51a5          MOV      r1,#0xa5a5
00009e  2002              MOVS     r0,#2
0000a0  f7fffffe          BL       RTC_WriteBackupRegister
;;;242    		
;;;243    		// Backup SRAM **************************************************************
;;;244    //Enable BKPRAM Clock 
;;;245    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
0000a4  2101              MOVS     r1,#1
0000a6  048e              LSLS     r6,r1,#18
0000a8  4630              MOV      r0,r6
0000aa  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;246    
;;;247    //Enable the Backup SRAM low power Regulator to retain it's content in VBAT mode 
;;;248    //PWR_BackupRegulatorCmd(ENABLE);
;;;249    
;;;250    // Wait until the Backup SRAM low power Regulator is ready 
;;;251    //while(PWR_GetFlagStatus(PWR_FLAG_BRR) == RESET)
;;;252    {
;;;253    }
;;;254    
;;;255     {
;;;256    	 
;;;257    	 extern st_conf conf;
;;;258    	 u32 i=0,i1=0, errorindex=0;
0000ae  2400              MOVS     r4,#0
;;;259    	 
;;;260       bkp=RTC_ReadBackupRegister(RTC_BKP_DR2);
0000b0  2002              MOVS     r0,#2
0000b2  f7fffffe          BL       RTC_ReadBackupRegister
0000b6  4d45              LDR      r5,|L2.460|
;;;261    
;;;262    
;;;263    //  Backup SRAM ************************************************************
;;;264      // Enable BKPRAM Clock 
;;;265      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
0000b8  2101              MOVS     r1,#1
0000ba  8028              STRH     r0,[r5,#0]            ;260
0000bc  4630              MOV      r0,r6
0000be  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;266    
;;;267    /*
;;;268      // Write to Backup SRAM with 32-Bit Data 
;;;269      for (i = 0; i < 0x1000; i += 4)
;;;270      {
;;;271        *(__IO uint32_t *) (BKPSRAM_BASE + i) = i;
;;;272      }
;;;273    */
;;;274    //	sizeof
;;;275      // read config rrom backup SRAM
;;;276    	 
;;;277    	 
;;;278    
;;;279    	/*
;;;280      for (i = 0; i < size; i += 2)
;;;281      {
;;;282    		(*(__IO uint16_t *) ((__IO uint16_t *) (&conf) + i))=(u16)i; //(*(__IO uint32_t *) (BKPSRAM_BASE + i));
;;;283    	}	
;;;284    */
;;;285    /*
;;;286    	conf.address=1;
;;;287    	conf.ver_po_st=2;
;;;288    	conf.ver_po_ml=3;
;;;289    	conf.tek_gr_kal=4;
;;;290    	conf.tm_antidreb=5;
;;;291    	conf.revers_group_select=6;
;;;292    	conf.revers_peredacha_select=7;
;;;293    	conf.rez8=8;
;;;294    	
;;;295    	conf.per_usr=9;
;;;296    	conf.time_max=10;
;;;297    	conf.por_rele=11;
;;;298    	conf.tm_rele_on=12;
;;;299    	conf.tm_rele_off=13;
;;;300    	conf.rez16=14;
;;;301    	
;;;302    	conf.indicators[0].numb=15;
;;;303    	conf.indicators[0].kol_cifr=16;
;;;304    	conf.indicators[1].numb=17;
;;;305    	conf.indicators[1].kol_cifr=18;
;;;306    	conf.indicators[2].numb=19;
;;;307    	conf.indicators[2].kol_cifr=20;
;;;308    	conf.indicators[3].numb=21;
;;;309    	conf.indicators[3].kol_cifr=2;
;;;310    	conf.gr_kal1.tabl1.kod[0]=23;
;;;311    	conf.gr_kal1.tabl1.fz[0]=24;
;;;312    	conf.gr_kal1.tabl2.kod[0]=25;
;;;313    	conf.gr_kal1.tabl2.fz[0]=26;
;;;314    	conf.gr_kal2.tabl1.kod[0]=27;
;;;315    	conf.gr_kal2.tabl1.fz[0]=28;
;;;316    	conf.gr_kal2.tabl2.kod[0]=29;
;;;317    	conf.gr_kal2.tabl2.fz[0]=30;
;;;318    	conf.gr_kal2.tabl2.kod[9]=31;
;;;319    	conf.gr_kal2.tabl2.fz[9]=32;
;;;320    */
;;;321    	size=sizeof(st_conf);
0000c2  21be              MOVS     r1,#0xbe
0000c4  8069              STRH     r1,[r5,#2]
;;;322    	
;;;323    	for (i = 0; i < size; i += 1)
;;;324      {
;;;325    		(*(__IO uint8_t *) ((__IO uint8_t *) (&conf) + i))=(*(__IO uint8_t *) (BKPSRAM_BASE + i));
0000c6  4842              LDR      r0,|L2.464|
0000c8  4d42              LDR      r5,|L2.468|
                  |L2.202|
0000ca  5c22              LDRB     r2,[r4,r0]
0000cc  552a              STRB     r2,[r5,r4]
0000ce  1c64              ADDS     r4,r4,#1              ;323
0000d0  428c              CMP      r4,r1                 ;323
0000d2  d3fa              BCC      |L2.202|
;;;326    	}	
;;;327    	
;;;328    		kol_usr=conf.per_usr;
0000d4  4940              LDR      r1,|L2.472|
0000d6  8928              LDRH     r0,[r5,#8]  ; conf
0000d8  f04f0401          MOV      r4,#1                 ;245
0000dc  8008              STRH     r0,[r1,#0]
;;;329    		conf.tm_antidreb=conf.tm_antidreb*10;
0000de  7928              LDRB     r0,[r5,#4]  ; conf
0000e0  eb000080          ADD      r0,r0,r0,LSL #2
0000e4  0640              LSLS     r0,r0,#25
0000e6  0e00              LSRS     r0,r0,#24
0000e8  7128              STRB     r0,[r5,#4]
;;;330    	
;;;331    		if (conf.tm_antidreb==0)
0000ea  d100              BNE      |L2.238|
;;;332    				conf.tm_antidreb=1;
0000ec  712c              STRB     r4,[r5,#4]
                  |L2.238|
;;;333    
;;;334    //	RCC_APB2PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE); 
;;;335    	GPIO_InitStructure.GPIO_Pin   = PIN_RELE;      		//  vivod RELE
0000ee  2010              MOVS     r0,#0x10
;;;336    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    // rezim vivoda
0000f0  f88d4004          STRB     r4,[sp,#4]
;;;337    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
0000f4  f88d4006          STRB     r4,[sp,#6]
;;;338    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //speed
0000f8  2602              MOVS     r6,#2
0000fa  9000              STR      r0,[sp,#0]            ;336
0000fc  f88d6005          STRB     r6,[sp,#5]
;;;339    	GPIO_Init(PORT_RELE, &GPIO_InitStructure); 
000100  4669              MOV      r1,sp
000102  f8dfa0d8          LDR      r10,|L2.476|
000106  e000              B        |L2.266|
                  |L2.264|
000108  e052              B        |L2.432|
                  |L2.266|
00010a  4650              MOV      r0,r10
00010c  f7fffffe          BL       GPIO_Init
;;;340    
;;;341    	GPIO_InitStructure.GPIO_Pin   = PIN_L1;      		//  vivod svetodiod knopka 1
;;;342    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    // rezim vivoda
000110  f88d4004          STRB     r4,[sp,#4]
;;;343    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
;;;344    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //speed
;;;345    	GPIO_Init(PORT_L1, &GPIO_InitStructure); 
000114  f8dfb0c8          LDR      r11,|L2.480|
000118  2740              MOVS     r7,#0x40              ;341
00011a  f88d4006          STRB     r4,[sp,#6]            ;343
00011e  9700              STR      r7,[sp,#0]            ;342
000120  f88d6005          STRB     r6,[sp,#5]            ;344
000124  4669              MOV      r1,sp
000126  4658              MOV      r0,r11
000128  f7fffffe          BL       GPIO_Init
;;;346    	
;;;347    	GPIO_InitStructure.GPIO_Pin   = PIN_L2;      		  //  vivod svetodiod knopka 2
;;;348    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    // rezim vivoda
00012c  f88d4004          STRB     r4,[sp,#4]
000130  f44f7880          MOV      r8,#0x100             ;347
;;;349    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
000134  f88d4006          STRB     r4,[sp,#6]
000138  f8cd8000          STR      r8,[sp,#0]            ;348
;;;350    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //speed
00013c  f88d6005          STRB     r6,[sp,#5]
;;;351    	GPIO_Init(PORT_L2, &GPIO_InitStructure); 
000140  4669              MOV      r1,sp
000142  4658              MOV      r0,r11
000144  f7fffffe          BL       GPIO_Init
;;;352    
;;;353    	GPIO_InitStructure.GPIO_Pin   = PIN_K1;      		  //  vvod  knopka 1
;;;354    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;    // 	rezim vivoda
000148  f04f0900          MOV      r9,#0
00014c  2080              MOVS     r0,#0x80              ;353
00014e  f88d9004          STRB     r9,[sp,#4]
000152  9000              STR      r0,[sp,#0]
;;;355    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
000154  f88d4006          STRB     r4,[sp,#6]
;;;356    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //	speed
000158  f88d6005          STRB     r6,[sp,#5]
;;;357    	GPIO_Init(PORT_K1, &GPIO_InitStructure); 
00015c  4669              MOV      r1,sp
00015e  4658              MOV      r0,r11
000160  f7fffffe          BL       GPIO_Init
;;;358    	
;;;359    	GPIO_InitStructure.GPIO_Pin   = PIN_K2;      		  //  vvod  knopka 2
000164  0230              LSLS     r0,r6,#8
;;;360    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;    // 	rezim vivoda
000166  f88d9004          STRB     r9,[sp,#4]
00016a  9000              STR      r0,[sp,#0]
;;;361    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
00016c  f88d4006          STRB     r4,[sp,#6]
;;;362    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //	speed
000170  f88d6005          STRB     r6,[sp,#5]
;;;363    	GPIO_Init(PORT_K2, &GPIO_InitStructure); 
000174  4669              MOV      r1,sp
000176  4658              MOV      r0,r11
000178  f7fffffe          BL       GPIO_Init
;;;364    	
;;;365    	if (conf.tek_gr_kal==0)
;;;366    	{
;;;367    		//  dr kal ==0 - pervaya
;;;368    		PORT_L1->BSRRL = PIN_L1;  // on  PIN_L1
00017c  4818              LDR      r0,|L2.480|
00017e  78ea              LDRB     r2,[r5,#3]            ;365  ; conf
000180  3018              ADDS     r0,r0,#0x18
;;;369    	  PORT_L2->BSRRH = PIN_L2;	// off PIN_L2
000182  1c81              ADDS     r1,r0,#2
000184  b1b2              CBZ      r2,|L2.436|
;;;370    	}
;;;371    	else
;;;372    	{
;;;373    		//  dr kal ==1 - vtoraya
;;;374    		PORT_L1->BSRRH = PIN_L1;  // off  PIN_L1
000186  800f              STRH     r7,[r1,#0]
;;;375    	  PORT_L2->BSRRL = PIN_L2;	// on   PIN_L2
000188  f8a08000          STRH     r8,[r0,#0]
                  |L2.396|
;;;376    	}
;;;377          
;;;378    		sost_flesh=0;	
00018c  4815              LDR      r0,|L2.484|
;;;379    		PORT_ZAP_EN->BSRRH = PIN_ZAP_EN;  // off  PORT_ZAP_EN
00018e  f44f5200          MOV      r2,#0x2000
000192  f8809000          STRB     r9,[r0,#0]            ;378
000196  f8aa201a          STRH     r2,[r10,#0x1a]
;;;380    		PORT_ZAP_DIS->BSRRL = PIN_ZAP_DIS;  // on  PORT_ZAP_DIS
00019a  0052              LSLS     r2,r2,#1
00019c  f8aa2018          STRH     r2,[r10,#0x18]
;;;381    		
;;;382    		avariya=0;
0001a0  4a11              LDR      r2,|L2.488|
;;;383    		PORT_AVARIYA->BSRRH = PIN_AVARIYA;               			
0001a2  f44f4100          MOV      r1,#0x8000
0001a6  f8829000          STRB     r9,[r2,#0]            ;382
0001aa  f8aa101a          STRH     r1,[r10,#0x1a]
;;;384    	
;;;385    	/*
;;;386    		conf.por_rele
;;;387    	  conf.time_max
;;;388    	  conf.tm_antidreb
;;;389    		conf.tm_rele_off
;;;390    		conf.tm_rele_on
;;;391    		conf.
;;;392    	*/	
;;;393    	
;;;394    	/*
;;;395    	for (i = 0; i < size; i += 1)
;;;396      {
;;;397        *(__IO uint8_t *) (BKPSRAM_BASE + i) = 0;
;;;398      }
;;;399    	*/
;;;400    	
;;;401    	/*
;;;402    	for (i = 0; i < size; i += 1)
;;;403      {
;;;404        *(__IO uint8_t *) (BKPSRAM_BASE + i) = *(__IO uint8_t *) ((__IO uint8_t *) (&conf) + i);
;;;405      }
;;;406    	*/
;;;407    	
;;;408    	
;;;409    /*
;;;410    	conf.address=255;
;;;411    	conf.ver_po_st=255;
;;;412    	conf.ver_po_ml=255;
;;;413    	conf.per_usr=255;
;;;414    	conf.time_max=255;
;;;415    	conf.tek_gr_kal=255;
;;;416    	conf.gr_kal1.tabl1.fz[0]=255;
;;;417    	conf.gr_kal1.tabl1.kod[0]=255;
;;;418    	conf.gr_kal1.tabl2.fz[0]=255;
;;;419    	conf.gr_kal1.tabl2.kod[0]=255;
;;;420    	
;;;421    	conf.gr_kal2.tabl1.fz[0]=255;
;;;422    	conf.gr_kal2.tabl1.kod[0]=255;
;;;423    	conf.gr_kal2.tabl2.fz[0]=255;
;;;424    	conf.gr_kal2.tabl2.kod[0]=255;
;;;425    	conf.revers_group_select=255;
;;;426    	conf.revers_peredacha_select=255;
;;;427    	conf.tm_antidreb=255;
;;;428    	conf.por_rele=255;
;;;429    	conf.tm_rele_on=255;
;;;430    	conf.tm_rele_off=255;
;;;431    	conf.indicators[0].numb=255;
;;;432    	conf.indicators[0].kol_cifr=255;
;;;433    	conf.indicators[1].numb=255;
;;;434    	conf.indicators[1].kol_cifr=255;
;;;435    	conf.indicators[2].numb=255;
;;;436    	conf.indicators[2].kol_cifr=255;
;;;437    	conf.indicators[3].numb=255;
;;;438    	conf.indicators[3].kol_cifr=255;
;;;439    	*/
;;;440    	/*
;;;441    	// test read config to comp
;;;442    	conf.address=1;
;;;443    	conf.ver_po_st=2;
;;;444    	conf.ver_po_ml=3;
;;;445    	conf.tek_gr_kal=4;
;;;446    	conf.tm_antidreb=5;
;;;447    	conf.revers_group_select=6;
;;;448    	conf.revers_peredacha_select=7;
;;;449    	conf.rez8=8;
;;;450    	
;;;451    	conf.per_usr=9;
;;;452    	conf.time_max=10;
;;;453    	conf.por_rele=11;
;;;454    	conf.tm_rele_on=12;
;;;455    	conf.tm_rele_off=13;
;;;456    	conf.rez16=14;
;;;457    	
;;;458    	conf.indicators[0].numb=15;
;;;459    	conf.indicators[0].kol_cifr=16;
;;;460    	conf.indicators[1].numb=17;
;;;461    	conf.indicators[1].kol_cifr=18;
;;;462    	conf.indicators[2].numb=19;
;;;463    	conf.indicators[2].kol_cifr=20;
;;;464    	conf.indicators[3].numb=21;
;;;465    	conf.indicators[3].kol_cifr=2;
;;;466    	conf.gr_kal1.tabl1.kod[0]=23;
;;;467    	conf.gr_kal1.tabl1.fz[0]=24;
;;;468    	conf.gr_kal1.tabl2.kod[0]=25;
;;;469    	conf.gr_kal1.tabl2.fz[0]=26;
;;;470    	conf.gr_kal2.tabl1.kod[0]=27;
;;;471    	conf.gr_kal2.tabl1.fz[0]=28;
;;;472    	conf.gr_kal2.tabl2.kod[0]=29;
;;;473    	conf.gr_kal2.tabl2.fz[0]=30;
;;;474    	conf.gr_kal2.tabl2.kod[9]=31;
;;;475    	conf.gr_kal2.tabl2.fz[9]=32;
;;;476    	
;;;477    */
;;;478    	
;;;479    }
;;;480    	
;;;481    __ASM volatile ("nop");
0001ae  bf00              NOP      
                  |L2.432|
;;;482    
;;;483        
;;;484        // Всё, часы запустились и считают время.
;;;485    		/*
;;;486    		
;;;487    		/разрешить тактирование модулей управления питанием и управлением резервной областью
;;;488      RCC->APB1ENR |= RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN;
;;;489      //разрешить доступ к области резервных данных
;;;490      PWR->CR |= PWR_CR_DBP;
;;;491      //если часы выключены - инициализировать их
;;;492      if ((RCC->BDCR & RCC_BDCR_RTCEN) != RCC_BDCR_RTCEN)
;;;493      {
;;;494        //выполнить сброс области резервных данных
;;;495        RCC->BDCR |=  RCC_BDCR_BDRST;
;;;496        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;497     
;;;498        //выбрать источником тактовых импульсов внешний кварц 32768 и подать тактирование
;;;499        RCC->BDCR |=  RCC_BDCR_RTCEN | RCC_BDCR_RTCSEL_LSE;
;;;500     
;;;501        RTC->CRL  |=  RTC_CRL_CNF;
;;;502        RTC->PRLL  = 0x7FFF;         //регистр деления на 32768
;;;503        RTC->CRL  &=  ~RTC_CRL_CNF;
;;;504     
;;;505        //установить бит разрешения работы и дождаться установки бита готовности
;;;506        RCC->BDCR |= RCC_BDCR_LSEON;
;;;507        while ((RCC->BDCR & RCC_BDCR_LSEON) != RCC_BDCR_LSEON){}
;;;508     
;;;509        RTC->CRL &= (uint16_t)~RTC_CRL_RSF;
;;;510        while((RTC->CRL & RTC_CRL_RSF) != RTC_CRL_RSF){}
;;;511     
;;;512        return 1;
;;;513      }
;;;514      return 0;
;;;515    	*/
;;;516    	
;;;517    	
;;;518    	/*
;;;519    	
;;;520    	// one more init кес
;;;521    	
;;;522    	RTC_InitTypeDef RTC_InitStructure;
;;;523    RTC_TimeTypeDef RTC_TimeStructure;
;;;524    RTC_DateTypeDef RTC_DateStructure;
;;;525    __IO uint32_t AsynchPrediv = 0, SynchPrediv = 0;
;;;526    __IO uint32_t TimeDisplay = 0;
;;;527    
;;;528    
;;;529    		// Enable the PWR APB1 Clock Interface 
;;;530    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
;;;531    
;;;532    //Allow access to BKP Domain 
;;;533    PWR_BackupAccessCmd(ENABLE);
;;;534      
;;;535    if (RTC_ReadBackupRegister(RTC_BKP_DR2) != 0xA5A5) {
;;;536    
;;;537    //Enable the PWR clock 
;;;538    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
;;;539    
;;;540    // Allow access to RTC 
;;;541    PWR_BackupAccessCmd(ENABLE);
;;;542    
;;;543    #if defined (RTC_CLOCK_SOURCE_LSI) // LSI used as RTC source clock
;;;544    // The RTC Clock may varies due to LSI frequency dispersion. 
;;;545    // Enable the LSI OSC 
;;;546    RCC_LSICmd(ENABLE);
;;;547    
;;;548    // Wait till LSI is ready 
;;;549    while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
;;;550    {
;;;551    }
;;;552    
;;;553    // Select the RTC Clock Source 
;;;554    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
;;;555    
;;;556    SynchPrediv = 0xFF;
;;;557    AsynchPrediv = 0x7F;
;;;558    
;;;559    #elif defined (RTC_CLOCK_SOURCE_LSE) // LSE used as RTC source clock 
;;;560    // Enable the LSE OSC 
;;;561    RCC_LSEConfig(RCC_LSE_ON);
;;;562    
;;;563    // Wait till LSE is ready 
;;;564    while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
;;;565    {
;;;566    }
;;;567    
;;;568    // Select the RTC Clock Source 
;;;569    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
;;;570    
;;;571    SynchPrediv = 0xFF;
;;;572    AsynchPrediv = 0x7F;
;;;573    
;;;574    #else
;;;575    #error Please select the RTC Clock source inside the main.c file
;;;576    #endif // RTC_CLOCK_SOURCE_LSI 
;;;577    
;;;578    // Enable the RTC Clock 
;;;579    RCC_RTCCLKCmd(ENABLE);
;;;580    
;;;581    // Wait for RTC APB registers synchronisation 
;;;582    RTC_WaitForSynchro();
;;;583    
;;;584    // Allow access to BKP Domain 
;;;585    PWR_BackupAccessCmd(ENABLE);
;;;586    
;;;587    // Write to the first RTC Backup Data Register 
;;;588    RTC_WriteBackupRegister(RTC_BKP_DR2,0xA5A5);
;;;589    
;;;590    //Set the Time 
;;;591    RTC_TimeStructure.RTC_Hours = 22;
;;;592    RTC_TimeStructure.RTC_Minutes = 11;
;;;593    RTC_TimeStructure.RTC_Seconds = 00;
;;;594    
;;;595    // Set the Date 
;;;596    RTC_DateStructure.RTC_Month = 4;
;;;597    RTC_DateStructure.RTC_Date = 29;
;;;598    RTC_DateStructure.RTC_Year = 11;
;;;599    RTC_DateStructure.RTC_WeekDay = RTC_Weekday_Friday;
;;;600    
;;;601    //Calendar Configuration 
;;;602    RTC_InitStructure.RTC_AsynchPrediv = AsynchPrediv;
;;;603    RTC_InitStructure.RTC_SynchPrediv = SynchPrediv;
;;;604    RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24;
;;;605    RTC_Init(&RTC_InitStructure);
;;;606    
;;;607    // Set Current Time and Date 
;;;608    RTC_SetTime(RTC_Format_BIN, &RTC_TimeStructure);
;;;609    RTC_SetDate(RTC_Format_BIN, &RTC_DateStructure);
;;;610    #if 0
;;;611    //Configure the RTC Wakeup Clock source and Counter (Wakeup event each 1 second) 
;;;612    RTC_WakeUpClockConfig(RTC_WakeUpClock_RTCCLK_Div16);
;;;613    RTC_SetWakeUpCounter(0x7FF);
;;;614    
;;;615    // Enable the Wakeup Interrupt 
;;;616    RTC_ITConfig(RTC_IT_WUT, ENABLE);
;;;617    
;;;618    //Enable Wakeup Counter 
;;;619    RTC_WakeUpCmd(ENABLE);
;;;620    #endif
;;;621    // Backup SRAM **************************************************************
;;;622    //Enable BKPRAM Clock 
;;;623    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
;;;624    
;;;625    //Enable the Backup SRAM low power Regulator to retain it's content in VBAT mode 
;;;626    PWR_BackupRegulatorCmd(ENABLE);
;;;627    
;;;628    // Wait until the Backup SRAM low power Regulator is ready 
;;;629    while(PWR_GetFlagStatus(PWR_FLAG_BRR) == RESET)
;;;630    {
;;;631    }
;;;632    
;;;633    }
;;;634    else{
;;;635    
;;;636    // Enable the PWR clock 
;;;637    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
;;;638    
;;;639    // Allow access to RTC 
;;;640    PWR_BackupAccessCmd(ENABLE);
;;;641    
;;;642    // Wait for RTC APB registers synchronisation 
;;;643    RTC_WaitForSynchro();
;;;644    // Clear the Wakeup Interrupt 
;;;645    RTC_ClearITPendingBit(RTC_IT_WUT);
;;;646    
;;;647    // Backup SRAM **************************************************************
;;;648    // Enable BKPSRAM Clock 
;;;649    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
;;;650    }
;;;651    
;;;652    
;;;653    	
;;;654    	*/
;;;655    	
;;;656    }
0001b0  e8bd9ffc          POP      {r2-r12,pc}
                  |L2.436|
0001b4  8007              STRH     r7,[r0,#0]            ;368
0001b6  f8a18000          STRH     r8,[r1,#0]            ;369
0001ba  e7e7              B        |L2.396|
;;;657    
                          ENDP

                  |L2.444|
                          DCD      0x4000280c
                  |L2.448|
                          DCD      0x40023840
                  |L2.452|
                          DCD      0x40007000
                  |L2.456|
                          DCD      0x007f0107
                  |L2.460|
                          DCD      ||.data||
                  |L2.464|
                          DCD      0x40024000
                  |L2.468|
                          DCD      conf
                  |L2.472|
                          DCD      kol_usr
                  |L2.476|
                          DCD      0x40020000
                  |L2.480|
                          DCD      0x40020800
                  |L2.484|
                          DCD      sost_flesh
                  |L2.488|
                          DCD      avariya

                          AREA ||i.rtc_Lock||, CODE, READONLY, ALIGN=2

                  rtc_Lock PROC
;;;24     // Включить защиту от записи
;;;25      void rtc_Lock(void)
000000  4901              LDR      r1,|L3.8|
;;;26     {
;;;27         // Запишем какую-нибудь фигню, главное, чтоб не правильную
;;;28         RTC->WPR = 0xFF;
000002  20ff              MOVS     r0,#0xff
000004  6008              STR      r0,[r1,#0]
;;;29     }
000006  4770              BX       lr
;;;30     
                          ENDP

                  |L3.8|
                          DCD      0x40002824

                          AREA ||i.rtc_Reset||, CODE, READONLY, ALIGN=2

                  rtc_Reset PROC
;;;112    // Сброс состояния часов
;;;113    void rtc_Reset(void)
000000  480a              LDR      r0,|L4.44|
;;;114    {
;;;115        // Включим тактирование PWR
;;;116        RCC->APB1ENR |= RCC_APB1ENR_PWREN;
000002  6801              LDR      r1,[r0,#0]
000004  f0415180          ORR      r1,r1,#0x10000000
000008  6001              STR      r1,[r0,#0]
;;;117        
;;;118        // Разрешим доступ к управляющим регистрам энергонезависимого домена
;;;119        PWR->CR |= PWR_CR_DBP;
00000a  4809              LDR      r0,|L4.48|
00000c  6801              LDR      r1,[r0,#0]
00000e  f4417180          ORR      r1,r1,#0x100
000012  6001              STR      r1,[r0,#0]
;;;120        
;;;121        // Выберем его как источник тактирования RTC:
;;;122        RCC->BDCR |=  RCC_BDCR_BDRST;
000014  4805              LDR      r0,|L4.44|
000016  3030              ADDS     r0,r0,#0x30
000018  6801              LDR      r1,[r0,#0]
00001a  f4413180          ORR      r1,r1,#0x10000
00001e  6001              STR      r1,[r0,#0]
;;;123        RCC->BDCR &= ~RCC_BDCR_BDRST;
000020  6801              LDR      r1,[r0,#0]
000022  f4213180          BIC      r1,r1,#0x10000
000026  6001              STR      r1,[r0,#0]
;;;124    }
000028  4770              BX       lr
;;;125    
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      0x40023840
                  |L4.48|
                          DCD      0x40007000

                          AREA ||i.rtc_SetDate||, CODE, READONLY, ALIGN=2

                  rtc_SetDate PROC
;;;31     // Установить дату
;;;32     void rtc_SetDate(uint8_t Day, uint8_t Month, uint8_t Year, uint8_t DayOfWeek)
000000  b5f0              PUSH     {r4-r7,lr}
;;;33     {
;;;34         uint32_t Tens, Units;
;;;35         uint32_t TempReg = 0;
;;;36         
;;;37         // Очистим поле даты
;;;38         TempReg = 0;
;;;39         
;;;40         // Запишем год
;;;41         {
;;;42             Tens  = (Year / 10) & 0x0f;          // Десятки лет
000002  260a              MOVS     r6,#0xa
000004  fbb2f4f6          UDIV     r4,r2,r6
000008  f004040f          AND      r4,r4,#0xf
;;;43             Units = (Year - (Tens * 10)) & 0x0f; // Единицы лет
00000c  4265              RSBS     r5,r4,#0
00000e  eb050585          ADD      r5,r5,r5,LSL #2
000012  2700              MOVS     r7,#0                 ;35
000014  eb020245          ADD      r2,r2,r5,LSL #1
000018  f002020f          AND      r2,r2,#0xf
;;;44             
;;;45             TempReg |= (Tens  << 20); // YT, 20
00001c  ea475404          ORR      r4,r7,r4,LSL #20
;;;46             TempReg |= (Units << 16); // YU, 16
000020  ea444502          ORR      r5,r4,r2,LSL #16
;;;47         }
;;;48         // Запишем месяц
;;;49         {
;;;50             Tens  = (Month / 10) & 0x01;          // Десятки месяцев
000024  fbb1f2f6          UDIV     r2,r1,r6
000028  f0020201          AND      r2,r2,#1
;;;51             Units = (Month - (Tens * 10)) & 0x0f; // Единицы месяцев
00002c  4254              RSBS     r4,r2,#0
00002e  eb040484          ADD      r4,r4,r4,LSL #2
000032  eb010144          ADD      r1,r1,r4,LSL #1
000036  f001010f          AND      r1,r1,#0xf
;;;52             
;;;53             TempReg |= (Tens  << 12); // MT, 12
00003a  ea453202          ORR      r2,r5,r2,LSL #12
;;;54             TempReg |= (Units << 8);  // MU, 8
00003e  ea422401          ORR      r4,r2,r1,LSL #8
;;;55         }
;;;56         // Запишем день
;;;57         {
;;;58             Tens  = (Day / 10) & 0x03;          // Десятки дней
000042  fbb0f1f6          UDIV     r1,r0,r6
000046  f0010103          AND      r1,r1,#3
;;;59             Units = (Day - (Tens * 10)) & 0x0f; // Единицы дней
00004a  424a              RSBS     r2,r1,#0
00004c  eb020282          ADD      r2,r2,r2,LSL #2
000050  eb000042          ADD      r0,r0,r2,LSL #1
000054  f000020f          AND      r2,r0,#0xf
;;;60             
;;;61             TempReg |= (Tens  << 4); // DT, 4
000058  ea441001          ORR      r0,r4,r1,LSL #4
;;;62             TempReg |= (Units << 0);  // DU, 0
00005c  4310              ORRS     r0,r0,r2
;;;63         }
;;;64         // День недели:
;;;65         {
;;;66             TempReg |= ((DayOfWeek & 0x07) << 13); // WDU, 13
00005e  f0030107          AND      r1,r3,#7
000062  ea403041          ORR      r0,r0,r1,LSL #13
;;;67         }
;;;68         
;;;69         // Записывать надо всё сразу
;;;70         RTC->DR = TempReg;
000066  4901              LDR      r1,|L5.108|
000068  6008              STR      r0,[r1,#0]
;;;71     }
00006a  bdf0              POP      {r4-r7,pc}
;;;72     
                          ENDP

                  |L5.108|
                          DCD      0x40002804

                          AREA ||i.rtc_SetTime||, CODE, READONLY, ALIGN=2

                  rtc_SetTime PROC
;;;74     //static void rtc_SetTime(uint8_t Hours, uint8_t Minutes, uint8_t Seconds)
;;;75     void rtc_SetTime(uint8_t Hours, uint8_t Minutes, uint8_t Seconds)
000000  b570              PUSH     {r4-r6,lr}
;;;76     {
;;;77         uint32_t Tens, Units;
;;;78         uint32_t TempReg = 0;
;;;79         
;;;80         // Очистим поле даты
;;;81         TempReg = 0;
;;;82         
;;;83         // Запишем часы
;;;84         {
;;;85             Tens  = (Hours / 10) & 0x03;          // Десятки часов
000002  250a              MOVS     r5,#0xa
000004  fbb0f3f5          UDIV     r3,r0,r5
000008  f0030303          AND      r3,r3,#3
;;;86             Units = (Hours - (Tens * 10)) & 0x0f; // Единицы часов
00000c  425c              RSBS     r4,r3,#0
00000e  eb040484          ADD      r4,r4,r4,LSL #2
000012  2600              MOVS     r6,#0                 ;78
000014  eb000044          ADD      r0,r0,r4,LSL #1
000018  f000000f          AND      r0,r0,#0xf
;;;87             
;;;88             TempReg |= (Tens  << 20); // HT, 20
00001c  ea465303          ORR      r3,r6,r3,LSL #20
;;;89             TempReg |= (Units << 16); // HU, 16
000020  ea434400          ORR      r4,r3,r0,LSL #16
;;;90         }
;;;91         // Запишем минуты
;;;92         {
;;;93             Tens  = (Minutes / 10) & 0x07;          // Десятки минут
000024  fbb1f0f5          UDIV     r0,r1,r5
000028  f0000007          AND      r0,r0,#7
;;;94             Units = (Minutes - (Tens * 10)) & 0x0f; // Единицы минут
00002c  4243              RSBS     r3,r0,#0
00002e  eb030383          ADD      r3,r3,r3,LSL #2
000032  eb010143          ADD      r1,r1,r3,LSL #1
000036  f001010f          AND      r1,r1,#0xf
;;;95             
;;;96             TempReg |= (Tens  << 12); // MNT, 12
00003a  ea443000          ORR      r0,r4,r0,LSL #12
;;;97             TempReg |= (Units << 8);  // MNU, 8
00003e  ea402301          ORR      r3,r0,r1,LSL #8
;;;98         }
;;;99         // Запишем секунды
;;;100        {
;;;101            Tens  = (Seconds / 10) & 0x07;          // Десятки секунд
000042  fbb2f0f5          UDIV     r0,r2,r5
000046  f0000007          AND      r0,r0,#7
;;;102            Units = (Seconds - (Tens * 10)) & 0x0f; // Единицы секунд
00004a  4241              RSBS     r1,r0,#0
00004c  eb010181          ADD      r1,r1,r1,LSL #2
000050  eb020141          ADD      r1,r2,r1,LSL #1
000054  f001010f          AND      r1,r1,#0xf
;;;103            
;;;104            TempReg |= (Tens  << 4); // ST, 4
000058  ea431000          ORR      r0,r3,r0,LSL #4
;;;105            TempReg |= (Units << 0);  // SU, 0
00005c  4308              ORRS     r0,r0,r1
;;;106        }
;;;107        
;;;108        // Записывать надо всё сразу
;;;109        RTC->TR = TempReg;
00005e  4901              LDR      r1,|L6.100|
000060  6008              STR      r0,[r1,#0]
;;;110    }
000062  bd70              POP      {r4-r6,pc}
;;;111    
                          ENDP

                  |L6.100|
                          DCD      0x40002800

                          AREA ||i.rtc_Unlock||, CODE, READONLY, ALIGN=2

                  rtc_Unlock PROC
;;;16     // Выключить защиту от записи
;;;17     void rtc_Unlock(void)
000000  4802              LDR      r0,|L7.12|
;;;18     {
;;;19         // Запишем эти значения по очереди
;;;20         RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6001              STR      r1,[r0,#0]
;;;21         RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6001              STR      r1,[r0,#0]
;;;22     }
00000a  4770              BX       lr
;;;23     
                          ENDP

                  |L7.12|
                          DCD      0x40002824

                          AREA ||.data||, DATA, ALIGN=1

                  bkp
000000  0000              DCW      0x0000
                  size
000002  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "src\\rtc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_rtc_c_bkp____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___5_rtc_c_bkp____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_rtc_c_bkp____REVSH|
#line 128
|__asm___5_rtc_c_bkp____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
