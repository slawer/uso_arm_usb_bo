; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\MEDIA_USB_KEY\rtc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\MEDIA_USB_KEY\rtc.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\MEDIA_USB_KEY\rtc.crf src\rtc.c]
                          THUMB

                          AREA ||i.rtc_Get||, CODE, READONLY, ALIGN=2

                  rtc_Get PROC
;;;229    // Получить текущее время
;;;230    void rtc_Get(TDateTime * DateTime)
000000  4921              LDR      r1,|L1.136|
;;;231    {
000002  b510              PUSH     {r4,lr}
;;;232        uint32_t Date = RTC->DR;
000004  6809              LDR      r1,[r1,#0]
;;;233        uint32_t Time = RTC->TR;
000006  4a20              LDR      r2,|L1.136|
000008  1f12              SUBS     r2,r2,#4
00000a  6812              LDR      r2,[r2,#0]
;;;234        
;;;235        // Очистим
;;;236        memset(DateTime, 0, sizeof(*DateTime));
00000c  2300              MOVS     r3,#0
00000e  6003              STR      r3,[r0,#0]
000010  8083              STRH     r3,[r0,#4]
;;;237        
;;;238        // Год
;;;239        DateTime->Year      = ((Date >> 20) & 0x0f) * 10 + ((Date >> 16) & 0x0f);
000012  f3c15303          UBFX     r3,r1,#20,#4
000016  eb030383          ADD      r3,r3,r3,LSL #2
00001a  f3c14403          UBFX     r4,r1,#16,#4
00001e  eb040343          ADD      r3,r4,r3,LSL #1
000022  7003              STRB     r3,[r0,#0]
;;;240        // Месяц
;;;241        DateTime->Month     = ((Date >> 12) & 0x01) * 10 + ((Date >>  8) & 0x0f);
000024  f3c13300          UBFX     r3,r1,#12,#1
000028  eb030383          ADD      r3,r3,r3,LSL #2
00002c  f3c12403          UBFX     r4,r1,#8,#4
000030  eb040343          ADD      r3,r4,r3,LSL #1
000034  7043              STRB     r3,[r0,#1]
;;;242        // День
;;;243        DateTime->Day       = ((Date >>  4) & 0x03) * 10 + ((Date >>  0) & 0x0f);
000036  f3c11301          UBFX     r3,r1,#4,#2
00003a  f001040f          AND      r4,r1,#0xf
00003e  eb030383          ADD      r3,r3,r3,LSL #2
000042  eb040343          ADD      r3,r4,r3,LSL #1
000046  7083              STRB     r3,[r0,#2]
;;;244        // День недели
;;;245        DateTime->DayOfWeek = ((Date >> 13) & 0x07);
000048  f3c13142          UBFX     r1,r1,#13,#3
00004c  70c1              STRB     r1,[r0,#3]
;;;246        
;;;247        // Час
;;;248        DateTime->Hours     = ((Time >> 20) & 0x03) * 10 + ((Time >> 16) & 0x0f);
00004e  f3c25101          UBFX     r1,r2,#20,#2
000052  eb010181          ADD      r1,r1,r1,LSL #2
000056  f3c24303          UBFX     r3,r2,#16,#4
00005a  eb030141          ADD      r1,r3,r1,LSL #1
00005e  7101              STRB     r1,[r0,#4]
;;;249        // Минуты
;;;250        DateTime->Minutes   = ((Time >> 12) & 0x07) * 10 + ((Time >> 8) & 0x0f);
000060  f3c23102          UBFX     r1,r2,#12,#3
000064  eb010181          ADD      r1,r1,r1,LSL #2
000068  f3c22303          UBFX     r3,r2,#8,#4
00006c  eb030141          ADD      r1,r3,r1,LSL #1
000070  7141              STRB     r1,[r0,#5]
;;;251        // Секунды
;;;252        DateTime->Seconds   = ((Time >> 4) & 0x07) * 10 + ((Time >> 0) & 0x0f);
000072  f3c21102          UBFX     r1,r2,#4,#3
000076  f002030f          AND      r3,r2,#0xf
00007a  eb010181          ADD      r1,r1,r1,LSL #2
00007e  eb030141          ADD      r1,r3,r1,LSL #1
000082  7181              STRB     r1,[r0,#6]
;;;253    }
000084  bd10              POP      {r4,pc}
                          ENDP

000086  0000              DCW      0x0000
                  |L1.136|
                          DCD      0x40002804

                          AREA ||i.rtc_Init||, CODE, READONLY, ALIGN=2

                  rtc_Init PROC
;;;119    // Инициализация модуля
;;;120    void rtc_Init(void)
000000  492a              LDR      r1,|L2.172|
;;;121    {
000002  b510              PUSH     {r4,lr}
;;;122        // Если часы запущены, делать тут нечего.
;;;123        if(RTC->ISR & RTC_ISR_INITS) return;
000004  6808              LDR      r0,[r1,#0]
000006  06c0              LSLS     r0,r0,#27
000008  d44e              BMI      |L2.168|
;;;124        
;;;125        // Включим тактирование PWR
;;;126        RCC->APB1ENR |= RCC_APB1ENR_PWREN;
00000a  4829              LDR      r0,|L2.176|
00000c  6802              LDR      r2,[r0,#0]
00000e  f0425280          ORR      r2,r2,#0x10000000
000012  6002              STR      r2,[r0,#0]
;;;127        
;;;128        // Разрешим доступ к управляющим регистрам энергонезависимого домена
;;;129        PWR->CR |= PWR_CR_DBP;
000014  4827              LDR      r0,|L2.180|
000016  6802              LDR      r2,[r0,#0]
000018  f4427280          ORR      r2,r2,#0x100
00001c  6002              STR      r2,[r0,#0]
;;;130        
;;;131        // Запускаем LSI:
;;;132        RCC->CSR |= RCC_CSR_LSION;
00001e  4824              LDR      r0,|L2.176|
000020  3034              ADDS     r0,r0,#0x34
000022  6802              LDR      r2,[r0,#0]
000024  f0420201          ORR      r2,r2,#1
000028  6002              STR      r2,[r0,#0]
                  |L2.42|
;;;133        
;;;134        // Ждём, когда он заведётся
;;;135        while(!(RCC->CSR & RCC_CSR_LSIRDY)) {}
00002a  6802              LDR      r2,[r0,#0]
00002c  0792              LSLS     r2,r2,#30
00002e  d5fc              BPL      |L2.42|
;;;136        
;;;137        // Ок, генератор на 32 кГц завёлся.
;;;138        
;;;139        // Сбросим состояние энергонезависимого домена
;;;140        RCC->BDCR |=  RCC_BDCR_BDRST;
000030  481f              LDR      r0,|L2.176|
000032  3030              ADDS     r0,r0,#0x30
000034  6802              LDR      r2,[r0,#0]
000036  f4423280          ORR      r2,r2,#0x10000
00003a  6002              STR      r2,[r0,#0]
;;;141        RCC->BDCR &= ~RCC_BDCR_BDRST;
00003c  6802              LDR      r2,[r0,#0]
00003e  f4223280          BIC      r2,r2,#0x10000
000042  6002              STR      r2,[r0,#0]
;;;142        
;;;143        // Выберем его как источник тактирования RTC:
;;;144        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
000044  6802              LDR      r2,[r0,#0]
000046  f4227240          BIC      r2,r2,#0x300
00004a  6002              STR      r2,[r0,#0]
;;;145        RCC->BDCR |= (RCC_BDCR_RTCSEL_1); // запишем 0b10
00004c  6802              LDR      r2,[r0,#0]
00004e  f4427200          ORR      r2,r2,#0x200
000052  6002              STR      r2,[r0,#0]
;;;146            
;;;147        // Включим тактирование RTC
;;;148        RCC->BDCR |= RCC_BDCR_RTCEN;
000054  6802              LDR      r2,[r0,#0]
000056  f4424200          ORR      r2,r2,#0x8000
00005a  6002              STR      r2,[r0,#0]
00005c  4a13              LDR      r2,|L2.172|
00005e  20ca              MOVS     r0,#0xca
000060  3218              ADDS     r2,r2,#0x18
000062  6010              STR      r0,[r2,#0]
000064  2053              MOVS     r0,#0x53
000066  6010              STR      r0,[r2,#0]
;;;149        
;;;150        // Снимем защиту от записи с регистров RTC
;;;151        rtc_Unlock();
;;;152        {
;;;153            // Здесь можем менять регистры RTC
;;;154    
;;;155            // Войдём в режим инициализации:
;;;156            RTC->ISR |= RTC_ISR_INIT;
000068  6808              LDR      r0,[r1,#0]
00006a  f0400080          ORR      r0,r0,#0x80
00006e  6008              STR      r0,[r1,#0]
                  |L2.112|
;;;157            
;;;158            // Ждём, когда это произойдёт
;;;159            while(!(RTC->ISR & RTC_ISR_INITF)) {}
000070  6808              LDR      r0,[r1,#0]
000072  0640              LSLS     r0,r0,#25
000074  d5fc              BPL      |L2.112|
;;;160            
;;;161            // Часы остановлены. Режим инициализации
;;;162            // Настроим предделитель для получения частоты 1 Гц.
;;;163            
;;;164            // LSI: 
;;;165            // LSE: нужно разделить на 0x7fff (кварцы так точно рассчитаны на это)
;;;166            {  //  32768Hz, а нам нужны
;;;167                uint32_t Sync = 263;   // 15 бит
;;;168                uint32_t Async =127;  // 7 бит
;;;169                
;;;170                // Сначала записываем величину для синхронного предделителя
;;;171                RTC->PRER = Sync;
000076  480d              LDR      r0,|L2.172|
000078  f2401307          MOV      r3,#0x107             ;167
00007c  1d00              ADDS     r0,r0,#4
00007e  6003              STR      r3,[r0,#0]
;;;172                
;;;173                // Теперь добавим для асинхронного предделителя
;;;174                RTC->PRER =Sync | (Async << 16);
000080  4b0d              LDR      r3,|L2.184|
000082  6003              STR      r3,[r0,#0]
000084  4c09              LDR      r4,|L2.172|
000086  2300              MOVS     r3,#0
000088  3c08              SUBS     r4,r4,#8
00008a  480c              LDR      r0,|L2.188|
00008c  6020              STR      r0,[r4,#0]
00008e  1f20              SUBS     r0,r4,#4
000090  6003              STR      r3,[r0,#0]
;;;175    					
;;;176    			//		RTC->PRER = 0x00000000; // RESET PRER register
;;;177    			//		RTC->PRER |= (0xFF<<0); // 255 + 1 Synchronous prescaler factor set
;;;178    			//		RTC->PRER |= (0x7F<<16); // 127 + 1 Asynchronous prescaler factor set
;;;179            }
;;;180            
;;;181            // Устанавливаем дату: 30.05.13, пятница
;;;182            rtc_SetDate(2, 6, 13, 7);
;;;183            
;;;184            // Устанавливаем время: 15:00:00
;;;185            rtc_SetTime(0, 0, 00);
;;;186            
;;;187            // Переведём часы в 24-часовой формат
;;;188            RTC->CR |= RTC_CR_FMT;
000092  1d20              ADDS     r0,r4,#4
000094  6803              LDR      r3,[r0,#0]
000096  f0430340          ORR      r3,r3,#0x40
00009a  6003              STR      r3,[r0,#0]
;;;189            
;;;190            // Инициализация закончилась
;;;191            RTC->ISR &= ~RTC_ISR_INIT;
00009c  6808              LDR      r0,[r1,#0]
00009e  f0200080          BIC      r0,r0,#0x80
0000a2  6008              STR      r0,[r1,#0]
0000a4  20ff              MOVS     r0,#0xff
0000a6  6010              STR      r0,[r2,#0]
                  |L2.168|
;;;192        }   
;;;193        rtc_Lock();
;;;194        
;;;195        // Всё, часы запустились и считают время.
;;;196    		/*
;;;197    		
;;;198    		/разрешить тактирование модулей управления питанием и управлением резервной областью
;;;199      RCC->APB1ENR |= RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN;
;;;200      //разрешить доступ к области резервных данных
;;;201      PWR->CR |= PWR_CR_DBP;
;;;202      //если часы выключены - инициализировать их
;;;203      if ((RCC->BDCR & RCC_BDCR_RTCEN) != RCC_BDCR_RTCEN)
;;;204      {
;;;205        //выполнить сброс области резервных данных
;;;206        RCC->BDCR |=  RCC_BDCR_BDRST;
;;;207        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;208     
;;;209        //выбрать источником тактовых импульсов внешний кварц 32768 и подать тактирование
;;;210        RCC->BDCR |=  RCC_BDCR_RTCEN | RCC_BDCR_RTCSEL_LSE;
;;;211     
;;;212        RTC->CRL  |=  RTC_CRL_CNF;
;;;213        RTC->PRLL  = 0x7FFF;         //регистр деления на 32768
;;;214        RTC->CRL  &=  ~RTC_CRL_CNF;
;;;215     
;;;216        //установить бит разрешения работы и дождаться установки бита готовности
;;;217        RCC->BDCR |= RCC_BDCR_LSEON;
;;;218        while ((RCC->BDCR & RCC_BDCR_LSEON) != RCC_BDCR_LSEON){}
;;;219     
;;;220        RTC->CRL &= (uint16_t)~RTC_CRL_RSF;
;;;221        while((RTC->CRL & RTC_CRL_RSF) != RTC_CRL_RSF){}
;;;222     
;;;223        return 1;
;;;224      }
;;;225      return 0;
;;;226    	*/
;;;227    }
0000a8  bd10              POP      {r4,pc}
;;;228    
                          ENDP

0000aa  0000              DCW      0x0000
                  |L2.172|
                          DCD      0x4000280c
                  |L2.176|
                          DCD      0x40023840
                  |L2.180|
                          DCD      0x40007000
                  |L2.184|
                          DCD      0x007f0107
                  |L2.188|
                          DCD      0x0013e602

                          AREA ||i.rtc_Reset||, CODE, READONLY, ALIGN=2

                  rtc_Reset PROC
;;;105    // Сброс состояния часов
;;;106    void rtc_Reset(void)
000000  480a              LDR      r0,|L3.44|
;;;107    {
;;;108        // Включим тактирование PWR
;;;109        RCC->APB1ENR |= RCC_APB1ENR_PWREN;
000002  6801              LDR      r1,[r0,#0]
000004  f0415180          ORR      r1,r1,#0x10000000
000008  6001              STR      r1,[r0,#0]
;;;110        
;;;111        // Разрешим доступ к управляющим регистрам энергонезависимого домена
;;;112        PWR->CR |= PWR_CR_DBP;
00000a  4809              LDR      r0,|L3.48|
00000c  6801              LDR      r1,[r0,#0]
00000e  f4417180          ORR      r1,r1,#0x100
000012  6001              STR      r1,[r0,#0]
;;;113        
;;;114        // Выберем его как источник тактирования RTC:
;;;115        RCC->BDCR |=  RCC_BDCR_BDRST;
000014  4805              LDR      r0,|L3.44|
000016  3030              ADDS     r0,r0,#0x30
000018  6801              LDR      r1,[r0,#0]
00001a  f4413180          ORR      r1,r1,#0x10000
00001e  6001              STR      r1,[r0,#0]
;;;116        RCC->BDCR &= ~RCC_BDCR_BDRST;
000020  6801              LDR      r1,[r0,#0]
000022  f4213180          BIC      r1,r1,#0x10000
000026  6001              STR      r1,[r0,#0]
;;;117    }
000028  4770              BX       lr
;;;118    
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      0x40023840
                  |L3.48|
                          DCD      0x40007000

;*** Start embedded assembler ***

#line 1 "src\\rtc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_rtc_c_00beeb99____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___5_rtc_c_00beeb99____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_rtc_c_00beeb99____REVSH|
#line 128
|__asm___5_rtc_c_00beeb99____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
