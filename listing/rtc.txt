; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\MEDIA_USB_KEY\rtc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\MEDIA_USB_KEY\rtc.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\MEDIA_USB_KEY\rtc.crf src\rtc.c]
                          THUMB

                          AREA ||i.rtc_Get||, CODE, READONLY, ALIGN=2

                  rtc_Get PROC
;;;783    // Получить текущее время
;;;784    void rtc_Get(TDateTime * DateTime)
000000  4921              LDR      r1,|L1.136|
;;;785    {
000002  b510              PUSH     {r4,lr}
;;;786        uint32_t Date = RTC->DR;
000004  6809              LDR      r1,[r1,#0]
;;;787        uint32_t Time = RTC->TR;
000006  4a20              LDR      r2,|L1.136|
000008  1f12              SUBS     r2,r2,#4
00000a  6812              LDR      r2,[r2,#0]
;;;788        
;;;789        // Очистим
;;;790        memset(DateTime, 0, sizeof(*DateTime));
00000c  2300              MOVS     r3,#0
00000e  6003              STR      r3,[r0,#0]
000010  8083              STRH     r3,[r0,#4]
;;;791        
;;;792        // Год
;;;793        DateTime->Year      = ((Date >> 20) & 0x0f) * 10 + ((Date >> 16) & 0x0f);
000012  f3c15303          UBFX     r3,r1,#20,#4
000016  eb030383          ADD      r3,r3,r3,LSL #2
00001a  f3c14403          UBFX     r4,r1,#16,#4
00001e  eb040343          ADD      r3,r4,r3,LSL #1
000022  7003              STRB     r3,[r0,#0]
;;;794        // Месяц
;;;795        DateTime->Month     = ((Date >> 12) & 0x01) * 10 + ((Date >>  8) & 0x0f);
000024  f3c13300          UBFX     r3,r1,#12,#1
000028  eb030383          ADD      r3,r3,r3,LSL #2
00002c  f3c12403          UBFX     r4,r1,#8,#4
000030  eb040343          ADD      r3,r4,r3,LSL #1
000034  7043              STRB     r3,[r0,#1]
;;;796        // День
;;;797        DateTime->Day       = ((Date >>  4) & 0x03) * 10 + ((Date >>  0) & 0x0f);
000036  f3c11301          UBFX     r3,r1,#4,#2
00003a  f001040f          AND      r4,r1,#0xf
00003e  eb030383          ADD      r3,r3,r3,LSL #2
000042  eb040343          ADD      r3,r4,r3,LSL #1
000046  7083              STRB     r3,[r0,#2]
;;;798        // День недели
;;;799        DateTime->DayOfWeek = ((Date >> 13) & 0x07);
000048  f3c13142          UBFX     r1,r1,#13,#3
00004c  70c1              STRB     r1,[r0,#3]
;;;800        
;;;801        // Час
;;;802        DateTime->Hours     = ((Time >> 20) & 0x03) * 10 + ((Time >> 16) & 0x0f);
00004e  f3c25101          UBFX     r1,r2,#20,#2
000052  eb010181          ADD      r1,r1,r1,LSL #2
000056  f3c24303          UBFX     r3,r2,#16,#4
00005a  eb030141          ADD      r1,r3,r1,LSL #1
00005e  7101              STRB     r1,[r0,#4]
;;;803        // Минуты
;;;804        DateTime->Minutes   = ((Time >> 12) & 0x07) * 10 + ((Time >> 8) & 0x0f);
000060  f3c23102          UBFX     r1,r2,#12,#3
000064  eb010181          ADD      r1,r1,r1,LSL #2
000068  f3c22303          UBFX     r3,r2,#8,#4
00006c  eb030141          ADD      r1,r3,r1,LSL #1
000070  7141              STRB     r1,[r0,#5]
;;;805        // Секунды
;;;806        DateTime->Seconds   = ((Time >> 4) & 0x07) * 10 + ((Time >> 0) & 0x0f);
000072  f3c21102          UBFX     r1,r2,#4,#3
000076  f002030f          AND      r3,r2,#0xf
00007a  eb010181          ADD      r1,r1,r1,LSL #2
00007e  eb030141          ADD      r1,r3,r1,LSL #1
000082  7181              STRB     r1,[r0,#6]
;;;807    }
000084  bd10              POP      {r4,pc}
                          ENDP

000086  0000              DCW      0x0000
                  |L1.136|
                          DCD      0x40002804

                          AREA ||i.rtc_Init||, CODE, READONLY, ALIGN=2

                  rtc_Init PROC
;;;126    // Инициализация модуля
;;;127    void rtc_Init(void)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;128    {
;;;129    		u32 tmp=0;
;;;130    	
;;;131    	  GPIO_InitTypeDef      GPIO_InitStructure;
;;;132    	
;;;133        // Если часы запущены, делать тут нечего.
;;;134        if(RTC->ISR & RTC_ISR_INITS) return;
000004  4a68              LDR      r2,|L2.424|
000006  6810              LDR      r0,[r2,#0]
000008  06c0              LSLS     r0,r0,#27
00000a  d47c              BMI      |L2.262|
;;;135        
;;;136        // Включим тактирование PWR
;;;137        RCC->APB1ENR |= RCC_APB1ENR_PWREN;
00000c  4867              LDR      r0,|L2.428|
00000e  6801              LDR      r1,[r0,#0]
000010  f0415180          ORR      r1,r1,#0x10000000
000014  6001              STR      r1,[r0,#0]
;;;138        
;;;139        // Разрешим доступ к управляющим регистрам энергонезависимого домена
;;;140        PWR->CR |= PWR_CR_DBP;
000016  4866              LDR      r0,|L2.432|
000018  6801              LDR      r1,[r0,#0]
00001a  f4417180          ORR      r1,r1,#0x100
00001e  6001              STR      r1,[r0,#0]
;;;141       
;;;142    /*
;;;143    	//  Кварц MC306-G-06Q-32.768 (JFVNY)
;;;144    	 //  start LSE
;;;145    		RCC->BDCR |= RCC_BDCR_LSEON;
;;;146    		while ((RCC->BDCR & RCC_BDCR_LSEON) != RCC_BDCR_LSEON) {}
;;;147    		
;;;148    		RCC->BDCR |=  RCC_BDCR_BDRST;
;;;149        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;150    		
;;;151    	// Выберем его как источник тактирования RTC:
;;;152        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
;;;153        RCC->BDCR |= (RCC_BDCR_RTCSEL_0); // запишем 0b10
;;;154    		
;;;155    		   // Включим тактирование RTC
;;;156        RCC->BDCR |= RCC_BDCR_RTCEN;
;;;157    */
;;;158     
;;;159    /* RTC configuration set 
;;;160    PWR->CR |= (1<<8);	 // Access to RTC and RTC backup registers and backup SRAM enabled
;;;161    RCC->CSR &= (1<<0);	 // LSI Off
;;;162    RCC->BDCR = 0x00000000;	 // Reset BDCR register
;;;163    RCC->BDCR |= (1<<15);	 // RTC clock enable
;;;164    RCC->BDCR |= (1<<0);	 // LSE On
;;;165    RCC->BDCR &= ~(1<<2);	 // LSE not bypassed quartz On
;;;166    RCC->BDCR &= ~(1<<16);	 // Backup domain software reset not activated
;;;167    RCC->BDCR |= (0x1<<8);	 // LSE used as the RTC clock
;;;168    RTC->WPR = 0x000000CA;	 // Key protect 1
;;;169    RTC->WPR = 0x00000053;	 // Key protect 2
;;;170    RTC->ISR |= (1<<7);	 // Initialization mode On
;;;171    for(;((RTC->ISR & 0x40) == 0x00);)	// delay while initialization flag will be set
;;;172    {
;;;173    }
;;;174    */	
;;;175    	/* 
;;;176    	JFVNY MC306G06 6 50000 32768 2 9.3
;;;177    	PC14/OSC32_IN   (PC14)
;;;178    	PC15/OSC32_OUT (PC15)
;;;179    	PB2/BOOT1    (PB2)
;;;180    */
;;;181    
;;;182    
;;;183    /*
;;;184    	//     push pull out  in kvarc
;;;185    	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_14|GPIO_Pin_15;      		  //  vvod  knopka 1
;;;186    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    										// 	rezim vivoda
;;;187    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		//
;;;188    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 									//	speed
;;;189    	GPIO_Init(GPIOC, &GPIO_InitStructure); 
;;;190    
;;;191    	for(tmp=0;tmp<10000;tmp++)	// delay while initialization flag will be set
;;;192    	{ __ASM volatile ("nop"); 	}
;;;193    
;;;194    //	GPIOA->BSRR = GPIO_BSRR_BS14; // Boot the cristal 
;;;195    	GPIOA->BSRRL = GPIO_Pin_14;
;;;196    //	GPIOA->BSRRL = GPIO_Pin_15;
;;;197    	GPIOB->BSRRL = GPIO_Pin_2;
;;;198    	
;;;199    	for(tmp=0;tmp<1000000;tmp++)	
;;;200    	{ __ASM volatile ("nop"); 	}
;;;201    	
;;;202    //     analog in kvarc
;;;203    	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_14|GPIO_Pin_15;      		  //  vvod  knopka 1
;;;204    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AN;    										// 	rezim vivoda
;;;205    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;  										//GPIO_OType_PP		//
;;;206    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 									//	speed
;;;207    	GPIO_Init(GPIOC, &GPIO_InitStructure); 
;;;208    */
;;;209    
;;;210     /*
;;;211    		
;;;212    		RCC->BDCR |=  RCC_BDCR_BDRST;
;;;213        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;214    		
;;;215    	// Выберем его как источник тактирования RTC:
;;;216        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
;;;217        RCC->BDCR |= (RCC_BDCR_RTCSEL_0); // запишем 0b10
;;;218    		
;;;219    		   // Включим тактирование RTC
;;;220        RCC->BDCR |= RCC_BDCR_RTCEN;
;;;221    	*/	
;;;222    /*	
;;;223    
;;;224    Попробуйте дать ему пинка. Сконфигурируйте ноги на выход и подайте напряжение на кварц на четверть периода. Потом уже снова на вход и запускайте генератор. Заводились даже 12 пФ кварцы. Только работали нестабильно.
;;;225    	GPIOC->CRH |= GPIO_CRH_MODE14_1 |GPIO_CRH_MODE15_1; // Out 2 MHZ
;;;226    	GPIOC->CRH &= ~(GPIO_CRH_CNF14|GPIO_CRH_CNF15); // PUSH pull
;;;227    	Delay();
;;;228    	GPIOA->BSRR = GPIO_BSRR_BS14; // Boot the cristal 
;;;229    	Delay();
;;;230    	GPIOC->CRH &= ~(GPIO_CRH_MODE14_1|GPIO_CRH_MODE15_1); // Analog IN 
;;;231    	RCC->BDCR |= RCC_BDCR_LSEON;
;;;232    
;;;233    KX-38 32.768 kHz 6pF,
;;;234    		32.768kHz crystal, with 6pF CL and 50kOhm ESR. 
;;;235    		a 15MOhm parallel resistor.
;;;236    if (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
;;;237    {
;;;238    
;;;239        RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE); // Enable PWR clock 
;;;240     
;;;241     //   PWR_BackupAccessCmd(ENABLE); // Allow access to BKP Domain 
;;;242    		 RCC->CSR = RCC_CSR_LSION;
;;;243        RCC_LSEConfig(RCC_LSE_ON); // Enable the LSE oscillator 
;;;244     
;;;245        while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET) // Wait till LSE is ready
;;;246    		{
;;;247    		 __ASM volatile ("nop");   
;;;248    		}
;;;249    }
;;;250    */
;;;251    /*
;;;252        // Запускаем LSI:
;;;253        RCC->CSR |= RCC_CSR_LSION;
;;;254        
;;;255        // Ждём, когда он заведётся
;;;256        while(!(RCC->CSR & RCC_CSR_LSIRDY)) {}
;;;257        
;;;258        // Ок, генератор на 32 кГц завёлся.
;;;259        
;;;260        // Сбросим состояние энергонезависимого домена
;;;261        RCC->BDCR |=  RCC_BDCR_BDRST;
;;;262        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;263        
;;;264        // Выберем его как источник тактирования RTC:
;;;265        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
;;;266        RCC->BDCR |= (RCC_BDCR_RTCSEL_1); // запишем 0b10
;;;267          
;;;268        // Включим тактирование RTC
;;;269        RCC->BDCR |= RCC_BDCR_RTCEN;
;;;270     */
;;;271    
;;;272    /*
;;;273    ● Access to the backup SRAM
;;;274    1. Enable the power interface clock by setting the PWREN bits in the RCC APB1
;;;275    peripheral clock enable register (RCC_APB1ENR)
;;;276    2. Set the DBP bit in the PWR power control register (PWR_CR) to enable access to the
;;;277    backup domain
;;;278    3. Enable the backup SRAM clock by setting BKPSRAMEN bit in the RCC AHB1
;;;279    peripheral clock register (RCC_AHB1ENR)
;;;280    
;;;281    uint8_t *BKPRam = (uint8_t *)0x40024000;
;;;282    
;;;283    
;;;284    */
;;;285    
;;;286    if (LSE==0) 
;;;287    {
;;;288    	        // Настроим предделитель для получения частоты 1 Гц.
;;;289            
;;;290            // LSI: 
;;;291            // LSE: нужно разделить на 0x7fff (кварцы так точно рассчитаны на это)
;;;292                uint32_t Sync = 249;   // 15 бит
;;;293                uint32_t Async = 127;  // 7 бит
;;;294    	
;;;295    	
;;;296       // Запускаем LSI:
;;;297        RCC->CSR |= RCC_CSR_LSION;
;;;298        
;;;299        // Ждём, когда он заведётся
;;;300        while(!(RCC->CSR & RCC_CSR_LSIRDY)) {}
;;;301        
;;;302        // Ок, генератор на 32 кГц завёлся.
;;;303        
;;;304        // Сбросим состояние энергонезависимого домена
;;;305        RCC->BDCR |=  RCC_BDCR_BDRST;
;;;306        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;307        
;;;308        // Выберем его как источник тактирования RTC:
;;;309        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
;;;310        RCC->BDCR |= (RCC_BDCR_RTCSEL_1); // запишем 0b10
;;;311          
;;;312        // Включим тактирование RTC
;;;313        RCC->BDCR |= RCC_BDCR_RTCEN;
;;;314        
;;;315        // Снимем защиту от записи с регистров RTC
;;;316        rtc_Unlock();
;;;317    
;;;318            // Здесь можем менять регистры RTC
;;;319    
;;;320            // Войдём в режим инициализации:
;;;321            RTC->ISR |= RTC_ISR_INIT;
;;;322            
;;;323            // Ждём, когда это произойдёт
;;;324            while(!(RTC->ISR & RTC_ISR_INITF)) {}
;;;325            
;;;326            // Часы остановлены. Режим инициализации            
;;;327                // Сначала записываем величину для синхронного предделителя
;;;328                RTC->PRER = Sync;
;;;329                
;;;330                // Теперь добавим для асинхронного предделителя
;;;331                RTC->PRER = Sync | (Async << 16);		
;;;332    				}
;;;333    else {	
;;;334    		 //  start LSE
;;;335    		 RCC->BDCR |= RCC_BDCR_LSEON;
000020  4862              LDR      r0,|L2.428|
000022  3030              ADDS     r0,r0,#0x30
000024  6801              LDR      r1,[r0,#0]
000026  f0410101          ORR      r1,r1,#1
00002a  6001              STR      r1,[r0,#0]
                  |L2.44|
;;;336    		 while ((RCC->BDCR & RCC_BDCR_LSEON) != RCC_BDCR_LSEON) {}			
00002c  6801              LDR      r1,[r0,#0]
00002e  07c9              LSLS     r1,r1,#31
000030  d0fc              BEQ      |L2.44|
                  |L2.50|
;;;337    		 while (!(RCC->BDCR & RCC_BDCR_LSERDY)) {}			
000032  6801              LDR      r1,[r0,#0]
000034  0789              LSLS     r1,r1,#30
000036  d5fc              BPL      |L2.50|
;;;338    		 RCC->BDCR |= RCC_BDCR_RTCEN | RCC_BDCR_RTCSEL_0;
000038  6801              LDR      r1,[r0,#0]
00003a  f4414101          ORR      r1,r1,#0x8100
00003e  6001              STR      r1,[r0,#0]
;;;339    			
;;;340          // Снимем защиту от записи с регистров RTC
;;;341          rtc_Unlock();
000040  f7fffffe          BL       rtc_Unlock
;;;342            // Войдём в режим инициализации:
;;;343          RTC->ISR |= RTC_ISR_INIT;
000044  6810              LDR      r0,[r2,#0]
000046  f0400080          ORR      r0,r0,#0x80
00004a  6010              STR      r0,[r2,#0]
                  |L2.76|
;;;344    			while(!(RTC->ISR & RTC_ISR_INITF)) {}
00004c  6810              LDR      r0,[r2,#0]
00004e  0640              LSLS     r0,r0,#25
000050  d5fc              BPL      |L2.76|
;;;345    
;;;346    					RTC->PRER = 0x00000000; // RESET PRER register
000052  4855              LDR      r0,|L2.424|
000054  f04f0900          MOV      r9,#0
000058  1d00              ADDS     r0,r0,#4
00005a  f8c09000          STR      r9,[r0,#0]
;;;347    					RTC->PRER |= (0xFF<<0); // 255 + 1 Synchronous prescaler factor set
00005e  6801              LDR      r1,[r0,#0]
000060  f04101ff          ORR      r1,r1,#0xff
000064  6001              STR      r1,[r0,#0]
;;;348    					RTC->PRER |= (0x7F<<16); // 127 + 1 Asynchronous prescaler factor set
000066  6801              LDR      r1,[r0,#0]
000068  f44101fe          ORR      r1,r1,#0x7f0000
00006c  6001              STR      r1,[r0,#0]
;;;349    			}
;;;350    
;;;351    				
;;;352            // Устанавливаем дату: 30.05.13, пятница
;;;353    				//       rtc_SetDate(2, 6, 13, 7);       
;;;354            // Устанавливаем время: 15:00:00
;;;355    				//      rtc_SetTime(0, 0, 00);       
;;;356            // Переведём часы в 24-часовой формат
;;;357            RTC->CR |= RTC_CR_FMT;        
00006e  484e              LDR      r0,|L2.424|
000070  1f00              SUBS     r0,r0,#4
000072  6801              LDR      r1,[r0,#0]
000074  f0410140          ORR      r1,r1,#0x40
000078  6001              STR      r1,[r0,#0]
;;;358            // Инициализация закончилась
;;;359            RTC->ISR &= ~RTC_ISR_INIT;   
00007a  6810              LDR      r0,[r2,#0]
00007c  f0200080          BIC      r0,r0,#0x80
000080  6010              STR      r0,[r2,#0]
000082  4949              LDR      r1,|L2.424|
000084  20ff              MOVS     r0,#0xff
000086  3118              ADDS     r1,r1,#0x18
000088  6008              STR      r0,[r1,#0]
;;;360        rtc_Lock();
;;;361    		
;;;362    		// Allow access to BKP Domain 
;;;363    //PWR_BackupAccessCmd(ENABLE);
;;;364    
;;;365    // Write to the first RTC Backup Data Register 
;;;366    RTC_WriteBackupRegister(RTC_BKP_DR2,0xA5A5);
00008a  f24a51a5          MOV      r1,#0xa5a5
00008e  2002              MOVS     r0,#2
000090  f7fffffe          BL       RTC_WriteBackupRegister
;;;367    		
;;;368    		// Backup SRAM **************************************************************
;;;369    //Enable BKPRAM Clock 
;;;370    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
000094  2101              MOVS     r1,#1
000096  048e              LSLS     r6,r1,#18
000098  4630              MOV      r0,r6
00009a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;371    
;;;372    //Enable the Backup SRAM low power Regulator to retain it's content in VBAT mode 
;;;373    //PWR_BackupRegulatorCmd(ENABLE);
;;;374    
;;;375    // Wait until the Backup SRAM low power Regulator is ready 
;;;376    //while(PWR_GetFlagStatus(PWR_FLAG_BRR) == RESET)
;;;377    {
;;;378    }
;;;379    
;;;380     {
;;;381    	 
;;;382    	 extern st_conf conf;
;;;383    	 u32 i=0,i1=0, errorindex=0;
00009e  2400              MOVS     r4,#0
;;;384    	 
;;;385       bkp=RTC_ReadBackupRegister(RTC_BKP_DR2);
0000a0  2002              MOVS     r0,#2
0000a2  f7fffffe          BL       RTC_ReadBackupRegister
0000a6  4d43              LDR      r5,|L2.436|
;;;386    
;;;387    
;;;388    //  Backup SRAM ************************************************************
;;;389      // Enable BKPRAM Clock 
;;;390      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
0000a8  2101              MOVS     r1,#1
0000aa  8028              STRH     r0,[r5,#0]            ;385
0000ac  4630              MOV      r0,r6
0000ae  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;391    
;;;392    /*
;;;393      // Write to Backup SRAM with 32-Bit Data 
;;;394      for (i = 0; i < 0x1000; i += 4)
;;;395      {
;;;396        *(__IO uint32_t *) (BKPSRAM_BASE + i) = i;
;;;397      }
;;;398    */
;;;399    //	sizeof
;;;400      // read config rrom backup SRAM
;;;401    	 
;;;402    	 
;;;403    
;;;404    	/*
;;;405      for (i = 0; i < size; i += 2)
;;;406      {
;;;407    		(*(__IO uint16_t *) ((__IO uint16_t *) (&conf) + i))=(u16)i; //(*(__IO uint32_t *) (BKPSRAM_BASE + i));
;;;408    	}	
;;;409    */
;;;410    /*
;;;411    	conf.address=1;
;;;412    	conf.ver_po_st=2;
;;;413    	conf.ver_po_ml=3;
;;;414    	conf.tek_gr_kal=4;
;;;415    	conf.tm_antidreb=5;
;;;416    	conf.revers_group_select=6;
;;;417    	conf.revers_peredacha_select=7;
;;;418    	conf.rez8=8;
;;;419    	
;;;420    	conf.per_usr=9;
;;;421    	conf.time_max=10;
;;;422    	conf.por_rele=11;
;;;423    	conf.tm_rele_on=12;
;;;424    	conf.tm_rele_off=13;
;;;425    	conf.rez16=14;
;;;426    	
;;;427    	conf.indicators[0].numb=15;
;;;428    	conf.indicators[0].kol_cifr=16;
;;;429    	conf.indicators[1].numb=17;
;;;430    	conf.indicators[1].kol_cifr=18;
;;;431    	conf.indicators[2].numb=19;
;;;432    	conf.indicators[2].kol_cifr=20;
;;;433    	conf.indicators[3].numb=21;
;;;434    	conf.indicators[3].kol_cifr=2;
;;;435    	conf.gr_kal1.tabl1.kod[0]=23;
;;;436    	conf.gr_kal1.tabl1.fz[0]=24;
;;;437    	conf.gr_kal1.tabl2.kod[0]=25;
;;;438    	conf.gr_kal1.tabl2.fz[0]=26;
;;;439    	conf.gr_kal2.tabl1.kod[0]=27;
;;;440    	conf.gr_kal2.tabl1.fz[0]=28;
;;;441    	conf.gr_kal2.tabl2.kod[0]=29;
;;;442    	conf.gr_kal2.tabl2.fz[0]=30;
;;;443    	conf.gr_kal2.tabl2.kod[9]=31;
;;;444    	conf.gr_kal2.tabl2.fz[9]=32;
;;;445    */
;;;446    	size=sizeof(st_conf);
0000b2  21be              MOVS     r1,#0xbe
0000b4  8069              STRH     r1,[r5,#2]
;;;447    	
;;;448    	for (i = 0; i < size; i += 1)
;;;449      {
;;;450    		(*(__IO uint8_t *) ((__IO uint8_t *) (&conf) + i))=(*(__IO uint8_t *) (BKPSRAM_BASE + i));
0000b6  4840              LDR      r0,|L2.440|
0000b8  4d40              LDR      r5,|L2.444|
                  |L2.186|
0000ba  5c22              LDRB     r2,[r4,r0]
0000bc  552a              STRB     r2,[r5,r4]
0000be  1c64              ADDS     r4,r4,#1              ;448
0000c0  428c              CMP      r4,r1                 ;448
0000c2  d3fa              BCC      |L2.186|
;;;451    	}	
;;;452    	
;;;453    		kol_usr=conf.per_usr;
0000c4  493e              LDR      r1,|L2.448|
0000c6  8928              LDRH     r0,[r5,#8]  ; conf
0000c8  f04f0401          MOV      r4,#1                 ;370
0000cc  8008              STRH     r0,[r1,#0]
;;;454    		conf.tm_antidreb=conf.tm_antidreb*10;
0000ce  7928              LDRB     r0,[r5,#4]  ; conf
0000d0  eb000080          ADD      r0,r0,r0,LSL #2
0000d4  0640              LSLS     r0,r0,#25
0000d6  0e00              LSRS     r0,r0,#24
0000d8  7128              STRB     r0,[r5,#4]
;;;455    	
;;;456    		if (conf.tm_antidreb==0)
0000da  d100              BNE      |L2.222|
;;;457    				conf.tm_antidreb=1;
0000dc  712c              STRB     r4,[r5,#4]
                  |L2.222|
;;;458    
;;;459    //	RCC_APB2PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE); 
;;;460    	GPIO_InitStructure.GPIO_Pin   = PIN_RELE;      		//  vivod RELE
0000de  2010              MOVS     r0,#0x10
;;;461    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    // rezim vivoda
0000e0  f88d4004          STRB     r4,[sp,#4]
;;;462    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
;;;463    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //speed
;;;464    	GPIO_Init(PORT_RELE, &GPIO_InitStructure); 
0000e4  f8dfa0dc          LDR      r10,|L2.452|
0000e8  9000              STR      r0,[sp,#0]            ;461
0000ea  f88d4006          STRB     r4,[sp,#6]            ;462
0000ee  2602              MOVS     r6,#2                 ;463
0000f0  f88d6005          STRB     r6,[sp,#5]            ;463
0000f4  4669              MOV      r1,sp
0000f6  4650              MOV      r0,r10
0000f8  f7fffffe          BL       GPIO_Init
;;;465    
;;;466    	GPIO_InitStructure.GPIO_Pin   = PIN_L1;      		//  vivod svetodiod knopka 1
0000fc  2740              MOVS     r7,#0x40
;;;467    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    // rezim vivoda
0000fe  9700              STR      r7,[sp,#0]
000100  f88d4004          STRB     r4,[sp,#4]
;;;468    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
000104  e000              B        |L2.264|
                  |L2.262|
000106  e049              B        |L2.412|
                  |L2.264|
;;;469    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //speed
;;;470    	GPIO_Init(PORT_L1, &GPIO_InitStructure); 
000108  f8dfb0bc          LDR      r11,|L2.456|
00010c  f88d4006          STRB     r4,[sp,#6]            ;468
000110  f88d6005          STRB     r6,[sp,#5]            ;469
000114  4669              MOV      r1,sp
000116  4658              MOV      r0,r11
000118  f7fffffe          BL       GPIO_Init
;;;471    	
;;;472    	GPIO_InitStructure.GPIO_Pin   = PIN_L2;      		  //  vivod svetodiod knopka 2
;;;473    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    // rezim vivoda
00011c  f88d4004          STRB     r4,[sp,#4]
000120  f44f7880          MOV      r8,#0x100             ;472
;;;474    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
000124  f88d4006          STRB     r4,[sp,#6]
000128  f8cd8000          STR      r8,[sp,#0]            ;473
;;;475    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //speed
00012c  f88d6005          STRB     r6,[sp,#5]
;;;476    	GPIO_Init(PORT_L2, &GPIO_InitStructure); 
000130  4669              MOV      r1,sp
000132  4658              MOV      r0,r11
000134  f7fffffe          BL       GPIO_Init
;;;477    
;;;478    	GPIO_InitStructure.GPIO_Pin   = PIN_K1;      		  //  vvod  knopka 1
000138  2080              MOVS     r0,#0x80
;;;479    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;    // 	rezim vivoda
00013a  f88d9004          STRB     r9,[sp,#4]
00013e  9000              STR      r0,[sp,#0]
;;;480    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
000140  f88d4006          STRB     r4,[sp,#6]
;;;481    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //	speed
000144  f88d6005          STRB     r6,[sp,#5]
;;;482    	GPIO_Init(PORT_K1, &GPIO_InitStructure); 
000148  4669              MOV      r1,sp
00014a  4658              MOV      r0,r11
00014c  f7fffffe          BL       GPIO_Init
;;;483    	
;;;484    	GPIO_InitStructure.GPIO_Pin   = PIN_K2;      		  //  vvod  knopka 2
000150  0230              LSLS     r0,r6,#8
;;;485    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;    // 	rezim vivoda
000152  f88d9004          STRB     r9,[sp,#4]
000156  9000              STR      r0,[sp,#0]
;;;486    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
000158  f88d4006          STRB     r4,[sp,#6]
;;;487    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //	speed
00015c  f88d6005          STRB     r6,[sp,#5]
;;;488    	GPIO_Init(PORT_K2, &GPIO_InitStructure); 
000160  4669              MOV      r1,sp
000162  4658              MOV      r0,r11
000164  f7fffffe          BL       GPIO_Init
;;;489    	
;;;490    	if (conf.tek_gr_kal==0)
;;;491    	{
;;;492    		//  dr kal ==0 - pervaya
;;;493    		PORT_L1->BSRRL = PIN_L1;  // on  PIN_L1
000168  4917              LDR      r1,|L2.456|
00016a  78ea              LDRB     r2,[r5,#3]            ;490  ; conf
00016c  3118              ADDS     r1,r1,#0x18
;;;494    	  PORT_L2->BSRRH = PIN_L2;	// off PIN_L2
00016e  1c88              ADDS     r0,r1,#2
000170  b1b2              CBZ      r2,|L2.416|
;;;495    	}
;;;496    	else
;;;497    	{
;;;498    		//  dr kal ==1 - vtoraya
;;;499    		PORT_L1->BSRRH = PIN_L1;  // off  PIN_L1
000172  8007              STRH     r7,[r0,#0]
;;;500    	  PORT_L2->BSRRL = PIN_L2;	// on   PIN_L2
000174  f8a18000          STRH     r8,[r1,#0]
                  |L2.376|
;;;501    	}
;;;502          
;;;503    		sost_flesh=0;	
000178  4814              LDR      r0,|L2.460|
;;;504    		PORT_ZAP_EN->BSRRH = PIN_ZAP_EN;  // off  PORT_ZAP_EN
00017a  f44f5200          MOV      r2,#0x2000
00017e  f8809000          STRB     r9,[r0,#0]            ;503
000182  f8aa201a          STRH     r2,[r10,#0x1a]
;;;505    		PORT_ZAP_DIS->BSRRL = PIN_ZAP_DIS;  // on  PORT_ZAP_DIS
000186  0052              LSLS     r2,r2,#1
000188  f8aa2018          STRH     r2,[r10,#0x18]
;;;506    		
;;;507    		avariya=0;
00018c  4a10              LDR      r2,|L2.464|
;;;508    		PORT_AVARIYA->BSRRH = PIN_AVARIYA;               			
00018e  f44f4100          MOV      r1,#0x8000
000192  f8829000          STRB     r9,[r2,#0]            ;507
000196  f8aa101a          STRH     r1,[r10,#0x1a]
;;;509    	
;;;510    	/*
;;;511    		conf.por_rele
;;;512    	  conf.time_max
;;;513    	  conf.tm_antidreb
;;;514    		conf.tm_rele_off
;;;515    		conf.tm_rele_on
;;;516    		conf.
;;;517    	*/	
;;;518    	
;;;519    	/*
;;;520    	for (i = 0; i < size; i += 1)
;;;521      {
;;;522        *(__IO uint8_t *) (BKPSRAM_BASE + i) = 0;
;;;523      }
;;;524    	*/
;;;525    	
;;;526    	/*
;;;527    	for (i = 0; i < size; i += 1)
;;;528      {
;;;529        *(__IO uint8_t *) (BKPSRAM_BASE + i) = *(__IO uint8_t *) ((__IO uint8_t *) (&conf) + i);
;;;530      }
;;;531    	*/
;;;532    	
;;;533    	
;;;534    /*
;;;535    	conf.address=255;
;;;536    	conf.ver_po_st=255;
;;;537    	conf.ver_po_ml=255;
;;;538    	conf.per_usr=255;
;;;539    	conf.time_max=255;
;;;540    	conf.tek_gr_kal=255;
;;;541    	conf.gr_kal1.tabl1.fz[0]=255;
;;;542    	conf.gr_kal1.tabl1.kod[0]=255;
;;;543    	conf.gr_kal1.tabl2.fz[0]=255;
;;;544    	conf.gr_kal1.tabl2.kod[0]=255;
;;;545    	
;;;546    	conf.gr_kal2.tabl1.fz[0]=255;
;;;547    	conf.gr_kal2.tabl1.kod[0]=255;
;;;548    	conf.gr_kal2.tabl2.fz[0]=255;
;;;549    	conf.gr_kal2.tabl2.kod[0]=255;
;;;550    	conf.revers_group_select=255;
;;;551    	conf.revers_peredacha_select=255;
;;;552    	conf.tm_antidreb=255;
;;;553    	conf.por_rele=255;
;;;554    	conf.tm_rele_on=255;
;;;555    	conf.tm_rele_off=255;
;;;556    	conf.indicators[0].numb=255;
;;;557    	conf.indicators[0].kol_cifr=255;
;;;558    	conf.indicators[1].numb=255;
;;;559    	conf.indicators[1].kol_cifr=255;
;;;560    	conf.indicators[2].numb=255;
;;;561    	conf.indicators[2].kol_cifr=255;
;;;562    	conf.indicators[3].numb=255;
;;;563    	conf.indicators[3].kol_cifr=255;
;;;564    	*/
;;;565    	/*
;;;566    	// test read config to comp
;;;567    	conf.address=1;
;;;568    	conf.ver_po_st=2;
;;;569    	conf.ver_po_ml=3;
;;;570    	conf.tek_gr_kal=4;
;;;571    	conf.tm_antidreb=5;
;;;572    	conf.revers_group_select=6;
;;;573    	conf.revers_peredacha_select=7;
;;;574    	conf.rez8=8;
;;;575    	
;;;576    	conf.per_usr=9;
;;;577    	conf.time_max=10;
;;;578    	conf.por_rele=11;
;;;579    	conf.tm_rele_on=12;
;;;580    	conf.tm_rele_off=13;
;;;581    	conf.rez16=14;
;;;582    	
;;;583    	conf.indicators[0].numb=15;
;;;584    	conf.indicators[0].kol_cifr=16;
;;;585    	conf.indicators[1].numb=17;
;;;586    	conf.indicators[1].kol_cifr=18;
;;;587    	conf.indicators[2].numb=19;
;;;588    	conf.indicators[2].kol_cifr=20;
;;;589    	conf.indicators[3].numb=21;
;;;590    	conf.indicators[3].kol_cifr=2;
;;;591    	conf.gr_kal1.tabl1.kod[0]=23;
;;;592    	conf.gr_kal1.tabl1.fz[0]=24;
;;;593    	conf.gr_kal1.tabl2.kod[0]=25;
;;;594    	conf.gr_kal1.tabl2.fz[0]=26;
;;;595    	conf.gr_kal2.tabl1.kod[0]=27;
;;;596    	conf.gr_kal2.tabl1.fz[0]=28;
;;;597    	conf.gr_kal2.tabl2.kod[0]=29;
;;;598    	conf.gr_kal2.tabl2.fz[0]=30;
;;;599    	conf.gr_kal2.tabl2.kod[9]=31;
;;;600    	conf.gr_kal2.tabl2.fz[9]=32;
;;;601    	
;;;602    */
;;;603    	
;;;604    }
;;;605    	
;;;606    __ASM volatile ("nop");
00019a  bf00              NOP      
                  |L2.412|
;;;607    
;;;608        
;;;609        // Всё, часы запустились и считают время.
;;;610    		/*
;;;611    		
;;;612    		/разрешить тактирование модулей управления питанием и управлением резервной областью
;;;613      RCC->APB1ENR |= RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN;
;;;614      //разрешить доступ к области резервных данных
;;;615      PWR->CR |= PWR_CR_DBP;
;;;616      //если часы выключены - инициализировать их
;;;617      if ((RCC->BDCR & RCC_BDCR_RTCEN) != RCC_BDCR_RTCEN)
;;;618      {
;;;619        //выполнить сброс области резервных данных
;;;620        RCC->BDCR |=  RCC_BDCR_BDRST;
;;;621        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;622     
;;;623        //выбрать источником тактовых импульсов внешний кварц 32768 и подать тактирование
;;;624        RCC->BDCR |=  RCC_BDCR_RTCEN | RCC_BDCR_RTCSEL_LSE;
;;;625     
;;;626        RTC->CRL  |=  RTC_CRL_CNF;
;;;627        RTC->PRLL  = 0x7FFF;         //регистр деления на 32768
;;;628        RTC->CRL  &=  ~RTC_CRL_CNF;
;;;629     
;;;630        //установить бит разрешения работы и дождаться установки бита готовности
;;;631        RCC->BDCR |= RCC_BDCR_LSEON;
;;;632        while ((RCC->BDCR & RCC_BDCR_LSEON) != RCC_BDCR_LSEON){}
;;;633     
;;;634        RTC->CRL &= (uint16_t)~RTC_CRL_RSF;
;;;635        while((RTC->CRL & RTC_CRL_RSF) != RTC_CRL_RSF){}
;;;636     
;;;637        return 1;
;;;638      }
;;;639      return 0;
;;;640    	*/
;;;641    	
;;;642    	
;;;643    	/*
;;;644    	
;;;645    	// one more init кес
;;;646    	
;;;647    	RTC_InitTypeDef RTC_InitStructure;
;;;648    RTC_TimeTypeDef RTC_TimeStructure;
;;;649    RTC_DateTypeDef RTC_DateStructure;
;;;650    __IO uint32_t AsynchPrediv = 0, SynchPrediv = 0;
;;;651    __IO uint32_t TimeDisplay = 0;
;;;652    
;;;653    
;;;654    		// Enable the PWR APB1 Clock Interface 
;;;655    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
;;;656    
;;;657    //Allow access to BKP Domain 
;;;658    PWR_BackupAccessCmd(ENABLE);
;;;659      
;;;660    if (RTC_ReadBackupRegister(RTC_BKP_DR2) != 0xA5A5) {
;;;661    
;;;662    //Enable the PWR clock 
;;;663    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
;;;664    
;;;665    // Allow access to RTC 
;;;666    PWR_BackupAccessCmd(ENABLE);
;;;667    
;;;668    #if defined (RTC_CLOCK_SOURCE_LSI) // LSI used as RTC source clock
;;;669    // The RTC Clock may varies due to LSI frequency dispersion. 
;;;670    // Enable the LSI OSC 
;;;671    RCC_LSICmd(ENABLE);
;;;672    
;;;673    // Wait till LSI is ready 
;;;674    while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
;;;675    {
;;;676    }
;;;677    
;;;678    // Select the RTC Clock Source 
;;;679    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
;;;680    
;;;681    SynchPrediv = 0xFF;
;;;682    AsynchPrediv = 0x7F;
;;;683    
;;;684    #elif defined (RTC_CLOCK_SOURCE_LSE) // LSE used as RTC source clock 
;;;685    // Enable the LSE OSC 
;;;686    RCC_LSEConfig(RCC_LSE_ON);
;;;687    
;;;688    // Wait till LSE is ready 
;;;689    while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
;;;690    {
;;;691    }
;;;692    
;;;693    // Select the RTC Clock Source 
;;;694    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
;;;695    
;;;696    SynchPrediv = 0xFF;
;;;697    AsynchPrediv = 0x7F;
;;;698    
;;;699    #else
;;;700    #error Please select the RTC Clock source inside the main.c file
;;;701    #endif // RTC_CLOCK_SOURCE_LSI 
;;;702    
;;;703    // Enable the RTC Clock 
;;;704    RCC_RTCCLKCmd(ENABLE);
;;;705    
;;;706    // Wait for RTC APB registers synchronisation 
;;;707    RTC_WaitForSynchro();
;;;708    
;;;709    // Allow access to BKP Domain 
;;;710    PWR_BackupAccessCmd(ENABLE);
;;;711    
;;;712    // Write to the first RTC Backup Data Register 
;;;713    RTC_WriteBackupRegister(RTC_BKP_DR2,0xA5A5);
;;;714    
;;;715    //Set the Time 
;;;716    RTC_TimeStructure.RTC_Hours = 22;
;;;717    RTC_TimeStructure.RTC_Minutes = 11;
;;;718    RTC_TimeStructure.RTC_Seconds = 00;
;;;719    
;;;720    // Set the Date 
;;;721    RTC_DateStructure.RTC_Month = 4;
;;;722    RTC_DateStructure.RTC_Date = 29;
;;;723    RTC_DateStructure.RTC_Year = 11;
;;;724    RTC_DateStructure.RTC_WeekDay = RTC_Weekday_Friday;
;;;725    
;;;726    //Calendar Configuration 
;;;727    RTC_InitStructure.RTC_AsynchPrediv = AsynchPrediv;
;;;728    RTC_InitStructure.RTC_SynchPrediv = SynchPrediv;
;;;729    RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24;
;;;730    RTC_Init(&RTC_InitStructure);
;;;731    
;;;732    // Set Current Time and Date 
;;;733    RTC_SetTime(RTC_Format_BIN, &RTC_TimeStructure);
;;;734    RTC_SetDate(RTC_Format_BIN, &RTC_DateStructure);
;;;735    #if 0
;;;736    //Configure the RTC Wakeup Clock source and Counter (Wakeup event each 1 second) 
;;;737    RTC_WakeUpClockConfig(RTC_WakeUpClock_RTCCLK_Div16);
;;;738    RTC_SetWakeUpCounter(0x7FF);
;;;739    
;;;740    // Enable the Wakeup Interrupt 
;;;741    RTC_ITConfig(RTC_IT_WUT, ENABLE);
;;;742    
;;;743    //Enable Wakeup Counter 
;;;744    RTC_WakeUpCmd(ENABLE);
;;;745    #endif
;;;746    // Backup SRAM **************************************************************
;;;747    //Enable BKPRAM Clock 
;;;748    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
;;;749    
;;;750    //Enable the Backup SRAM low power Regulator to retain it's content in VBAT mode 
;;;751    PWR_BackupRegulatorCmd(ENABLE);
;;;752    
;;;753    // Wait until the Backup SRAM low power Regulator is ready 
;;;754    while(PWR_GetFlagStatus(PWR_FLAG_BRR) == RESET)
;;;755    {
;;;756    }
;;;757    
;;;758    }
;;;759    else{
;;;760    
;;;761    // Enable the PWR clock 
;;;762    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
;;;763    
;;;764    // Allow access to RTC 
;;;765    PWR_BackupAccessCmd(ENABLE);
;;;766    
;;;767    // Wait for RTC APB registers synchronisation 
;;;768    RTC_WaitForSynchro();
;;;769    // Clear the Wakeup Interrupt 
;;;770    RTC_ClearITPendingBit(RTC_IT_WUT);
;;;771    
;;;772    // Backup SRAM **************************************************************
;;;773    // Enable BKPSRAM Clock 
;;;774    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
;;;775    }
;;;776    
;;;777    
;;;778    	
;;;779    	*/
;;;780    	
;;;781    }
00019c  e8bd9ffc          POP      {r2-r12,pc}
                  |L2.416|
0001a0  800f              STRH     r7,[r1,#0]            ;493
0001a2  f8a08000          STRH     r8,[r0,#0]            ;494
0001a6  e7e7              B        |L2.376|
;;;782    
                          ENDP

                  |L2.424|
                          DCD      0x4000280c
                  |L2.428|
                          DCD      0x40023840
                  |L2.432|
                          DCD      0x40007000
                  |L2.436|
                          DCD      ||.data||
                  |L2.440|
                          DCD      0x40024000
                  |L2.444|
                          DCD      conf
                  |L2.448|
                          DCD      kol_usr
                  |L2.452|
                          DCD      0x40020000
                  |L2.456|
                          DCD      0x40020800
                  |L2.460|
                          DCD      sost_flesh
                  |L2.464|
                          DCD      avariya

                          AREA ||i.rtc_Lock||, CODE, READONLY, ALIGN=2

                  rtc_Lock PROC
;;;24     // Включить защиту от записи
;;;25      void rtc_Lock(void)
000000  4901              LDR      r1,|L3.8|
;;;26     {
;;;27         // Запишем какую-нибудь фигню, главное, чтоб не правильную
;;;28         RTC->WPR = 0xFF;
000002  20ff              MOVS     r0,#0xff
000004  6008              STR      r0,[r1,#0]
;;;29     }
000006  4770              BX       lr
;;;30     
                          ENDP

                  |L3.8|
                          DCD      0x40002824

                          AREA ||i.rtc_Reset||, CODE, READONLY, ALIGN=2

                  rtc_Reset PROC
;;;112    // Сброс состояния часов
;;;113    void rtc_Reset(void)
000000  480a              LDR      r0,|L4.44|
;;;114    {
;;;115        // Включим тактирование PWR
;;;116        RCC->APB1ENR |= RCC_APB1ENR_PWREN;
000002  6801              LDR      r1,[r0,#0]
000004  f0415180          ORR      r1,r1,#0x10000000
000008  6001              STR      r1,[r0,#0]
;;;117        
;;;118        // Разрешим доступ к управляющим регистрам энергонезависимого домена
;;;119        PWR->CR |= PWR_CR_DBP;
00000a  4809              LDR      r0,|L4.48|
00000c  6801              LDR      r1,[r0,#0]
00000e  f4417180          ORR      r1,r1,#0x100
000012  6001              STR      r1,[r0,#0]
;;;120        
;;;121        // Выберем его как источник тактирования RTC:
;;;122        RCC->BDCR |=  RCC_BDCR_BDRST;
000014  4805              LDR      r0,|L4.44|
000016  3030              ADDS     r0,r0,#0x30
000018  6801              LDR      r1,[r0,#0]
00001a  f4413180          ORR      r1,r1,#0x10000
00001e  6001              STR      r1,[r0,#0]
;;;123        RCC->BDCR &= ~RCC_BDCR_BDRST;
000020  6801              LDR      r1,[r0,#0]
000022  f4213180          BIC      r1,r1,#0x10000
000026  6001              STR      r1,[r0,#0]
;;;124    }
000028  4770              BX       lr
;;;125    
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      0x40023840
                  |L4.48|
                          DCD      0x40007000

                          AREA ||i.rtc_SetDate||, CODE, READONLY, ALIGN=2

                  rtc_SetDate PROC
;;;31     // Установить дату
;;;32     void rtc_SetDate(uint8_t Day, uint8_t Month, uint8_t Year, uint8_t DayOfWeek)
000000  b5f0              PUSH     {r4-r7,lr}
;;;33     {
;;;34         uint32_t Tens, Units;
;;;35         uint32_t TempReg = 0;
;;;36         
;;;37         // Очистим поле даты
;;;38         TempReg = 0;
;;;39         
;;;40         // Запишем год
;;;41         {
;;;42             Tens  = (Year / 10) & 0x0f;          // Десятки лет
000002  260a              MOVS     r6,#0xa
000004  fbb2f4f6          UDIV     r4,r2,r6
000008  f004040f          AND      r4,r4,#0xf
;;;43             Units = (Year - (Tens * 10)) & 0x0f; // Единицы лет
00000c  4265              RSBS     r5,r4,#0
00000e  eb050585          ADD      r5,r5,r5,LSL #2
000012  2700              MOVS     r7,#0                 ;35
000014  eb020245          ADD      r2,r2,r5,LSL #1
000018  f002020f          AND      r2,r2,#0xf
;;;44             
;;;45             TempReg |= (Tens  << 20); // YT, 20
00001c  ea475404          ORR      r4,r7,r4,LSL #20
;;;46             TempReg |= (Units << 16); // YU, 16
000020  ea444502          ORR      r5,r4,r2,LSL #16
;;;47         }
;;;48         // Запишем месяц
;;;49         {
;;;50             Tens  = (Month / 10) & 0x01;          // Десятки месяцев
000024  fbb1f2f6          UDIV     r2,r1,r6
000028  f0020201          AND      r2,r2,#1
;;;51             Units = (Month - (Tens * 10)) & 0x0f; // Единицы месяцев
00002c  4254              RSBS     r4,r2,#0
00002e  eb040484          ADD      r4,r4,r4,LSL #2
000032  eb010144          ADD      r1,r1,r4,LSL #1
000036  f001010f          AND      r1,r1,#0xf
;;;52             
;;;53             TempReg |= (Tens  << 12); // MT, 12
00003a  ea453202          ORR      r2,r5,r2,LSL #12
;;;54             TempReg |= (Units << 8);  // MU, 8
00003e  ea422401          ORR      r4,r2,r1,LSL #8
;;;55         }
;;;56         // Запишем день
;;;57         {
;;;58             Tens  = (Day / 10) & 0x03;          // Десятки дней
000042  fbb0f1f6          UDIV     r1,r0,r6
000046  f0010103          AND      r1,r1,#3
;;;59             Units = (Day - (Tens * 10)) & 0x0f; // Единицы дней
00004a  424a              RSBS     r2,r1,#0
00004c  eb020282          ADD      r2,r2,r2,LSL #2
000050  eb000042          ADD      r0,r0,r2,LSL #1
000054  f000020f          AND      r2,r0,#0xf
;;;60             
;;;61             TempReg |= (Tens  << 4); // DT, 4
000058  ea441001          ORR      r0,r4,r1,LSL #4
;;;62             TempReg |= (Units << 0);  // DU, 0
00005c  4310              ORRS     r0,r0,r2
;;;63         }
;;;64         // День недели:
;;;65         {
;;;66             TempReg |= ((DayOfWeek & 0x07) << 13); // WDU, 13
00005e  f0030107          AND      r1,r3,#7
000062  ea403041          ORR      r0,r0,r1,LSL #13
;;;67         }
;;;68         
;;;69         // Записывать надо всё сразу
;;;70         RTC->DR = TempReg;
000066  4901              LDR      r1,|L5.108|
000068  6008              STR      r0,[r1,#0]
;;;71     }
00006a  bdf0              POP      {r4-r7,pc}
;;;72     
                          ENDP

                  |L5.108|
                          DCD      0x40002804

                          AREA ||i.rtc_SetTime||, CODE, READONLY, ALIGN=2

                  rtc_SetTime PROC
;;;74     //static void rtc_SetTime(uint8_t Hours, uint8_t Minutes, uint8_t Seconds)
;;;75     void rtc_SetTime(uint8_t Hours, uint8_t Minutes, uint8_t Seconds)
000000  b570              PUSH     {r4-r6,lr}
;;;76     {
;;;77         uint32_t Tens, Units;
;;;78         uint32_t TempReg = 0;
;;;79         
;;;80         // Очистим поле даты
;;;81         TempReg = 0;
;;;82         
;;;83         // Запишем часы
;;;84         {
;;;85             Tens  = (Hours / 10) & 0x03;          // Десятки часов
000002  250a              MOVS     r5,#0xa
000004  fbb0f3f5          UDIV     r3,r0,r5
000008  f0030303          AND      r3,r3,#3
;;;86             Units = (Hours - (Tens * 10)) & 0x0f; // Единицы часов
00000c  425c              RSBS     r4,r3,#0
00000e  eb040484          ADD      r4,r4,r4,LSL #2
000012  2600              MOVS     r6,#0                 ;78
000014  eb000044          ADD      r0,r0,r4,LSL #1
000018  f000000f          AND      r0,r0,#0xf
;;;87             
;;;88             TempReg |= (Tens  << 20); // HT, 20
00001c  ea465303          ORR      r3,r6,r3,LSL #20
;;;89             TempReg |= (Units << 16); // HU, 16
000020  ea434400          ORR      r4,r3,r0,LSL #16
;;;90         }
;;;91         // Запишем минуты
;;;92         {
;;;93             Tens  = (Minutes / 10) & 0x07;          // Десятки минут
000024  fbb1f0f5          UDIV     r0,r1,r5
000028  f0000007          AND      r0,r0,#7
;;;94             Units = (Minutes - (Tens * 10)) & 0x0f; // Единицы минут
00002c  4243              RSBS     r3,r0,#0
00002e  eb030383          ADD      r3,r3,r3,LSL #2
000032  eb010143          ADD      r1,r1,r3,LSL #1
000036  f001010f          AND      r1,r1,#0xf
;;;95             
;;;96             TempReg |= (Tens  << 12); // MNT, 12
00003a  ea443000          ORR      r0,r4,r0,LSL #12
;;;97             TempReg |= (Units << 8);  // MNU, 8
00003e  ea402301          ORR      r3,r0,r1,LSL #8
;;;98         }
;;;99         // Запишем секунды
;;;100        {
;;;101            Tens  = (Seconds / 10) & 0x07;          // Десятки секунд
000042  fbb2f0f5          UDIV     r0,r2,r5
000046  f0000007          AND      r0,r0,#7
;;;102            Units = (Seconds - (Tens * 10)) & 0x0f; // Единицы секунд
00004a  4241              RSBS     r1,r0,#0
00004c  eb010181          ADD      r1,r1,r1,LSL #2
000050  eb020141          ADD      r1,r2,r1,LSL #1
000054  f001010f          AND      r1,r1,#0xf
;;;103            
;;;104            TempReg |= (Tens  << 4); // ST, 4
000058  ea431000          ORR      r0,r3,r0,LSL #4
;;;105            TempReg |= (Units << 0);  // SU, 0
00005c  4308              ORRS     r0,r0,r1
;;;106        }
;;;107        
;;;108        // Записывать надо всё сразу
;;;109        RTC->TR = TempReg;
00005e  4901              LDR      r1,|L6.100|
000060  6008              STR      r0,[r1,#0]
;;;110    }
000062  bd70              POP      {r4-r6,pc}
;;;111    
                          ENDP

                  |L6.100|
                          DCD      0x40002800

                          AREA ||i.rtc_Unlock||, CODE, READONLY, ALIGN=2

                  rtc_Unlock PROC
;;;16     // Выключить защиту от записи
;;;17     void rtc_Unlock(void)
000000  4802              LDR      r0,|L7.12|
;;;18     {
;;;19         // Запишем эти значения по очереди
;;;20         RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6001              STR      r1,[r0,#0]
;;;21         RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6001              STR      r1,[r0,#0]
;;;22     }
00000a  4770              BX       lr
;;;23     
                          ENDP

                  |L7.12|
                          DCD      0x40002824

                          AREA ||.data||, DATA, ALIGN=1

                  bkp
000000  0000              DCW      0x0000
                  size
000002  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "src\\rtc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_rtc_c_bkp____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___5_rtc_c_bkp____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_rtc_c_bkp____REVSH|
#line 128
|__asm___5_rtc_c_bkp____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
