; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\MEDIA_USB_KEY\rtc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\MEDIA_USB_KEY\rtc.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\MEDIA_USB_KEY\rtc.crf src\rtc.c]
                          THUMB

                          AREA ||i.rtc_Get||, CODE, READONLY, ALIGN=2

                  rtc_Get PROC
;;;229    // Получить текущее время
;;;230    void rtc_Get(TDateTime * DateTime)
000000  4921              LDR      r1,|L1.136|
;;;231    {
000002  b510              PUSH     {r4,lr}
;;;232        uint32_t Date = RTC->DR;
000004  6809              LDR      r1,[r1,#0]
;;;233        uint32_t Time = RTC->TR;
000006  4a20              LDR      r2,|L1.136|
000008  1f12              SUBS     r2,r2,#4
00000a  6812              LDR      r2,[r2,#0]
;;;234        
;;;235        // Очистим
;;;236        memset(DateTime, 0, sizeof(*DateTime));
00000c  2300              MOVS     r3,#0
00000e  6003              STR      r3,[r0,#0]
000010  8083              STRH     r3,[r0,#4]
;;;237        
;;;238        // Год
;;;239        DateTime->Year      = ((Date >> 20) & 0x0f) * 10 + ((Date >> 16) & 0x0f);
000012  f3c15303          UBFX     r3,r1,#20,#4
000016  eb030383          ADD      r3,r3,r3,LSL #2
00001a  f3c14403          UBFX     r4,r1,#16,#4
00001e  eb040343          ADD      r3,r4,r3,LSL #1
000022  7003              STRB     r3,[r0,#0]
;;;240        // Месяц
;;;241        DateTime->Month     = ((Date >> 12) & 0x01) * 10 + ((Date >>  8) & 0x0f);
000024  f3c13300          UBFX     r3,r1,#12,#1
000028  eb030383          ADD      r3,r3,r3,LSL #2
00002c  f3c12403          UBFX     r4,r1,#8,#4
000030  eb040343          ADD      r3,r4,r3,LSL #1
000034  7043              STRB     r3,[r0,#1]
;;;242        // День
;;;243        DateTime->Day       = ((Date >>  4) & 0x03) * 10 + ((Date >>  0) & 0x0f);
000036  f3c11301          UBFX     r3,r1,#4,#2
00003a  f001040f          AND      r4,r1,#0xf
00003e  eb030383          ADD      r3,r3,r3,LSL #2
000042  eb040343          ADD      r3,r4,r3,LSL #1
000046  7083              STRB     r3,[r0,#2]
;;;244        // День недели
;;;245        DateTime->DayOfWeek = ((Date >> 13) & 0x07);
000048  f3c13142          UBFX     r1,r1,#13,#3
00004c  70c1              STRB     r1,[r0,#3]
;;;246        
;;;247        // Час
;;;248        DateTime->Hours     = ((Time >> 20) & 0x03) * 10 + ((Time >> 16) & 0x0f);
00004e  f3c25101          UBFX     r1,r2,#20,#2
000052  eb010181          ADD      r1,r1,r1,LSL #2
000056  f3c24303          UBFX     r3,r2,#16,#4
00005a  eb030141          ADD      r1,r3,r1,LSL #1
00005e  7101              STRB     r1,[r0,#4]
;;;249        // Минуты
;;;250        DateTime->Minutes   = ((Time >> 12) & 0x07) * 10 + ((Time >> 8) & 0x0f);
000060  f3c23102          UBFX     r1,r2,#12,#3
000064  eb010181          ADD      r1,r1,r1,LSL #2
000068  f3c22303          UBFX     r3,r2,#8,#4
00006c  eb030141          ADD      r1,r3,r1,LSL #1
000070  7141              STRB     r1,[r0,#5]
;;;251        // Секунды
;;;252        DateTime->Seconds   = ((Time >> 4) & 0x07) * 10 + ((Time >> 0) & 0x0f);
000072  f3c21102          UBFX     r1,r2,#4,#3
000076  f002030f          AND      r3,r2,#0xf
00007a  eb010181          ADD      r1,r1,r1,LSL #2
00007e  eb030141          ADD      r1,r3,r1,LSL #1
000082  7181              STRB     r1,[r0,#6]
;;;253    }
000084  bd10              POP      {r4,pc}
                          ENDP

000086  0000              DCW      0x0000
                  |L1.136|
                          DCD      0x40002804

                          AREA ||i.rtc_Init||, CODE, READONLY, ALIGN=2

                  rtc_Init PROC
;;;119    // Инициализация модуля
;;;120    void rtc_Init(void)
000000  4929              LDR      r1,|L2.168|
;;;121    {
;;;122        // Если часы запущены, делать тут нечего.
;;;123        if(RTC->ISR & RTC_ISR_INITS) return;
000002  6808              LDR      r0,[r1,#0]
000004  06c0              LSLS     r0,r0,#27
000006  d44e              BMI      |L2.166|
;;;124        
;;;125        // Включим тактирование PWR
;;;126        RCC->APB1ENR |= RCC_APB1ENR_PWREN;
000008  4828              LDR      r0,|L2.172|
00000a  6802              LDR      r2,[r0,#0]
00000c  f0425280          ORR      r2,r2,#0x10000000
000010  6002              STR      r2,[r0,#0]
;;;127        
;;;128        // Разрешим доступ к управляющим регистрам энергонезависимого домена
;;;129        PWR->CR |= PWR_CR_DBP;
000012  4827              LDR      r0,|L2.176|
000014  6802              LDR      r2,[r0,#0]
000016  f4427280          ORR      r2,r2,#0x100
00001a  6002              STR      r2,[r0,#0]
;;;130        
;;;131        // Запускаем LSI:
;;;132        RCC->CSR |= RCC_CSR_LSION;
00001c  4823              LDR      r0,|L2.172|
00001e  3034              ADDS     r0,r0,#0x34
000020  6802              LDR      r2,[r0,#0]
000022  f0420201          ORR      r2,r2,#1
000026  6002              STR      r2,[r0,#0]
                  |L2.40|
;;;133        
;;;134        // Ждём, когда он заведётся
;;;135        while(!(RCC->CSR & RCC_CSR_LSIRDY)) {}
000028  6802              LDR      r2,[r0,#0]
00002a  0792              LSLS     r2,r2,#30
00002c  d5fc              BPL      |L2.40|
;;;136        
;;;137        // Ок, генератор на 32 кГц завёлся.
;;;138        
;;;139        // Сбросим состояние энергонезависимого домена
;;;140        RCC->BDCR |=  RCC_BDCR_BDRST;
00002e  481f              LDR      r0,|L2.172|
000030  3030              ADDS     r0,r0,#0x30
000032  6802              LDR      r2,[r0,#0]
000034  f4423280          ORR      r2,r2,#0x10000
000038  6002              STR      r2,[r0,#0]
;;;141        RCC->BDCR &= ~RCC_BDCR_BDRST;
00003a  6802              LDR      r2,[r0,#0]
00003c  f4223280          BIC      r2,r2,#0x10000
000040  6002              STR      r2,[r0,#0]
;;;142        
;;;143        // Выберем его как источник тактирования RTC:
;;;144        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
000042  6802              LDR      r2,[r0,#0]
000044  f4227240          BIC      r2,r2,#0x300
000048  6002              STR      r2,[r0,#0]
;;;145        RCC->BDCR |= (RCC_BDCR_RTCSEL_1); // запишем 0b10
00004a  6802              LDR      r2,[r0,#0]
00004c  f4427200          ORR      r2,r2,#0x200
000050  6002              STR      r2,[r0,#0]
;;;146            
;;;147        // Включим тактирование RTC
;;;148        RCC->BDCR |= RCC_BDCR_RTCEN;
000052  6802              LDR      r2,[r0,#0]
000054  f4424200          ORR      r2,r2,#0x8000
000058  6002              STR      r2,[r0,#0]
00005a  4a13              LDR      r2,|L2.168|
00005c  20ca              MOVS     r0,#0xca
00005e  3218              ADDS     r2,r2,#0x18
000060  6010              STR      r0,[r2,#0]
000062  2053              MOVS     r0,#0x53
000064  6010              STR      r0,[r2,#0]
;;;149        
;;;150        // Снимем защиту от записи с регистров RTC
;;;151        rtc_Unlock();
;;;152        {
;;;153            // Здесь можем менять регистры RTC
;;;154    
;;;155            // Войдём в режим инициализации:
;;;156            RTC->ISR |= RTC_ISR_INIT;
000066  6808              LDR      r0,[r1,#0]
000068  f0400080          ORR      r0,r0,#0x80
00006c  6008              STR      r0,[r1,#0]
                  |L2.110|
;;;157            
;;;158            // Ждём, когда это произойдёт
;;;159            while(!(RTC->ISR & RTC_ISR_INITF)) {}
00006e  6808              LDR      r0,[r1,#0]
000070  0640              LSLS     r0,r0,#25
000072  d5fc              BPL      |L2.110|
;;;160            
;;;161            // Часы остановлены. Режим инициализации
;;;162            // Настроим предделитель для получения частоты 1 Гц.
;;;163            
;;;164            // LSI: 
;;;165            // LSE: нужно разделить на 0x7fff (кварцы так точно рассчитаны на это)
;;;166            {  //  32768Hz, а нам нужны
;;;167                uint32_t Sync = 249;   // 15 бит
;;;168                uint32_t Async =127;  // 7 бит
;;;169                
;;;170                // Сначала записываем величину для синхронного предделителя
;;;171                RTC->PRER = Sync;
000074  4b0c              LDR      r3,|L2.168|
000076  20f9              MOVS     r0,#0xf9              ;167
000078  1d1b              ADDS     r3,r3,#4
00007a  6018              STR      r0,[r3,#0]
;;;172                
;;;173                // Теперь добавим для асинхронного предделителя
;;;174                RTC->PRER =Sync | (Async << 16);
00007c  480d              LDR      r0,|L2.180|
00007e  6018              STR      r0,[r3,#0]
000080  4b09              LDR      r3,|L2.168|
000082  480d              LDR      r0,|L2.184|
000084  3b08              SUBS     r3,r3,#8
000086  6018              STR      r0,[r3,#0]
000088  1f1b              SUBS     r3,r3,#4
00008a  480c              LDR      r0,|L2.188|
00008c  6018              STR      r0,[r3,#0]
;;;175    					
;;;176    			//		RTC->PRER = 0x00000000; // RESET PRER register
;;;177    			//		RTC->PRER |= (0xFF<<0); // 255 + 1 Synchronous prescaler factor set
;;;178    			//		RTC->PRER |= (0x7F<<16); // 127 + 1 Asynchronous prescaler factor set
;;;179            }
;;;180            
;;;181            // Устанавливаем дату: 30.05.13, пятница
;;;182            rtc_SetDate(2, 6, 13, 7);
;;;183            
;;;184            // Устанавливаем время: 15:00:00
;;;185            rtc_SetTime(15, 15, 00);
;;;186            
;;;187            // Переведём часы в 24-часовой формат
;;;188            RTC->CR |= RTC_CR_FMT;
00008e  4806              LDR      r0,|L2.168|
000090  1f00              SUBS     r0,r0,#4
000092  6803              LDR      r3,[r0,#0]
000094  f0430340          ORR      r3,r3,#0x40
000098  6003              STR      r3,[r0,#0]
;;;189            
;;;190            // Инициализация закончилась
;;;191            RTC->ISR &= ~RTC_ISR_INIT;
00009a  6808              LDR      r0,[r1,#0]
00009c  f0200080          BIC      r0,r0,#0x80
0000a0  6008              STR      r0,[r1,#0]
0000a2  20ff              MOVS     r0,#0xff
0000a4  6010              STR      r0,[r2,#0]
                  |L2.166|
;;;192        }   
;;;193        rtc_Lock();
;;;194        
;;;195        // Всё, часы запустились и считают время.
;;;196    		/*
;;;197    		
;;;198    		/разрешить тактирование модулей управления питанием и управлением резервной областью
;;;199      RCC->APB1ENR |= RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN;
;;;200      //разрешить доступ к области резервных данных
;;;201      PWR->CR |= PWR_CR_DBP;
;;;202      //если часы выключены - инициализировать их
;;;203      if ((RCC->BDCR & RCC_BDCR_RTCEN) != RCC_BDCR_RTCEN)
;;;204      {
;;;205        //выполнить сброс области резервных данных
;;;206        RCC->BDCR |=  RCC_BDCR_BDRST;
;;;207        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;208     
;;;209        //выбрать источником тактовых импульсов внешний кварц 32768 и подать тактирование
;;;210        RCC->BDCR |=  RCC_BDCR_RTCEN | RCC_BDCR_RTCSEL_LSE;
;;;211     
;;;212        RTC->CRL  |=  RTC_CRL_CNF;
;;;213        RTC->PRLL  = 0x7FFF;         //регистр деления на 32768
;;;214        RTC->CRL  &=  ~RTC_CRL_CNF;
;;;215     
;;;216        //установить бит разрешения работы и дождаться установки бита готовности
;;;217        RCC->BDCR |= RCC_BDCR_LSEON;
;;;218        while ((RCC->BDCR & RCC_BDCR_LSEON) != RCC_BDCR_LSEON){}
;;;219     
;;;220        RTC->CRL &= (uint16_t)~RTC_CRL_RSF;
;;;221        while((RTC->CRL & RTC_CRL_RSF) != RTC_CRL_RSF){}
;;;222     
;;;223        return 1;
;;;224      }
;;;225      return 0;
;;;226    	*/
;;;227    }
0000a6  4770              BX       lr
;;;228    
                          ENDP

                  |L2.168|
                          DCD      0x4000280c
                  |L2.172|
                          DCD      0x40023840
                  |L2.176|
                          DCD      0x40007000
                  |L2.180|
                          DCD      0x007f00f9
                  |L2.184|
                          DCD      0x0013e602
                  |L2.188|
                          DCD      0x00151500

                          AREA ||i.rtc_Reset||, CODE, READONLY, ALIGN=2

                  rtc_Reset PROC
;;;105    // Сброс состояния часов
;;;106    void rtc_Reset(void)
000000  480a              LDR      r0,|L3.44|
;;;107    {
;;;108        // Включим тактирование PWR
;;;109        RCC->APB1ENR |= RCC_APB1ENR_PWREN;
000002  6801              LDR      r1,[r0,#0]
000004  f0415180          ORR      r1,r1,#0x10000000
000008  6001              STR      r1,[r0,#0]
;;;110        
;;;111        // Разрешим доступ к управляющим регистрам энергонезависимого домена
;;;112        PWR->CR |= PWR_CR_DBP;
00000a  4809              LDR      r0,|L3.48|
00000c  6801              LDR      r1,[r0,#0]
00000e  f4417180          ORR      r1,r1,#0x100
000012  6001              STR      r1,[r0,#0]
;;;113        
;;;114        // Выберем его как источник тактирования RTC:
;;;115        RCC->BDCR |=  RCC_BDCR_BDRST;
000014  4805              LDR      r0,|L3.44|
000016  3030              ADDS     r0,r0,#0x30
000018  6801              LDR      r1,[r0,#0]
00001a  f4413180          ORR      r1,r1,#0x10000
00001e  6001              STR      r1,[r0,#0]
;;;116        RCC->BDCR &= ~RCC_BDCR_BDRST;
000020  6801              LDR      r1,[r0,#0]
000022  f4213180          BIC      r1,r1,#0x10000
000026  6001              STR      r1,[r0,#0]
;;;117    }
000028  4770              BX       lr
;;;118    
                          ENDP

00002a  0000              DCW      0x0000
                  |L3.44|
                          DCD      0x40023840
                  |L3.48|
                          DCD      0x40007000

;*** Start embedded assembler ***

#line 1 "src\\rtc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_rtc_c_00beeb99____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___5_rtc_c_00beeb99____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_rtc_c_00beeb99____REVSH|
#line 128
|__asm___5_rtc_c_00beeb99____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
