; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\media_usb_key\rtc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\media_usb_key\rtc.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\media_usb_key\rtc.crf src\rtc.c]
                          THUMB

                          AREA ||i.rtc_Get||, CODE, READONLY, ALIGN=2

                  rtc_Get PROC
;;;767    // Получить текущее время
;;;768    void rtc_Get(TDateTime * DateTime)
000000  4921              LDR      r1,|L1.136|
;;;769    {
000002  b510              PUSH     {r4,lr}
;;;770        uint32_t Date = RTC->DR;
000004  6809              LDR      r1,[r1,#0]
;;;771        uint32_t Time = RTC->TR;
000006  4a20              LDR      r2,|L1.136|
000008  1f12              SUBS     r2,r2,#4
00000a  6812              LDR      r2,[r2,#0]
;;;772        
;;;773        // Очистим
;;;774        memset(DateTime, 0, sizeof(*DateTime));
00000c  2300              MOVS     r3,#0
00000e  6003              STR      r3,[r0,#0]
000010  8083              STRH     r3,[r0,#4]
;;;775        
;;;776        // Год
;;;777        DateTime->Year      = ((Date >> 20) & 0x0f) * 10 + ((Date >> 16) & 0x0f);
000012  f3c15303          UBFX     r3,r1,#20,#4
000016  eb030383          ADD      r3,r3,r3,LSL #2
00001a  f3c14403          UBFX     r4,r1,#16,#4
00001e  eb040343          ADD      r3,r4,r3,LSL #1
000022  7003              STRB     r3,[r0,#0]
;;;778        // Месяц
;;;779        DateTime->Month     = ((Date >> 12) & 0x01) * 10 + ((Date >>  8) & 0x0f);
000024  f3c13300          UBFX     r3,r1,#12,#1
000028  eb030383          ADD      r3,r3,r3,LSL #2
00002c  f3c12403          UBFX     r4,r1,#8,#4
000030  eb040343          ADD      r3,r4,r3,LSL #1
000034  7043              STRB     r3,[r0,#1]
;;;780        // День
;;;781        DateTime->Day       = ((Date >>  4) & 0x03) * 10 + ((Date >>  0) & 0x0f);
000036  f3c11301          UBFX     r3,r1,#4,#2
00003a  f001040f          AND      r4,r1,#0xf
00003e  eb030383          ADD      r3,r3,r3,LSL #2
000042  eb040343          ADD      r3,r4,r3,LSL #1
000046  7083              STRB     r3,[r0,#2]
;;;782        // День недели
;;;783        DateTime->DayOfWeek = ((Date >> 13) & 0x07);
000048  f3c13142          UBFX     r1,r1,#13,#3
00004c  70c1              STRB     r1,[r0,#3]
;;;784        
;;;785        // Час
;;;786        DateTime->Hours     = ((Time >> 20) & 0x03) * 10 + ((Time >> 16) & 0x0f);
00004e  f3c25101          UBFX     r1,r2,#20,#2
000052  eb010181          ADD      r1,r1,r1,LSL #2
000056  f3c24303          UBFX     r3,r2,#16,#4
00005a  eb030141          ADD      r1,r3,r1,LSL #1
00005e  7101              STRB     r1,[r0,#4]
;;;787        // Минуты
;;;788        DateTime->Minutes   = ((Time >> 12) & 0x07) * 10 + ((Time >> 8) & 0x0f);
000060  f3c23102          UBFX     r1,r2,#12,#3
000064  eb010181          ADD      r1,r1,r1,LSL #2
000068  f3c22303          UBFX     r3,r2,#8,#4
00006c  eb030141          ADD      r1,r3,r1,LSL #1
000070  7141              STRB     r1,[r0,#5]
;;;789        // Секунды
;;;790        DateTime->Seconds   = ((Time >> 4) & 0x07) * 10 + ((Time >> 0) & 0x0f);
000072  f3c21102          UBFX     r1,r2,#4,#3
000076  f002030f          AND      r3,r2,#0xf
00007a  eb010181          ADD      r1,r1,r1,LSL #2
00007e  eb030141          ADD      r1,r3,r1,LSL #1
000082  7181              STRB     r1,[r0,#6]
;;;791    }
000084  bd10              POP      {r4,pc}
                          ENDP

000086  0000              DCW      0x0000
                  |L1.136|
                          DCD      0x40002804

                          AREA ||i.rtc_Init||, CODE, READONLY, ALIGN=2

                  rtc_Init PROC
;;;126    // Инициализация модуля
;;;127    void rtc_Init(void)
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;128    {
;;;129    		u32 tmp=0;
;;;130    	
;;;131    	  GPIO_InitTypeDef      GPIO_InitStructure;
;;;132    	
;;;133        // Если часы запущены, делать тут нечего.
;;;134        if(RTC->ISR & RTC_ISR_INITS) return;
000004  4a69              LDR      r2,|L2.428|
000006  6810              LDR      r0,[r2,#0]
000008  06c0              LSLS     r0,r0,#27
00000a  d47c              BMI      |L2.262|
;;;135        
;;;136        // Включим тактирование PWR
;;;137        RCC->APB1ENR |= RCC_APB1ENR_PWREN;
00000c  4868              LDR      r0,|L2.432|
00000e  6801              LDR      r1,[r0,#0]
000010  f0415180          ORR      r1,r1,#0x10000000
000014  6001              STR      r1,[r0,#0]
;;;138        
;;;139        // Разрешим доступ к управляющим регистрам энергонезависимого домена
;;;140        PWR->CR |= PWR_CR_DBP;
000016  4867              LDR      r0,|L2.436|
000018  6801              LDR      r1,[r0,#0]
00001a  f4417180          ORR      r1,r1,#0x100
00001e  6001              STR      r1,[r0,#0]
;;;141       
;;;142    /*
;;;143    	//  Кварц MC306-G-06Q-32.768 (JFVNY)
;;;144    	 //  start LSE
;;;145    		RCC->BDCR |= RCC_BDCR_LSEON;
;;;146    		while ((RCC->BDCR & RCC_BDCR_LSEON) != RCC_BDCR_LSEON) {}
;;;147    		
;;;148    		RCC->BDCR |=  RCC_BDCR_BDRST;
;;;149        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;150    		
;;;151    	// Выберем его как источник тактирования RTC:
;;;152        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
;;;153        RCC->BDCR |= (RCC_BDCR_RTCSEL_0); // запишем 0b10
;;;154    		
;;;155    		   // Включим тактирование RTC
;;;156        RCC->BDCR |= RCC_BDCR_RTCEN;
;;;157    */
;;;158     
;;;159    /* RTC configuration set 
;;;160    PWR->CR |= (1<<8);	 // Access to RTC and RTC backup registers and backup SRAM enabled
;;;161    RCC->CSR &= (1<<0);	 // LSI Off
;;;162    RCC->BDCR = 0x00000000;	 // Reset BDCR register
;;;163    RCC->BDCR |= (1<<15);	 // RTC clock enable
;;;164    RCC->BDCR |= (1<<0);	 // LSE On
;;;165    RCC->BDCR &= ~(1<<2);	 // LSE not bypassed quartz On
;;;166    RCC->BDCR &= ~(1<<16);	 // Backup domain software reset not activated
;;;167    RCC->BDCR |= (0x1<<8);	 // LSE used as the RTC clock
;;;168    RTC->WPR = 0x000000CA;	 // Key protect 1
;;;169    RTC->WPR = 0x00000053;	 // Key protect 2
;;;170    RTC->ISR |= (1<<7);	 // Initialization mode On
;;;171    for(;((RTC->ISR & 0x40) == 0x00);)	// delay while initialization flag will be set
;;;172    {
;;;173    }
;;;174    */	
;;;175    	/* 
;;;176    	JFVNY MC306G06 6 50000 32768 2 9.3
;;;177    	PC14/OSC32_IN   (PC14)
;;;178    	PC15/OSC32_OUT (PC15)
;;;179    	PB2/BOOT1    (PB2)
;;;180    */
;;;181    
;;;182    
;;;183    /*
;;;184    	//     push pull out  in kvarc
;;;185    	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_14|GPIO_Pin_15;      		  //  vvod  knopka 1
;;;186    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    										// 	rezim vivoda
;;;187    	GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;		//
;;;188    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 									//	speed
;;;189    	GPIO_Init(GPIOC, &GPIO_InitStructure); 
;;;190    
;;;191    	for(tmp=0;tmp<10000;tmp++)	// delay while initialization flag will be set
;;;192    	{ __ASM volatile ("nop"); 	}
;;;193    
;;;194    //	GPIOA->BSRR = GPIO_BSRR_BS14; // Boot the cristal 
;;;195    	GPIOA->BSRRL = GPIO_Pin_14;
;;;196    //	GPIOA->BSRRL = GPIO_Pin_15;
;;;197    	GPIOB->BSRRL = GPIO_Pin_2;
;;;198    	
;;;199    	for(tmp=0;tmp<1000000;tmp++)	
;;;200    	{ __ASM volatile ("nop"); 	}
;;;201    	
;;;202    //     analog in kvarc
;;;203    	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_14|GPIO_Pin_15;      		  //  vvod  knopka 1
;;;204    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AN;    										// 	rezim vivoda
;;;205    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;  										//GPIO_OType_PP		//
;;;206    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 									//	speed
;;;207    	GPIO_Init(GPIOC, &GPIO_InitStructure); 
;;;208    */
;;;209    
;;;210     /*
;;;211    		
;;;212    		RCC->BDCR |=  RCC_BDCR_BDRST;
;;;213        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;214    		
;;;215    	// Выберем его как источник тактирования RTC:
;;;216        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
;;;217        RCC->BDCR |= (RCC_BDCR_RTCSEL_0); // запишем 0b10
;;;218    		
;;;219    		   // Включим тактирование RTC
;;;220        RCC->BDCR |= RCC_BDCR_RTCEN;
;;;221    	*/	
;;;222    /*	
;;;223    
;;;224    Попробуйте дать ему пинка. Сконфигурируйте ноги на выход и подайте напряжение на кварц на четверть периода. Потом уже снова на вход и запускайте генератор. Заводились даже 12 пФ кварцы. Только работали нестабильно.
;;;225    	GPIOC->CRH |= GPIO_CRH_MODE14_1 |GPIO_CRH_MODE15_1; // Out 2 MHZ
;;;226    	GPIOC->CRH &= ~(GPIO_CRH_CNF14|GPIO_CRH_CNF15); // PUSH pull
;;;227    	Delay();
;;;228    	GPIOA->BSRR = GPIO_BSRR_BS14; // Boot the cristal 
;;;229    	Delay();
;;;230    	GPIOC->CRH &= ~(GPIO_CRH_MODE14_1|GPIO_CRH_MODE15_1); // Analog IN 
;;;231    	RCC->BDCR |= RCC_BDCR_LSEON;
;;;232    
;;;233    KX-38 32.768 kHz 6pF,
;;;234    		32.768kHz crystal, with 6pF CL and 50kOhm ESR. 
;;;235    		a 15MOhm parallel resistor.
;;;236    if (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
;;;237    {
;;;238    
;;;239        RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE); // Enable PWR clock 
;;;240     
;;;241     //   PWR_BackupAccessCmd(ENABLE); // Allow access to BKP Domain 
;;;242    		 RCC->CSR = RCC_CSR_LSION;
;;;243        RCC_LSEConfig(RCC_LSE_ON); // Enable the LSE oscillator 
;;;244     
;;;245        while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET) // Wait till LSE is ready
;;;246    		{
;;;247    		 __ASM volatile ("nop");   
;;;248    		}
;;;249    }
;;;250    */
;;;251    /*
;;;252        // Запускаем LSI:
;;;253        RCC->CSR |= RCC_CSR_LSION;
;;;254        
;;;255        // Ждём, когда он заведётся
;;;256        while(!(RCC->CSR & RCC_CSR_LSIRDY)) {}
;;;257        
;;;258        // Ок, генератор на 32 кГц завёлся.
;;;259        
;;;260        // Сбросим состояние энергонезависимого домена
;;;261        RCC->BDCR |=  RCC_BDCR_BDRST;
;;;262        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;263        
;;;264        // Выберем его как источник тактирования RTC:
;;;265        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
;;;266        RCC->BDCR |= (RCC_BDCR_RTCSEL_1); // запишем 0b10
;;;267          
;;;268        // Включим тактирование RTC
;;;269        RCC->BDCR |= RCC_BDCR_RTCEN;
;;;270     */
;;;271    
;;;272    /*
;;;273    ● Access to the backup SRAM
;;;274    1. Enable the power interface clock by setting the PWREN bits in the RCC APB1
;;;275    peripheral clock enable register (RCC_APB1ENR)
;;;276    2. Set the DBP bit in the PWR power control register (PWR_CR) to enable access to the
;;;277    backup domain
;;;278    3. Enable the backup SRAM clock by setting BKPSRAMEN bit in the RCC AHB1
;;;279    peripheral clock register (RCC_AHB1ENR)
;;;280    
;;;281    uint8_t *BKPRam = (uint8_t *)0x40024000;
;;;282    
;;;283    
;;;284    */	
;;;285    
;;;286       // Запускаем LSI:
;;;287        RCC->CSR |= RCC_CSR_LSION;
000020  4863              LDR      r0,|L2.432|
000022  3034              ADDS     r0,r0,#0x34
000024  6801              LDR      r1,[r0,#0]
000026  f0410101          ORR      r1,r1,#1
00002a  6001              STR      r1,[r0,#0]
                  |L2.44|
;;;288        
;;;289        // Ждём, когда он заведётся
;;;290        while(!(RCC->CSR & RCC_CSR_LSIRDY)) {}
00002c  6801              LDR      r1,[r0,#0]
00002e  0789              LSLS     r1,r1,#30
000030  d5fc              BPL      |L2.44|
;;;291        
;;;292        // Ок, генератор на 32 кГц завёлся.
;;;293        
;;;294        // Сбросим состояние энергонезависимого домена
;;;295        RCC->BDCR |=  RCC_BDCR_BDRST;
000032  485f              LDR      r0,|L2.432|
000034  3030              ADDS     r0,r0,#0x30
000036  6801              LDR      r1,[r0,#0]
000038  f4413180          ORR      r1,r1,#0x10000
00003c  6001              STR      r1,[r0,#0]
;;;296        RCC->BDCR &= ~RCC_BDCR_BDRST;
00003e  6801              LDR      r1,[r0,#0]
000040  f4213180          BIC      r1,r1,#0x10000
000044  6001              STR      r1,[r0,#0]
;;;297        
;;;298        // Выберем его как источник тактирования RTC:
;;;299        RCC->BDCR &= ~RCC_BDCR_RTCSEL; // сбросим
000046  6801              LDR      r1,[r0,#0]
000048  f4217140          BIC      r1,r1,#0x300
00004c  6001              STR      r1,[r0,#0]
;;;300        RCC->BDCR |= (RCC_BDCR_RTCSEL_1); // запишем 0b10
00004e  6801              LDR      r1,[r0,#0]
000050  f4417100          ORR      r1,r1,#0x200
000054  6001              STR      r1,[r0,#0]
;;;301          
;;;302        // Включим тактирование RTC
;;;303        RCC->BDCR |= RCC_BDCR_RTCEN;
000056  6801              LDR      r1,[r0,#0]
000058  f4414100          ORR      r1,r1,#0x8000
00005c  6001              STR      r1,[r0,#0]
;;;304    			
;;;305    /*
;;;306    		 //  start LSE
;;;307    		 RCC->BDCR |= RCC_BDCR_LSEON;
;;;308    		 while ((RCC->BDCR & RCC_BDCR_LSEON) != RCC_BDCR_LSEON) {}			
;;;309    		 while (!(RCC->BDCR & RCC_BDCR_LSERDY)) {}			
;;;310    		 RCC->BDCR |= RCC_BDCR_RTCEN | RCC_BDCR_RTCSEL_0;
;;;311    			
;;;312          // Снимем защиту от записи с регистров RTC
;;;313          rtc_Unlock();
;;;314            // Войдём в режим инициализации:
;;;315          RTC->ISR |= RTC_ISR_INIT;
;;;316    			while(!(RTC->ISR & RTC_ISR_INITF)) {}
;;;317    
;;;318    					RTC->PRER = 0x00000000; // RESET PRER register
;;;319    					RTC->PRER |= (0xFF<<0); // 255 + 1 Synchronous prescaler factor set
;;;320    					RTC->PRER |= (0x7F<<16); // 127 + 1 Asynchronous prescaler factor set
;;;321         */          
;;;322            // Устанавливаем дату: 30.05.13, пятница
;;;323    				//       rtc_SetDate(2, 6, 13, 7);       
;;;324            // Устанавливаем время: 15:00:00
;;;325    				//      rtc_SetTime(0, 0, 00);       
;;;326            // Переведём часы в 24-часовой формат
;;;327            RTC->CR |= RTC_CR_FMT;        
00005e  4853              LDR      r0,|L2.428|
000060  1f00              SUBS     r0,r0,#4
000062  6801              LDR      r1,[r0,#0]
000064  f0410140          ORR      r1,r1,#0x40
000068  6001              STR      r1,[r0,#0]
;;;328            // Инициализация закончилась
;;;329            RTC->ISR &= ~RTC_ISR_INIT;   
00006a  6810              LDR      r0,[r2,#0]
00006c  f0200080          BIC      r0,r0,#0x80
000070  6010              STR      r0,[r2,#0]
000072  494e              LDR      r1,|L2.428|
000074  20ff              MOVS     r0,#0xff
000076  3118              ADDS     r1,r1,#0x18
000078  6008              STR      r0,[r1,#0]
;;;330        rtc_Lock();
;;;331    		
;;;332    		// Allow access to BKP Domain 
;;;333    //PWR_BackupAccessCmd(ENABLE);
;;;334    
;;;335    // Write to the first RTC Backup Data Register 
;;;336    RTC_WriteBackupRegister(RTC_BKP_DR2,0xA5A5);
00007a  f24a51a5          MOV      r1,#0xa5a5
00007e  2002              MOVS     r0,#2
000080  f7fffffe          BL       RTC_WriteBackupRegister
;;;337    		
;;;338    		// Backup SRAM **************************************************************
;;;339    //Enable BKPRAM Clock 
;;;340    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
000084  2101              MOVS     r1,#1
000086  048d              LSLS     r5,r1,#18
000088  4628              MOV      r0,r5
00008a  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;341    
;;;342    //Enable the Backup SRAM low power Regulator to retain it's content in VBAT mode 
;;;343    //PWR_BackupRegulatorCmd(ENABLE);
;;;344    
;;;345    // Wait until the Backup SRAM low power Regulator is ready 
;;;346    //while(PWR_GetFlagStatus(PWR_FLAG_BRR) == RESET)
;;;347    {
;;;348    }
;;;349    
;;;350     {
;;;351    	 
;;;352    	 extern st_conf conf;
;;;353    	 u32 i=0,i1=0, errorindex=0;
00008e  2400              MOVS     r4,#0
;;;354    	 
;;;355       bkp=RTC_ReadBackupRegister(RTC_BKP_DR2);
000090  2002              MOVS     r0,#2
000092  f7fffffe          BL       RTC_ReadBackupRegister
000096  4e48              LDR      r6,|L2.440|
;;;356    
;;;357    
;;;358    //  Backup SRAM ************************************************************
;;;359      // Enable BKPRAM Clock 
;;;360      RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
000098  2101              MOVS     r1,#1
00009a  8030              STRH     r0,[r6,#0]            ;355
00009c  4628              MOV      r0,r5
00009e  f7fffffe          BL       RCC_AHB1PeriphClockCmd
;;;361    
;;;362    /*
;;;363      // Write to Backup SRAM with 32-Bit Data 
;;;364      for (i = 0; i < 0x1000; i += 4)
;;;365      {
;;;366        *(__IO uint32_t *) (BKPSRAM_BASE + i) = i;
;;;367      }
;;;368    */
;;;369    //	sizeof
;;;370      // read config rrom backup SRAM
;;;371    	 
;;;372    	 
;;;373    
;;;374    	/*
;;;375      for (i = 0; i < size; i += 2)
;;;376      {
;;;377    		(*(__IO uint16_t *) ((__IO uint16_t *) (&conf) + i))=(u16)i; //(*(__IO uint32_t *) (BKPSRAM_BASE + i));
;;;378    	}	
;;;379    */
;;;380    /*
;;;381    	conf.address=1;
;;;382    	conf.ver_po_st=2;
;;;383    	conf.ver_po_ml=3;
;;;384    	conf.tek_gr_kal=4;
;;;385    	conf.tm_antidreb=5;
;;;386    	conf.revers_group_select=6;
;;;387    	conf.revers_peredacha_select=7;
;;;388    	conf.rez8=8;
;;;389    	
;;;390    	conf.per_usr=9;
;;;391    	conf.time_max=10;
;;;392    	conf.por_rele=11;
;;;393    	conf.tm_rele_on=12;
;;;394    	conf.tm_rele_off=13;
;;;395    	conf.rez16=14;
;;;396    	
;;;397    	conf.indicators[0].numb=15;
;;;398    	conf.indicators[0].kol_cifr=16;
;;;399    	conf.indicators[1].numb=17;
;;;400    	conf.indicators[1].kol_cifr=18;
;;;401    	conf.indicators[2].numb=19;
;;;402    	conf.indicators[2].kol_cifr=20;
;;;403    	conf.indicators[3].numb=21;
;;;404    	conf.indicators[3].kol_cifr=2;
;;;405    	conf.gr_kal1.tabl1.kod[0]=23;
;;;406    	conf.gr_kal1.tabl1.fz[0]=24;
;;;407    	conf.gr_kal1.tabl2.kod[0]=25;
;;;408    	conf.gr_kal1.tabl2.fz[0]=26;
;;;409    	conf.gr_kal2.tabl1.kod[0]=27;
;;;410    	conf.gr_kal2.tabl1.fz[0]=28;
;;;411    	conf.gr_kal2.tabl2.kod[0]=29;
;;;412    	conf.gr_kal2.tabl2.fz[0]=30;
;;;413    	conf.gr_kal2.tabl2.kod[9]=31;
;;;414    	conf.gr_kal2.tabl2.fz[9]=32;
;;;415    */
;;;416    /*
;;;417    uint32_t flash_read(uint32_t address) {
;;;418    return (*(__IO uint32_t*) address);
;;;419    }
;;;420    */
;;;421    	size=sizeof(st_conf);
0000a2  21be              MOVS     r1,#0xbe
;;;422    	
;;;423    	for (i = 0; i < size; i += 1)
;;;424      {
;;;425    		(*(__IO uint8_t *) ((__IO uint8_t *) (&conf) + i))=(*(__IO uint8_t *) (ADDR_FLASH + i));
0000a4  4845              LDR      r0,|L2.444|
0000a6  4d46              LDR      r5,|L2.448|
0000a8  8071              STRH     r1,[r6,#2]            ;421
                  |L2.170|
0000aa  5c22              LDRB     r2,[r4,r0]
0000ac  552a              STRB     r2,[r5,r4]
0000ae  1c64              ADDS     r4,r4,#1              ;423
0000b0  428c              CMP      r4,r1                 ;423
0000b2  d3fa              BCC      |L2.170|
;;;426    	}	
;;;427    	
;;;428    	size=sizeof(st_conf);
;;;429    	
;;;430    	for (i = 0; i < size; i += 1)
;;;431      {
;;;432    		(*(__IO uint8_t *) ((__IO uint8_t *) (&conf) + i))=(*(__IO uint8_t *) (BKPSRAM_BASE + i));
0000b4  4a43              LDR      r2,|L2.452|
0000b6  8071              STRH     r1,[r6,#2]            ;428
0000b8  2000              MOVS     r0,#0                 ;430
                  |L2.186|
0000ba  5c83              LDRB     r3,[r0,r2]
0000bc  542b              STRB     r3,[r5,r0]
0000be  1c40              ADDS     r0,r0,#1              ;430
0000c0  4288              CMP      r0,r1                 ;430
0000c2  d3fa              BCC      |L2.186|
;;;433    	}	
;;;434    	
;;;435    		kol_usr=conf.per_usr;
0000c4  4940              LDR      r1,|L2.456|
0000c6  8928              LDRH     r0,[r5,#8]  ; conf
0000c8  f04f0401          MOV      r4,#1                 ;340
0000cc  8008              STRH     r0,[r1,#0]
;;;436    		conf.tm_antidreb=conf.tm_antidreb*10;
0000ce  7928              LDRB     r0,[r5,#4]  ; conf
0000d0  eb000080          ADD      r0,r0,r0,LSL #2
0000d4  0640              LSLS     r0,r0,#25
0000d6  0e00              LSRS     r0,r0,#24
0000d8  7128              STRB     r0,[r5,#4]
;;;437    	
;;;438    		if (conf.tm_antidreb==0)
0000da  d100              BNE      |L2.222|
;;;439    				conf.tm_antidreb=1;
0000dc  712c              STRB     r4,[r5,#4]
                  |L2.222|
;;;440    
;;;441    //	RCC_APB2PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE); 
;;;442    	GPIO_InitStructure.GPIO_Pin   = PIN_RELE;      		//  vivod RELE
;;;443    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    // rezim vivoda
0000de  f88d4004          STRB     r4,[sp,#4]
;;;444    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
;;;445    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //speed
;;;446    	GPIO_Init(PORT_RELE, &GPIO_InitStructure); 
0000e2  f8dfb0e8          LDR      r11,|L2.460|
0000e6  f04f0a10          MOV      r10,#0x10             ;442
0000ea  f88d4006          STRB     r4,[sp,#6]            ;444
0000ee  2602              MOVS     r6,#2                 ;445
0000f0  f8cda000          STR      r10,[sp,#0]           ;443
0000f4  f88d6005          STRB     r6,[sp,#5]            ;445
0000f8  4669              MOV      r1,sp
0000fa  4658              MOV      r0,r11
0000fc  f7fffffe          BL       GPIO_Init
;;;447    
;;;448    	GPIO_InitStructure.GPIO_Pin   = PIN_L1;      		//  vivod svetodiod knopka 1
000100  2740              MOVS     r7,#0x40
;;;449    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    // rezim vivoda
000102  9700              STR      r7,[sp,#0]
000104  e000              B        |L2.264|
                  |L2.262|
000106  e04a              B        |L2.414|
                  |L2.264|
000108  f88d4004          STRB     r4,[sp,#4]
;;;450    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
00010c  f88d4006          STRB     r4,[sp,#6]
;;;451    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //speed
000110  f88d6005          STRB     r6,[sp,#5]
;;;452    	GPIO_Init(PORT_L1, &GPIO_InitStructure); 
000114  4669              MOV      r1,sp
000116  482e              LDR      r0,|L2.464|
000118  f7fffffe          BL       GPIO_Init
;;;453    	
;;;454    	GPIO_InitStructure.GPIO_Pin   = PIN_L2;      		  //  vivod svetodiod knopka 2
;;;455    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;    // rezim vivoda
00011c  f88d4004          STRB     r4,[sp,#4]
000120  f44f7880          MOV      r8,#0x100             ;454
;;;456    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
000124  f88d4006          STRB     r4,[sp,#6]
000128  f8cd8000          STR      r8,[sp,#0]            ;455
;;;457    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //speed
00012c  f88d6005          STRB     r6,[sp,#5]
;;;458    	GPIO_Init(PORT_L2, &GPIO_InitStructure); 
000130  4669              MOV      r1,sp
000132  4827              LDR      r0,|L2.464|
000134  f7fffffe          BL       GPIO_Init
;;;459    
;;;460    	GPIO_InitStructure.GPIO_Pin   = PIN_K1;      		  //  vvod  knopka 1
;;;461    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;    // 	rezim vivoda
000138  f04f0900          MOV      r9,#0
00013c  2080              MOVS     r0,#0x80              ;460
00013e  f88d9004          STRB     r9,[sp,#4]
000142  9000              STR      r0,[sp,#0]
;;;462    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
000144  f88d4006          STRB     r4,[sp,#6]
;;;463    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //	speed
000148  f88d6005          STRB     r6,[sp,#5]
;;;464    	GPIO_Init(PORT_K1, &GPIO_InitStructure); 
00014c  4669              MOV      r1,sp
00014e  4820              LDR      r0,|L2.464|
000150  f7fffffe          BL       GPIO_Init
;;;465    	
;;;466    	GPIO_InitStructure.GPIO_Pin   = PIN_K2;      		  //  vvod  knopka 2
000154  0230              LSLS     r0,r6,#8
;;;467    	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_IN;    // 	rezim vivoda
000156  f88d9004          STRB     r9,[sp,#4]
00015a  9000              STR      r0,[sp,#0]
;;;468    	GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;		//
00015c  f88d4006          STRB     r4,[sp,#6]
;;;469    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; //	speed
000160  f88d6005          STRB     r6,[sp,#5]
;;;470    	GPIO_Init(PORT_K2, &GPIO_InitStructure); 
000164  4669              MOV      r1,sp
000166  481a              LDR      r0,|L2.464|
000168  f7fffffe          BL       GPIO_Init
;;;471    	
;;;472    	if (conf.tek_gr_kal==0)
;;;473    	{
;;;474    		//  dr kal ==0 - pervaya
;;;475    		PORT_L1->BSRRL = PIN_L1;  // on  PIN_L1
00016c  4818              LDR      r0,|L2.464|
00016e  78ea              LDRB     r2,[r5,#3]            ;472  ; conf
000170  3018              ADDS     r0,r0,#0x18
;;;476    	  PORT_L2->BSRRH = PIN_L2;	// off PIN_L2
000172  1c81              ADDS     r1,r0,#2
000174  b1aa              CBZ      r2,|L2.418|
;;;477    	}
;;;478    	else
;;;479    	{
;;;480    		//  dr kal ==1 - vtoraya
;;;481    		PORT_L1->BSRRH = PIN_L1;  // off  PIN_L1
000176  800f              STRH     r7,[r1,#0]
;;;482    	  PORT_L2->BSRRL = PIN_L2;	// on   PIN_L2
000178  f8a08000          STRH     r8,[r0,#0]
                  |L2.380|
;;;483    	}
;;;484          
;;;485    		sost_flesh=0;	
00017c  4915              LDR      r1,|L2.468|
;;;486    		PORT_ZAP_EN->BSRRH = PIN_ZAP_EN;  // off  PORT_ZAP_EN
00017e  4a16              LDR      r2,|L2.472|
000180  f8819000          STRB     r9,[r1,#0]            ;485
000184  f8a2a01a          STRH     r10,[r2,#0x1a]
;;;487    		PORT_ZAP_DIS->BSRRL = PIN_ZAP_DIS;  // on  PORT_ZAP_DIS
000188  2320              MOVS     r3,#0x20
00018a  8313              STRH     r3,[r2,#0x18]
;;;488    		
;;;489    		avariya=0;
00018c  4a13              LDR      r2,|L2.476|
00018e  f8829000          STRB     r9,[r2,#0]
;;;490    		PORT_AVARIYA->BSRRH = PIN_AVARIYA;   
000192  029a              LSLS     r2,r3,#10
000194  f8ab201a          STRH     r2,[r11,#0x1a]
;;;491    	
;;;492    		PORT_RELE->BSRRH = PIN_RELE;	// on PIN_RELE	
000198  f8aba01a          STRH     r10,[r11,#0x1a]
;;;493    	
;;;494    	/*
;;;495    		conf.por_rele
;;;496    	  conf.time_max
;;;497    	  conf.tm_antidreb
;;;498    		conf.tm_rele_off
;;;499    		conf.tm_rele_on
;;;500    		conf.
;;;501    	*/	
;;;502    	
;;;503    	/*
;;;504    	for (i = 0; i < size; i += 1)
;;;505      {
;;;506        *(__IO uint8_t *) (BKPSRAM_BASE + i) = 0;
;;;507      }
;;;508    	*/
;;;509    	
;;;510    	/*
;;;511    	for (i = 0; i < size; i += 1)
;;;512      {
;;;513        *(__IO uint8_t *) (BKPSRAM_BASE + i) = *(__IO uint8_t *) ((__IO uint8_t *) (&conf) + i);
;;;514      }
;;;515    	*/
;;;516    	
;;;517    	
;;;518    /*
;;;519    	conf.address=255;
;;;520    	conf.ver_po_st=255;
;;;521    	conf.ver_po_ml=255;
;;;522    	conf.per_usr=255;
;;;523    	conf.time_max=255;
;;;524    	conf.tek_gr_kal=255;
;;;525    	conf.gr_kal1.tabl1.fz[0]=255;
;;;526    	conf.gr_kal1.tabl1.kod[0]=255;
;;;527    	conf.gr_kal1.tabl2.fz[0]=255;
;;;528    	conf.gr_kal1.tabl2.kod[0]=255;
;;;529    	
;;;530    	conf.gr_kal2.tabl1.fz[0]=255;
;;;531    	conf.gr_kal2.tabl1.kod[0]=255;
;;;532    	conf.gr_kal2.tabl2.fz[0]=255;
;;;533    	conf.gr_kal2.tabl2.kod[0]=255;
;;;534    	conf.revers_group_select=255;
;;;535    	conf.revers_peredacha_select=255;
;;;536    	conf.tm_antidreb=255;
;;;537    	conf.por_rele=255;
;;;538    	conf.tm_rele_on=255;
;;;539    	conf.tm_rele_off=255;
;;;540    	conf.indicators[0].numb=255;
;;;541    	conf.indicators[0].kol_cifr=255;
;;;542    	conf.indicators[1].numb=255;
;;;543    	conf.indicators[1].kol_cifr=255;
;;;544    	conf.indicators[2].numb=255;
;;;545    	conf.indicators[2].kol_cifr=255;
;;;546    	conf.indicators[3].numb=255;
;;;547    	conf.indicators[3].kol_cifr=255;
;;;548    	*/
;;;549    	/*
;;;550    	// test read config to comp
;;;551    	conf.address=1;
;;;552    	conf.ver_po_st=2;
;;;553    	conf.ver_po_ml=3;
;;;554    	conf.tek_gr_kal=4;
;;;555    	conf.tm_antidreb=5;
;;;556    	conf.revers_group_select=6;
;;;557    	conf.revers_peredacha_select=7;
;;;558    	conf.rez8=8;
;;;559    	
;;;560    	conf.per_usr=9;
;;;561    	conf.time_max=10;
;;;562    	conf.por_rele=11;
;;;563    	conf.tm_rele_on=12;
;;;564    	conf.tm_rele_off=13;
;;;565    	conf.rez16=14;
;;;566    	
;;;567    	conf.indicators[0].numb=15;
;;;568    	conf.indicators[0].kol_cifr=16;
;;;569    	conf.indicators[1].numb=17;
;;;570    	conf.indicators[1].kol_cifr=18;
;;;571    	conf.indicators[2].numb=19;
;;;572    	conf.indicators[2].kol_cifr=20;
;;;573    	conf.indicators[3].numb=21;
;;;574    	conf.indicators[3].kol_cifr=2;
;;;575    	conf.gr_kal1.tabl1.kod[0]=23;
;;;576    	conf.gr_kal1.tabl1.fz[0]=24;
;;;577    	conf.gr_kal1.tabl2.kod[0]=25;
;;;578    	conf.gr_kal1.tabl2.fz[0]=26;
;;;579    	conf.gr_kal2.tabl1.kod[0]=27;
;;;580    	conf.gr_kal2.tabl1.fz[0]=28;
;;;581    	conf.gr_kal2.tabl2.kod[0]=29;
;;;582    	conf.gr_kal2.tabl2.fz[0]=30;
;;;583    	conf.gr_kal2.tabl2.kod[9]=31;
;;;584    	conf.gr_kal2.tabl2.fz[9]=32;
;;;585    	
;;;586    */
;;;587    	
;;;588    }
;;;589    	
;;;590    __ASM volatile ("nop");
00019c  bf00              NOP      
                  |L2.414|
;;;591    
;;;592        
;;;593        // Всё, часы запустились и считают время.
;;;594    		/*
;;;595    		
;;;596    		/разрешить тактирование модулей управления питанием и управлением резервной областью
;;;597      RCC->APB1ENR |= RCC_APB1ENR_PWREN | RCC_APB1ENR_BKPEN;
;;;598      //разрешить доступ к области резервных данных
;;;599      PWR->CR |= PWR_CR_DBP;
;;;600      //если часы выключены - инициализировать их
;;;601      if ((RCC->BDCR & RCC_BDCR_RTCEN) != RCC_BDCR_RTCEN)
;;;602      {
;;;603        //выполнить сброс области резервных данных
;;;604        RCC->BDCR |=  RCC_BDCR_BDRST;
;;;605        RCC->BDCR &= ~RCC_BDCR_BDRST;
;;;606     
;;;607        //выбрать источником тактовых импульсов внешний кварц 32768 и подать тактирование
;;;608        RCC->BDCR |=  RCC_BDCR_RTCEN | RCC_BDCR_RTCSEL_LSE;
;;;609     
;;;610        RTC->CRL  |=  RTC_CRL_CNF;
;;;611        RTC->PRLL  = 0x7FFF;         //регистр деления на 32768
;;;612        RTC->CRL  &=  ~RTC_CRL_CNF;
;;;613     
;;;614        //установить бит разрешения работы и дождаться установки бита готовности
;;;615        RCC->BDCR |= RCC_BDCR_LSEON;
;;;616        while ((RCC->BDCR & RCC_BDCR_LSEON) != RCC_BDCR_LSEON){}
;;;617     
;;;618        RTC->CRL &= (uint16_t)~RTC_CRL_RSF;
;;;619        while((RTC->CRL & RTC_CRL_RSF) != RTC_CRL_RSF){}
;;;620     
;;;621        return 1;
;;;622      }
;;;623      return 0;
;;;624    	*/
;;;625    	
;;;626    	
;;;627    	/*
;;;628    	
;;;629    	// one more init кес
;;;630    	
;;;631    	RTC_InitTypeDef RTC_InitStructure;
;;;632    RTC_TimeTypeDef RTC_TimeStructure;
;;;633    RTC_DateTypeDef RTC_DateStructure;
;;;634    __IO uint32_t AsynchPrediv = 0, SynchPrediv = 0;
;;;635    __IO uint32_t TimeDisplay = 0;
;;;636    
;;;637    
;;;638    		// Enable the PWR APB1 Clock Interface 
;;;639    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
;;;640    
;;;641    //Allow access to BKP Domain 
;;;642    PWR_BackupAccessCmd(ENABLE);
;;;643      
;;;644    if (RTC_ReadBackupRegister(RTC_BKP_DR2) != 0xA5A5) {
;;;645    
;;;646    //Enable the PWR clock 
;;;647    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
;;;648    
;;;649    // Allow access to RTC 
;;;650    PWR_BackupAccessCmd(ENABLE);
;;;651    
;;;652    #if defined (RTC_CLOCK_SOURCE_LSI) // LSI used as RTC source clock
;;;653    // The RTC Clock may varies due to LSI frequency dispersion. 
;;;654    // Enable the LSI OSC 
;;;655    RCC_LSICmd(ENABLE);
;;;656    
;;;657    // Wait till LSI is ready 
;;;658    while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
;;;659    {
;;;660    }
;;;661    
;;;662    // Select the RTC Clock Source 
;;;663    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);
;;;664    
;;;665    SynchPrediv = 0xFF;
;;;666    AsynchPrediv = 0x7F;
;;;667    
;;;668    #elif defined (RTC_CLOCK_SOURCE_LSE) // LSE used as RTC source clock 
;;;669    // Enable the LSE OSC 
;;;670    RCC_LSEConfig(RCC_LSE_ON);
;;;671    
;;;672    // Wait till LSE is ready 
;;;673    while(RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
;;;674    {
;;;675    }
;;;676    
;;;677    // Select the RTC Clock Source 
;;;678    RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
;;;679    
;;;680    SynchPrediv = 0xFF;
;;;681    AsynchPrediv = 0x7F;
;;;682    
;;;683    #else
;;;684    #error Please select the RTC Clock source inside the main.c file
;;;685    #endif // RTC_CLOCK_SOURCE_LSI 
;;;686    
;;;687    // Enable the RTC Clock 
;;;688    RCC_RTCCLKCmd(ENABLE);
;;;689    
;;;690    // Wait for RTC APB registers synchronisation 
;;;691    RTC_WaitForSynchro();
;;;692    
;;;693    // Allow access to BKP Domain 
;;;694    PWR_BackupAccessCmd(ENABLE);
;;;695    
;;;696    // Write to the first RTC Backup Data Register 
;;;697    RTC_WriteBackupRegister(RTC_BKP_DR2,0xA5A5);
;;;698    
;;;699    //Set the Time 
;;;700    RTC_TimeStructure.RTC_Hours = 22;
;;;701    RTC_TimeStructure.RTC_Minutes = 11;
;;;702    RTC_TimeStructure.RTC_Seconds = 00;
;;;703    
;;;704    // Set the Date 
;;;705    RTC_DateStructure.RTC_Month = 4;
;;;706    RTC_DateStructure.RTC_Date = 29;
;;;707    RTC_DateStructure.RTC_Year = 11;
;;;708    RTC_DateStructure.RTC_WeekDay = RTC_Weekday_Friday;
;;;709    
;;;710    //Calendar Configuration 
;;;711    RTC_InitStructure.RTC_AsynchPrediv = AsynchPrediv;
;;;712    RTC_InitStructure.RTC_SynchPrediv = SynchPrediv;
;;;713    RTC_InitStructure.RTC_HourFormat = RTC_HourFormat_24;
;;;714    RTC_Init(&RTC_InitStructure);
;;;715    
;;;716    // Set Current Time and Date 
;;;717    RTC_SetTime(RTC_Format_BIN, &RTC_TimeStructure);
;;;718    RTC_SetDate(RTC_Format_BIN, &RTC_DateStructure);
;;;719    #if 0
;;;720    //Configure the RTC Wakeup Clock source and Counter (Wakeup event each 1 second) 
;;;721    RTC_WakeUpClockConfig(RTC_WakeUpClock_RTCCLK_Div16);
;;;722    RTC_SetWakeUpCounter(0x7FF);
;;;723    
;;;724    // Enable the Wakeup Interrupt 
;;;725    RTC_ITConfig(RTC_IT_WUT, ENABLE);
;;;726    
;;;727    //Enable Wakeup Counter 
;;;728    RTC_WakeUpCmd(ENABLE);
;;;729    #endif
;;;730    // Backup SRAM **************************************************************
;;;731    //Enable BKPRAM Clock 
;;;732    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
;;;733    
;;;734    //Enable the Backup SRAM low power Regulator to retain it's content in VBAT mode 
;;;735    PWR_BackupRegulatorCmd(ENABLE);
;;;736    
;;;737    // Wait until the Backup SRAM low power Regulator is ready 
;;;738    while(PWR_GetFlagStatus(PWR_FLAG_BRR) == RESET)
;;;739    {
;;;740    }
;;;741    
;;;742    }
;;;743    else{
;;;744    
;;;745    // Enable the PWR clock 
;;;746    RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE);
;;;747    
;;;748    // Allow access to RTC 
;;;749    PWR_BackupAccessCmd(ENABLE);
;;;750    
;;;751    // Wait for RTC APB registers synchronisation 
;;;752    RTC_WaitForSynchro();
;;;753    // Clear the Wakeup Interrupt 
;;;754    RTC_ClearITPendingBit(RTC_IT_WUT);
;;;755    
;;;756    // Backup SRAM **************************************************************
;;;757    // Enable BKPSRAM Clock 
;;;758    RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_BKPSRAM, ENABLE);
;;;759    }
;;;760    
;;;761    
;;;762    	
;;;763    	*/
;;;764    	
;;;765    }
00019e  e8bd9ffc          POP      {r2-r12,pc}
                  |L2.418|
0001a2  8007              STRH     r7,[r0,#0]            ;475
0001a4  f8a18000          STRH     r8,[r1,#0]            ;476
0001a8  e7e8              B        |L2.380|
;;;766    
                          ENDP

0001aa  0000              DCW      0x0000
                  |L2.428|
                          DCD      0x4000280c
                  |L2.432|
                          DCD      0x40023840
                  |L2.436|
                          DCD      0x40007000
                  |L2.440|
                          DCD      ||.data||
                  |L2.444|
                          DCD      0x0800c000
                  |L2.448|
                          DCD      conf
                  |L2.452|
                          DCD      0x40024000
                  |L2.456|
                          DCD      kol_usr
                  |L2.460|
                          DCD      0x40020000
                  |L2.464|
                          DCD      0x40020800
                  |L2.468|
                          DCD      sost_flesh
                  |L2.472|
                          DCD      0x40021000
                  |L2.476|
                          DCD      avariya

                          AREA ||i.rtc_Lock||, CODE, READONLY, ALIGN=2

                  rtc_Lock PROC
;;;24     // Включить защиту от записи
;;;25      void rtc_Lock(void)
000000  4901              LDR      r1,|L3.8|
;;;26     {
;;;27         // Запишем какую-нибудь фигню, главное, чтоб не правильную
;;;28         RTC->WPR = 0xFF;
000002  20ff              MOVS     r0,#0xff
000004  6008              STR      r0,[r1,#0]
;;;29     }
000006  4770              BX       lr
;;;30     
                          ENDP

                  |L3.8|
                          DCD      0x40002824

                          AREA ||i.rtc_Reset||, CODE, READONLY, ALIGN=2

                  rtc_Reset PROC
;;;112    // Сброс состояния часов
;;;113    void rtc_Reset(void)
000000  480a              LDR      r0,|L4.44|
;;;114    {
;;;115        // Включим тактирование PWR
;;;116        RCC->APB1ENR |= RCC_APB1ENR_PWREN;
000002  6801              LDR      r1,[r0,#0]
000004  f0415180          ORR      r1,r1,#0x10000000
000008  6001              STR      r1,[r0,#0]
;;;117        
;;;118        // Разрешим доступ к управляющим регистрам энергонезависимого домена
;;;119        PWR->CR |= PWR_CR_DBP;
00000a  4809              LDR      r0,|L4.48|
00000c  6801              LDR      r1,[r0,#0]
00000e  f4417180          ORR      r1,r1,#0x100
000012  6001              STR      r1,[r0,#0]
;;;120        
;;;121        // Выберем его как источник тактирования RTC:
;;;122        RCC->BDCR |=  RCC_BDCR_BDRST;
000014  4805              LDR      r0,|L4.44|
000016  3030              ADDS     r0,r0,#0x30
000018  6801              LDR      r1,[r0,#0]
00001a  f4413180          ORR      r1,r1,#0x10000
00001e  6001              STR      r1,[r0,#0]
;;;123        RCC->BDCR &= ~RCC_BDCR_BDRST;
000020  6801              LDR      r1,[r0,#0]
000022  f4213180          BIC      r1,r1,#0x10000
000026  6001              STR      r1,[r0,#0]
;;;124    }
000028  4770              BX       lr
;;;125    
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      0x40023840
                  |L4.48|
                          DCD      0x40007000

                          AREA ||i.rtc_SetDate||, CODE, READONLY, ALIGN=2

                  rtc_SetDate PROC
;;;31     // Установить дату
;;;32     void rtc_SetDate(uint8_t Day, uint8_t Month, uint8_t Year, uint8_t DayOfWeek)
000000  b5f0              PUSH     {r4-r7,lr}
;;;33     {
;;;34         uint32_t Tens, Units;
;;;35         uint32_t TempReg = 0;
;;;36         
;;;37         // Очистим поле даты
;;;38         TempReg = 0;
;;;39         
;;;40         // Запишем год
;;;41         {
;;;42             Tens  = (Year / 10) & 0x0f;          // Десятки лет
000002  260a              MOVS     r6,#0xa
000004  fbb2f4f6          UDIV     r4,r2,r6
000008  f004040f          AND      r4,r4,#0xf
;;;43             Units = (Year - (Tens * 10)) & 0x0f; // Единицы лет
00000c  4265              RSBS     r5,r4,#0
00000e  eb050585          ADD      r5,r5,r5,LSL #2
000012  2700              MOVS     r7,#0                 ;35
000014  eb020245          ADD      r2,r2,r5,LSL #1
000018  f002020f          AND      r2,r2,#0xf
;;;44             
;;;45             TempReg |= (Tens  << 20); // YT, 20
00001c  ea475404          ORR      r4,r7,r4,LSL #20
;;;46             TempReg |= (Units << 16); // YU, 16
000020  ea444502          ORR      r5,r4,r2,LSL #16
;;;47         }
;;;48         // Запишем месяц
;;;49         {
;;;50             Tens  = (Month / 10) & 0x01;          // Десятки месяцев
000024  fbb1f2f6          UDIV     r2,r1,r6
000028  f0020201          AND      r2,r2,#1
;;;51             Units = (Month - (Tens * 10)) & 0x0f; // Единицы месяцев
00002c  4254              RSBS     r4,r2,#0
00002e  eb040484          ADD      r4,r4,r4,LSL #2
000032  eb010144          ADD      r1,r1,r4,LSL #1
000036  f001010f          AND      r1,r1,#0xf
;;;52             
;;;53             TempReg |= (Tens  << 12); // MT, 12
00003a  ea453202          ORR      r2,r5,r2,LSL #12
;;;54             TempReg |= (Units << 8);  // MU, 8
00003e  ea422401          ORR      r4,r2,r1,LSL #8
;;;55         }
;;;56         // Запишем день
;;;57         {
;;;58             Tens  = (Day / 10) & 0x03;          // Десятки дней
000042  fbb0f1f6          UDIV     r1,r0,r6
000046  f0010103          AND      r1,r1,#3
;;;59             Units = (Day - (Tens * 10)) & 0x0f; // Единицы дней
00004a  424a              RSBS     r2,r1,#0
00004c  eb020282          ADD      r2,r2,r2,LSL #2
000050  eb000042          ADD      r0,r0,r2,LSL #1
000054  f000020f          AND      r2,r0,#0xf
;;;60             
;;;61             TempReg |= (Tens  << 4); // DT, 4
000058  ea441001          ORR      r0,r4,r1,LSL #4
;;;62             TempReg |= (Units << 0);  // DU, 0
00005c  4310              ORRS     r0,r0,r2
;;;63         }
;;;64         // День недели:
;;;65         {
;;;66             TempReg |= ((DayOfWeek & 0x07) << 13); // WDU, 13
00005e  f0030107          AND      r1,r3,#7
000062  ea403041          ORR      r0,r0,r1,LSL #13
;;;67         }
;;;68         
;;;69         // Записывать надо всё сразу
;;;70         RTC->DR = TempReg;
000066  4901              LDR      r1,|L5.108|
000068  6008              STR      r0,[r1,#0]
;;;71     }
00006a  bdf0              POP      {r4-r7,pc}
;;;72     
                          ENDP

                  |L5.108|
                          DCD      0x40002804

                          AREA ||i.rtc_SetTime||, CODE, READONLY, ALIGN=2

                  rtc_SetTime PROC
;;;74     //static void rtc_SetTime(uint8_t Hours, uint8_t Minutes, uint8_t Seconds)
;;;75     void rtc_SetTime(uint8_t Hours, uint8_t Minutes, uint8_t Seconds)
000000  b570              PUSH     {r4-r6,lr}
;;;76     {
;;;77         uint32_t Tens, Units;
;;;78         uint32_t TempReg = 0;
;;;79         
;;;80         // Очистим поле даты
;;;81         TempReg = 0;
;;;82         
;;;83         // Запишем часы
;;;84         {
;;;85             Tens  = (Hours / 10) & 0x03;          // Десятки часов
000002  250a              MOVS     r5,#0xa
000004  fbb0f3f5          UDIV     r3,r0,r5
000008  f0030303          AND      r3,r3,#3
;;;86             Units = (Hours - (Tens * 10)) & 0x0f; // Единицы часов
00000c  425c              RSBS     r4,r3,#0
00000e  eb040484          ADD      r4,r4,r4,LSL #2
000012  2600              MOVS     r6,#0                 ;78
000014  eb000044          ADD      r0,r0,r4,LSL #1
000018  f000000f          AND      r0,r0,#0xf
;;;87             
;;;88             TempReg |= (Tens  << 20); // HT, 20
00001c  ea465303          ORR      r3,r6,r3,LSL #20
;;;89             TempReg |= (Units << 16); // HU, 16
000020  ea434400          ORR      r4,r3,r0,LSL #16
;;;90         }
;;;91         // Запишем минуты
;;;92         {
;;;93             Tens  = (Minutes / 10) & 0x07;          // Десятки минут
000024  fbb1f0f5          UDIV     r0,r1,r5
000028  f0000007          AND      r0,r0,#7
;;;94             Units = (Minutes - (Tens * 10)) & 0x0f; // Единицы минут
00002c  4243              RSBS     r3,r0,#0
00002e  eb030383          ADD      r3,r3,r3,LSL #2
000032  eb010143          ADD      r1,r1,r3,LSL #1
000036  f001010f          AND      r1,r1,#0xf
;;;95             
;;;96             TempReg |= (Tens  << 12); // MNT, 12
00003a  ea443000          ORR      r0,r4,r0,LSL #12
;;;97             TempReg |= (Units << 8);  // MNU, 8
00003e  ea402301          ORR      r3,r0,r1,LSL #8
;;;98         }
;;;99         // Запишем секунды
;;;100        {
;;;101            Tens  = (Seconds / 10) & 0x07;          // Десятки секунд
000042  fbb2f0f5          UDIV     r0,r2,r5
000046  f0000007          AND      r0,r0,#7
;;;102            Units = (Seconds - (Tens * 10)) & 0x0f; // Единицы секунд
00004a  4241              RSBS     r1,r0,#0
00004c  eb010181          ADD      r1,r1,r1,LSL #2
000050  eb020141          ADD      r1,r2,r1,LSL #1
000054  f001010f          AND      r1,r1,#0xf
;;;103            
;;;104            TempReg |= (Tens  << 4); // ST, 4
000058  ea431000          ORR      r0,r3,r0,LSL #4
;;;105            TempReg |= (Units << 0);  // SU, 0
00005c  4308              ORRS     r0,r0,r1
;;;106        }
;;;107        
;;;108        // Записывать надо всё сразу
;;;109        RTC->TR = TempReg;
00005e  4901              LDR      r1,|L6.100|
000060  6008              STR      r0,[r1,#0]
;;;110    }
000062  bd70              POP      {r4-r6,pc}
;;;111    
                          ENDP

                  |L6.100|
                          DCD      0x40002800

                          AREA ||i.rtc_Unlock||, CODE, READONLY, ALIGN=2

                  rtc_Unlock PROC
;;;16     // Выключить защиту от записи
;;;17     void rtc_Unlock(void)
000000  4802              LDR      r0,|L7.12|
;;;18     {
;;;19         // Запишем эти значения по очереди
;;;20         RTC->WPR = 0xCA;
000002  21ca              MOVS     r1,#0xca
000004  6001              STR      r1,[r0,#0]
;;;21         RTC->WPR = 0x53;
000006  2153              MOVS     r1,#0x53
000008  6001              STR      r1,[r0,#0]
;;;22     }
00000a  4770              BX       lr
;;;23     
                          ENDP

                  |L7.12|
                          DCD      0x40002824

                          AREA ||.data||, DATA, ALIGN=1

                  bkp
000000  0000              DCW      0x0000
                  size
000002  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "src\\rtc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_rtc_c_bkp____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___5_rtc_c_bkp____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_rtc_c_bkp____REVSH|
#line 128
|__asm___5_rtc_c_bkp____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
