; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\MEDIA_USB_KEY\stm32f4xx_tim.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\MEDIA_USB_KEY\stm32f4xx_tim.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\MEDIA_USB_KEY\stm32f4xx_tim.crf Libraries\CMSIS\stm32f4xx_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=1

                  TI1_Config PROC
;;;3190     */
;;;3191   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;3192                          uint16_t TIM_ICFilter)
;;;3193   {
;;;3194     uint16_t tmpccmr1 = 0, tmpccer = 0;
;;;3195   
;;;3196     /* Disable the Channel 1: Reset the CC1E Bit */
;;;3197     TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
000002  8c04              LDRH     r4,[r0,#0x20]
000004  f0240401          BIC      r4,r4,#1
000008  8404              STRH     r4,[r0,#0x20]
;;;3198     tmpccmr1 = TIMx->CCMR1;
00000a  8b05              LDRH     r5,[r0,#0x18]
;;;3199     tmpccer = TIMx->CCER;
00000c  8c04              LDRH     r4,[r0,#0x20]
;;;3200   
;;;3201     /* Select the Input and set the filter */
;;;3202     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_IC1F);
;;;3203     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00000e  f64f76ff          MOV      r6,#0xffff
000012  ea061303          AND      r3,r6,r3,LSL #4
000016  4313              ORRS     r3,r3,r2
000018  f02505f3          BIC      r5,r5,#0xf3           ;3202
00001c  432b              ORRS     r3,r3,r5
;;;3204   
;;;3205     /* Select the Polarity and set the CC1E Bit */
;;;3206     tmpccer &= (uint16_t)~(TIM_CCER_CC1P | TIM_CCER_CC1NP);
00001e  f024020a          BIC      r2,r4,#0xa
;;;3207     tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
000022  430a              ORRS     r2,r2,r1
000024  f0420101          ORR      r1,r2,#1
;;;3208   
;;;3209     /* Write to TIMx CCMR1 and CCER registers */
;;;3210     TIMx->CCMR1 = tmpccmr1;
000028  8303              STRH     r3,[r0,#0x18]
;;;3211     TIMx->CCER = tmpccer;
00002a  8401              STRH     r1,[r0,#0x20]
;;;3212   }
00002c  bd70              POP      {r4-r6,pc}
;;;3213   
                          ENDP


                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=1

                  TI2_Config PROC
;;;3231     */
;;;3232   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b5f0              PUSH     {r4-r7,lr}
;;;3233                          uint16_t TIM_ICFilter)
;;;3234   {
;;;3235     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
;;;3236   
;;;3237     /* Disable the Channel 2: Reset the CC2E Bit */
;;;3238     TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
000002  8c04              LDRH     r4,[r0,#0x20]
000004  f0240410          BIC      r4,r4,#0x10
000008  8404              STRH     r4,[r0,#0x20]
;;;3239     tmpccmr1 = TIMx->CCMR1;
00000a  8b07              LDRH     r7,[r0,#0x18]
;;;3240     tmpccer = TIMx->CCER;
00000c  8c06              LDRH     r6,[r0,#0x20]
;;;3241     tmp = (uint16_t)(TIM_ICPolarity << 4);
00000e  f64f74ff          MOV      r4,#0xffff
000012  ea041501          AND      r5,r4,r1,LSL #4
;;;3242   
;;;3243     /* Select the Input and set the filter */
;;;3244     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC2S) & ((uint16_t)~TIM_CCMR1_IC2F);
000016  f4274773          BIC      r7,r7,#0xf300
;;;3245     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
00001a  ea043103          AND      r1,r4,r3,LSL #12
00001e  4339              ORRS     r1,r1,r7
;;;3246     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
000020  ea042202          AND      r2,r4,r2,LSL #8
000024  430a              ORRS     r2,r2,r1
;;;3247   
;;;3248     /* Select the Polarity and set the CC2E Bit */
;;;3249     tmpccer &= (uint16_t)~(TIM_CCER_CC2P | TIM_CCER_CC2NP);
000026  f02601a0          BIC      r1,r6,#0xa0
;;;3250     tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
00002a  4329              ORRS     r1,r1,r5
00002c  f0410110          ORR      r1,r1,#0x10
;;;3251   
;;;3252     /* Write to TIMx CCMR1 and CCER registers */
;;;3253     TIMx->CCMR1 = tmpccmr1 ;
000030  8302              STRH     r2,[r0,#0x18]
;;;3254     TIMx->CCER = tmpccer;
000032  8401              STRH     r1,[r0,#0x20]
;;;3255   }
000034  bdf0              POP      {r4-r7,pc}
;;;3256   
                          ENDP


                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;515      */
;;;516    void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;517    {
;;;518      /* Check the parameters */
;;;519      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;520      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;521    
;;;522      if (NewState != DISABLE)
;;;523      {
;;;524        /* Set the ARR Preload Bit */
;;;525        TIMx->CR1 |= TIM_CR1_ARPE;
;;;526      }
;;;527      else
;;;528      {
;;;529        /* Reset the ARR Preload Bit */
;;;530        TIMx->CR1 &= (uint16_t)~TIM_CR1_ARPE;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L3.12|
000006  f0410180          ORR      r1,r1,#0x80           ;525
00000a  e001              B        |L3.16|
                  |L3.12|
00000c  f0210180          BIC      r1,r1,#0x80
                  |L3.16|
000010  8001              STRH     r1,[r0,#0]            ;525
;;;531      }
;;;532    }
000012  4770              BX       lr
;;;533    
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;2210     */
;;;2211   void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  b510              PUSH     {r4,lr}
;;;2212   {
;;;2213     /* Check the parameters */
;;;2214     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2215     assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;2216     assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;2217     assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;2218     assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;2219     assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;2220     assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;2221   
;;;2222     /* Set the Lock level, the Break enable Bit and the Polarity, the OSSR State,
;;;2223        the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;2224     TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  880a              LDRH     r2,[r1,#0]
000004  884b              LDRH     r3,[r1,#2]
000006  88cc              LDRH     r4,[r1,#6]
000008  431a              ORRS     r2,r2,r3
00000a  888b              LDRH     r3,[r1,#4]
00000c  4323              ORRS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  890b              LDRH     r3,[r1,#8]
000012  431a              ORRS     r2,r2,r3
000014  894b              LDRH     r3,[r1,#0xa]
000016  8989              LDRH     r1,[r1,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  430a              ORRS     r2,r2,r1
00001c  f8a02044          STRH     r2,[r0,#0x44]
;;;2225                TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;2226                TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;2227                TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;2228   }
000020  bd10              POP      {r4,pc}
;;;2229   
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;2235     */
;;;2236   void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;2237   {
;;;2238     /* Set the default configuration */
;;;2239     TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;2240     TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;2241     TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;2242     TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;2243     TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;2244     TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;2245     TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;2246   }
000010  4770              BX       lr
;;;2247   
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;2304     */
;;;2305   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2306   { 
;;;2307     /* Check the parameters */
;;;2308     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2309     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2310     if (NewState != DISABLE)
;;;2311     {
;;;2312       /* Set the CCPC Bit */
;;;2313       TIMx->CR2 |= TIM_CR2_CCPC;
;;;2314     }
;;;2315     else
;;;2316     {
;;;2317       /* Reset the CCPC Bit */
;;;2318       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCPC;
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L6.12|
000006  f0410101          ORR      r1,r1,#1              ;2313
00000a  e001              B        |L6.16|
                  |L6.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L6.16|
000010  8081              STRH     r1,[r0,#4]            ;2313
;;;2319     }
;;;2320   }
000012  4770              BX       lr
;;;2321   /**
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;1777     */
;;;1778   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  b510              PUSH     {r4,lr}
;;;1779   {
;;;1780     uint16_t tmp = 0;
;;;1781   
;;;1782     /* Check the parameters */
;;;1783     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;1784     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1785     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1786   
;;;1787     tmp = CCER_CCE_SET << TIM_Channel;
000002  2301              MOVS     r3,#1
;;;1788   
;;;1789     /* Reset the CCxE Bit */
;;;1790     TIMx->CCER &= (uint16_t)~ tmp;
000004  8c04              LDRH     r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;1787
000008  439c              BICS     r4,r4,r3
00000a  8404              STRH     r4,[r0,#0x20]
;;;1791   
;;;1792     /* Set or reset the CCxE Bit */ 
;;;1793     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
00000c  8c03              LDRH     r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  8403              STRH     r3,[r0,#0x20]
;;;1794   }
000014  bd10              POP      {r4,pc}
;;;1795   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;1807     */
;;;1808   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000000  b510              PUSH     {r4,lr}
;;;1809   {
;;;1810     uint16_t tmp = 0;
;;;1811   
;;;1812     /* Check the parameters */
;;;1813     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1814     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;1815     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;1816   
;;;1817     tmp = CCER_CCNE_SET << TIM_Channel;
000002  2304              MOVS     r3,#4
;;;1818   
;;;1819     /* Reset the CCxNE Bit */
;;;1820     TIMx->CCER &= (uint16_t) ~tmp;
000004  8c04              LDRH     r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;1817
000008  439c              BICS     r4,r4,r3
00000a  8404              STRH     r4,[r0,#0x20]
;;;1821   
;;;1822     /* Set or reset the CCxNE Bit */ 
;;;1823     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
00000c  8c03              LDRH     r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  8403              STRH     r3,[r0,#0x20]
;;;1824   }
000014  bd10              POP      {r4,pc}
;;;1825   /**
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;2474     */
;;;2475   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43c9              MVNS     r1,r1
;;;2476   {  
;;;2477     /* Check the parameters */
;;;2478     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2479      
;;;2480     /* Clear the flags */
;;;2481     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  8201              STRH     r1,[r0,#0x10]
;;;2482   }
000004  4770              BX       lr
;;;2483   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;2543     */
;;;2544   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43c9              MVNS     r1,r1
;;;2545   {
;;;2546     /* Check the parameters */
;;;2547     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2548   
;;;2549     /* Clear the IT pending Bit */
;;;2550     TIMx->SR = (uint16_t)~TIM_IT;
000002  8201              STRH     r1,[r0,#0x10]
;;;2551   }
000004  4770              BX       lr
;;;2552   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1467     */
;;;1468   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1469   {
;;;1470     uint16_t tmpccmr1 = 0;
;;;1471   
;;;1472     /* Check the parameters */
;;;1473     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1474     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1475   
;;;1476     tmpccmr1 = TIMx->CCMR1;
;;;1477   
;;;1478     /* Reset the OC1CE Bit */
;;;1479     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1CE;
000002  f0220280          BIC      r2,r2,#0x80
;;;1480   
;;;1481     /* Enable or Disable the Output Compare Clear Bit */
;;;1482     tmpccmr1 |= TIM_OCClear;
000006  430a              ORRS     r2,r2,r1
;;;1483   
;;;1484     /* Write to TIMx CCMR1 register */
;;;1485     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1486   }
00000a  4770              BX       lr
;;;1487   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1497     */
;;;1498   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1499   {
;;;1500     uint16_t tmpccmr1 = 0;
;;;1501   
;;;1502     /* Check the parameters */
;;;1503     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1504     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1505   
;;;1506     tmpccmr1 = TIMx->CCMR1;
;;;1507   
;;;1508     /* Reset the OC2CE Bit */
;;;1509     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2CE;
;;;1510   
;;;1511     /* Enable or Disable the Output Compare Clear Bit */
;;;1512     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f3c2020e          UBFX     r2,r2,#0,#15          ;1509
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1513   
;;;1514     /* Write to TIMx CCMR1 register */
;;;1515     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1516   }
000012  4770              BX       lr
;;;1517   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1526     */
;;;1527   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1528   {
;;;1529     uint16_t tmpccmr2 = 0;
;;;1530   
;;;1531     /* Check the parameters */
;;;1532     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1533     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1534   
;;;1535     tmpccmr2 = TIMx->CCMR2;
;;;1536   
;;;1537     /* Reset the OC3CE Bit */
;;;1538     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3CE;
000002  f0220280          BIC      r2,r2,#0x80
;;;1539   
;;;1540     /* Enable or Disable the Output Compare Clear Bit */
;;;1541     tmpccmr2 |= TIM_OCClear;
000006  430a              ORRS     r2,r2,r1
;;;1542   
;;;1543     /* Write to TIMx CCMR2 register */
;;;1544     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1545   }
00000a  4770              BX       lr
;;;1546   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1555     */
;;;1556   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1557   {
;;;1558     uint16_t tmpccmr2 = 0;
;;;1559   
;;;1560     /* Check the parameters */
;;;1561     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1562     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1563   
;;;1564     tmpccmr2 = TIMx->CCMR2;
;;;1565   
;;;1566     /* Reset the OC4CE Bit */
;;;1567     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4CE;
;;;1568   
;;;1569     /* Enable or Disable the Output Compare Clear Bit */
;;;1570     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f3c2020e          UBFX     r2,r2,#0,#15          ;1567
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1571   
;;;1572     /* Write to TIMx CCMR2 register */
;;;1573     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1574   }
000012  4770              BX       lr
;;;1575   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;585      */
;;;586    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;587    {
;;;588      /* Check the parameters */
;;;589      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;590      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;591      
;;;592      if (NewState != DISABLE)
;;;593      {
;;;594        /* Enable the TIM Counter */
;;;595        TIMx->CR1 |= TIM_CR1_CEN;
;;;596      }
;;;597      else
;;;598      {
;;;599        /* Disable the TIM Counter */
;;;600        TIMx->CR1 &= (uint16_t)~TIM_CR1_CEN;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L15.12|
000006  f0410101          ORR      r1,r1,#1              ;595
00000a  e001              B        |L15.16|
                  |L15.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L15.16|
000010  8001              STRH     r1,[r0,#0]            ;595
;;;601      }
;;;602    }
000012  4770              BX       lr
;;;603    /**
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;376      */
;;;377    void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  8802              LDRH     r2,[r0,#0]
;;;378    {
;;;379      uint16_t tmpcr1 = 0;
;;;380    
;;;381      /* Check the parameters */
;;;382      assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;383      assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;384    
;;;385      tmpcr1 = TIMx->CR1;
;;;386    
;;;387      /* Reset the CMS and DIR Bits */
;;;388      tmpcr1 &= (uint16_t)~(TIM_CR1_DIR | TIM_CR1_CMS);
000002  f0220270          BIC      r2,r2,#0x70
;;;389    
;;;390      /* Set the Counter Mode */
;;;391      tmpcr1 |= TIM_CounterMode;
000006  430a              ORRS     r2,r2,r1
;;;392    
;;;393      /* Write to TIMx CR1 register */
;;;394      TIMx->CR1 = tmpcr1;
000008  8002              STRH     r2,[r0,#0]
;;;395    }
00000a  4770              BX       lr
;;;396    
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;2254     */
;;;2255   void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2256   {
;;;2257     /* Check the parameters */
;;;2258     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2259     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2260   
;;;2261     if (NewState != DISABLE)
;;;2262     {
;;;2263       /* Enable the TIM Main Output */
;;;2264       TIMx->BDTR |= TIM_BDTR_MOE;
;;;2265     }
;;;2266     else
;;;2267     {
;;;2268       /* Disable the TIM Main Output */
;;;2269       TIMx->BDTR &= (uint16_t)~TIM_BDTR_MOE;
000002  f8301f44          LDRH     r1,[r0,#0x44]!
000006  d002              BEQ      |L17.14|
000008  f4414100          ORR      r1,r1,#0x8000         ;2264
00000c  e001              B        |L17.18|
                  |L17.14|
00000e  f3c1010e          UBFX     r1,r1,#0,#15
                  |L17.18|
000012  8001              STRH     r1,[r0,#0]            ;2264
;;;2270     }  
;;;2271   }
000014  4770              BX       lr
;;;2272   
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;2607     */
;;;2608   void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;2609   { 
;;;2610     /* Check the parameters */
;;;2611     assert_param(IS_TIM_LIST5_PERIPH(TIMx)); 
;;;2612     assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;2613     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2614     
;;;2615     if (NewState != DISABLE)
;;;2616     {
;;;2617       /* Enable the DMA sources */
;;;2618       TIMx->DIER |= TIM_DMASource; 
;;;2619     }
;;;2620     else
;;;2621     {
;;;2622       /* Disable the DMA sources */
;;;2623       TIMx->DIER &= (uint16_t)~TIM_DMASource;
000002  8982              LDRH     r2,[r0,#0xc]
000004  d001              BEQ      |L18.10|
000006  430a              ORRS     r2,r2,r1              ;2618
000008  e000              B        |L18.12|
                  |L18.10|
00000a  438a              BICS     r2,r2,r1
                  |L18.12|
00000c  8182              STRH     r2,[r0,#0xc]          ;2618
;;;2624     }
;;;2625   }
00000e  4770              BX       lr
;;;2626   
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;2580     */
;;;2581   void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  4311              ORRS     r1,r1,r2
;;;2582   {
;;;2583     /* Check the parameters */
;;;2584     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2585     assert_param(IS_TIM_DMA_BASE(TIM_DMABase)); 
;;;2586     assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;2587   
;;;2588     /* Set the DMA Base and the DMA Burst Length */
;;;2589     TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000002  f8a01048          STRH     r1,[r0,#0x48]
;;;2590   }
000006  4770              BX       lr
;;;2591   
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;193      */
;;;194    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  4946              LDR      r1,|L20.284|
;;;195    {
000002  b510              PUSH     {r4,lr}
;;;196      /* Check the parameters */
;;;197      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;198     
;;;199      if (TIMx == TIM1)
000004  4288              CMP      r0,r1
000006  d106              BNE      |L20.22|
;;;200      {
;;;201        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;202        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
000010  2100              MOVS     r1,#0
000012  2001              MOVS     r0,#1
000014  e05b              B        |L20.206|
                  |L20.22|
;;;203      } 
;;;204      else if (TIMx == TIM2) 
000016  f1b04f80          CMP      r0,#0x40000000
00001a  d009              BEQ      |L20.48|
;;;205      {     
;;;206        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
;;;207        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
;;;208      }  
;;;209      else if (TIMx == TIM3)
00001c  4940              LDR      r1,|L20.288|
00001e  4288              CMP      r0,r1
000020  d10d              BNE      |L20.62|
;;;210      { 
;;;211        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
000022  2101              MOVS     r1,#1
000024  2002              MOVS     r0,#2
000026  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;212        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
00002a  2100              MOVS     r1,#0
00002c  2002              MOVS     r0,#2
00002e  e070              B        |L20.274|
                  |L20.48|
000030  2101              MOVS     r1,#1                 ;206
000032  4608              MOV      r0,r1                 ;206
000034  f7fffffe          BL       RCC_APB1PeriphResetCmd
000038  2100              MOVS     r1,#0                 ;207
00003a  2001              MOVS     r0,#1                 ;207
00003c  e069              B        |L20.274|
                  |L20.62|
;;;213      }  
;;;214      else if (TIMx == TIM4)
00003e  4939              LDR      r1,|L20.292|
000040  4288              CMP      r0,r1
000042  d106              BNE      |L20.82|
;;;215      { 
;;;216        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
000044  2101              MOVS     r1,#1
000046  2004              MOVS     r0,#4
000048  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;217        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
00004c  2100              MOVS     r1,#0
00004e  2004              MOVS     r0,#4
000050  e05f              B        |L20.274|
                  |L20.82|
;;;218      }  
;;;219      else if (TIMx == TIM5)
000052  4935              LDR      r1,|L20.296|
000054  4288              CMP      r0,r1
000056  d106              BNE      |L20.102|
;;;220      {      
;;;221        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
000058  2101              MOVS     r1,#1
00005a  2008              MOVS     r0,#8
00005c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;222        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
000060  2100              MOVS     r1,#0
000062  2008              MOVS     r0,#8
000064  e055              B        |L20.274|
                  |L20.102|
;;;223      }  
;;;224      else if (TIMx == TIM6)  
000066  4931              LDR      r1,|L20.300|
000068  4288              CMP      r0,r1
00006a  d106              BNE      |L20.122|
;;;225      {    
;;;226        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
00006c  2101              MOVS     r1,#1
00006e  2010              MOVS     r0,#0x10
000070  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;227        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
000074  2100              MOVS     r1,#0
000076  2010              MOVS     r0,#0x10
000078  e04b              B        |L20.274|
                  |L20.122|
;;;228      }  
;;;229      else if (TIMx == TIM7)
00007a  492d              LDR      r1,|L20.304|
00007c  4288              CMP      r0,r1
00007e  d106              BNE      |L20.142|
;;;230      {      
;;;231        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
000080  2101              MOVS     r1,#1
000082  2020              MOVS     r0,#0x20
000084  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;232        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
000088  2100              MOVS     r1,#0
00008a  2020              MOVS     r0,#0x20
00008c  e041              B        |L20.274|
                  |L20.142|
;;;233      }  
;;;234      else if (TIMx == TIM8)
00008e  4929              LDR      r1,|L20.308|
000090  4288              CMP      r0,r1
000092  d106              BNE      |L20.162|
;;;235      {      
;;;236        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
000094  2101              MOVS     r1,#1
000096  2002              MOVS     r0,#2
000098  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;237        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);  
00009c  2100              MOVS     r1,#0
00009e  2002              MOVS     r0,#2
0000a0  e015              B        |L20.206|
                  |L20.162|
;;;238      }  
;;;239      else if (TIMx == TIM9)
0000a2  4925              LDR      r1,|L20.312|
0000a4  4288              CMP      r0,r1
0000a6  d102              BNE      |L20.174|
;;;240      {      
;;;241        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
0000a8  2101              MOVS     r1,#1
0000aa  040c              LSLS     r4,r1,#16
;;;242        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
0000ac  e00a              B        |L20.196|
                  |L20.174|
;;;243       }  
;;;244      else if (TIMx == TIM10)
0000ae  4923              LDR      r1,|L20.316|
0000b0  4288              CMP      r0,r1
0000b2  d102              BNE      |L20.186|
;;;245      {      
;;;246        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
0000b4  2101              MOVS     r1,#1
0000b6  044c              LSLS     r4,r1,#17
;;;247        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
0000b8  e004              B        |L20.196|
                  |L20.186|
;;;248      }  
;;;249      else if (TIMx == TIM11) 
0000ba  4921              LDR      r1,|L20.320|
0000bc  4288              CMP      r0,r1
0000be  d10a              BNE      |L20.214|
;;;250      {     
;;;251        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
0000c0  2101              MOVS     r1,#1
0000c2  048c              LSLS     r4,r1,#18
                  |L20.196|
0000c4  4620              MOV      r0,r4
0000c6  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;252        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
0000ca  2100              MOVS     r1,#0
0000cc  4620              MOV      r0,r4
                  |L20.206|
0000ce  e8bd4010          POP      {r4,lr}
0000d2  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L20.214|
;;;253      }  
;;;254      else if (TIMx == TIM12)
0000d6  491b              LDR      r1,|L20.324|
0000d8  4288              CMP      r0,r1
0000da  d106              BNE      |L20.234|
;;;255      {      
;;;256        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
0000dc  2101              MOVS     r1,#1
0000de  2040              MOVS     r0,#0x40
0000e0  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;257        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
0000e4  2100              MOVS     r1,#0
0000e6  2040              MOVS     r0,#0x40
0000e8  e013              B        |L20.274|
                  |L20.234|
;;;258      }  
;;;259      else if (TIMx == TIM13) 
0000ea  4917              LDR      r1,|L20.328|
0000ec  4288              CMP      r0,r1
0000ee  d106              BNE      |L20.254|
;;;260      {       
;;;261        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
0000f0  2101              MOVS     r1,#1
0000f2  2080              MOVS     r0,#0x80
0000f4  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;262        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
0000f8  2100              MOVS     r1,#0
0000fa  2080              MOVS     r0,#0x80
0000fc  e009              B        |L20.274|
                  |L20.254|
;;;263      }  
;;;264      else
;;;265      { 
;;;266        if (TIMx == TIM14) 
0000fe  4913              LDR      r1,|L20.332|
000100  4288              CMP      r0,r1
000102  d10a              BNE      |L20.282|
;;;267        {     
;;;268          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
000104  1584              ASRS     r4,r0,#22
000106  2101              MOVS     r1,#1
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;269          RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE); 
00010e  2100              MOVS     r1,#0
000110  4620              MOV      r0,r4
                  |L20.274|
000112  e8bd4010          POP      {r4,lr}
000116  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L20.282|
;;;270        }   
;;;271      }
;;;272    }
00011a  bd10              POP      {r4,pc}
;;;273    
                          ENDP

                  |L20.284|
                          DCD      0x40010000
                  |L20.288|
                          DCD      0x40000400
                  |L20.292|
                          DCD      0x40000800
                  |L20.296|
                          DCD      0x40000c00
                  |L20.300|
                          DCD      0x40001000
                  |L20.304|
                          DCD      0x40001400
                  |L20.308|
                          DCD      0x40010400
                  |L20.312|
                          DCD      0x40014000
                  |L20.316|
                          DCD      0x40014400
                  |L20.320|
                          DCD      0x40014800
                  |L20.324|
                          DCD      0x40001800
                  |L20.328|
                          DCD      0x40001c00
                  |L20.332|
                          DCD      0x40002000

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;2763     */
;;;2764   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000000  b510              PUSH     {r4,lr}
;;;2765                               uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2766   {
000002  4604              MOV      r4,r0
;;;2767     uint16_t tmpsmcr = 0;
;;;2768   
;;;2769     /* Check the parameters */
;;;2770     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2771     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2772     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2773     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2774     /* Configure the ETR Clock source */
;;;2775     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000004  f7fffffe          BL       TIM_ETRConfig
;;;2776     
;;;2777     /* Get the TIMx SMCR register value */
;;;2778     tmpsmcr = TIMx->SMCR;
000008  8920              LDRH     r0,[r4,#8]
;;;2779   
;;;2780     /* Reset the SMS Bits */
;;;2781     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
;;;2782   
;;;2783     /* Select the External clock mode1 */
;;;2784     tmpsmcr |= TIM_SlaveMode_External1;
;;;2785   
;;;2786     /* Select the Trigger selection : ETRF */
;;;2787     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
;;;2788     tmpsmcr |= TIM_TS_ETRF;
00000a  f0400077          ORR      r0,r0,#0x77
;;;2789   
;;;2790     /* Write to TIMx SMCR */
;;;2791     TIMx->SMCR = tmpsmcr;
00000e  8120              STRH     r0,[r4,#8]
;;;2792   }
000010  bd10              POP      {r4,pc}
;;;2793   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;2810     */
;;;2811   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b510              PUSH     {r4,lr}
;;;2812                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;2813   {
000002  4604              MOV      r4,r0
;;;2814     /* Check the parameters */
;;;2815     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2816     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;2817     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;2818     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;2819   
;;;2820     /* Configure the ETR Clock source */
;;;2821     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000004  f7fffffe          BL       TIM_ETRConfig
;;;2822   
;;;2823     /* Enable the External clock mode2 */
;;;2824     TIMx->SMCR |= TIM_SMCR_ECE;
000008  8920              LDRH     r0,[r4,#8]
00000a  f4404080          ORR      r0,r0,#0x4000
00000e  8120              STRH     r0,[r4,#8]
;;;2825   }
000010  bd10              POP      {r4,pc}
;;;2826   /**
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;2998     */
;;;2999   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler,
000000  b530              PUSH     {r4,r5,lr}
;;;3000                      uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;3001   {
;;;3002     uint16_t tmpsmcr = 0;
;;;3003   
;;;3004     /* Check the parameters */
;;;3005     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;3006     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;3007     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;3008     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;3009   
;;;3010     tmpsmcr = TIMx->SMCR;
000002  8904              LDRH     r4,[r0,#8]
;;;3011   
;;;3012     /* Reset the ETR Bits */
;;;3013     tmpsmcr &= SMCR_ETR_MASK;
;;;3014   
;;;3015     /* Set the Prescaler, the Filter value and the Polarity */
;;;3016     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
000004  f64f75ff          MOV      r5,#0xffff
000008  ea052303          AND      r3,r5,r3,LSL #8
00000c  4313              ORRS     r3,r3,r2
00000e  b2e4              UXTB     r4,r4                 ;3013
000010  430b              ORRS     r3,r3,r1
000012  4323              ORRS     r3,r3,r4
;;;3017   
;;;3018     /* Write to TIMx SMCR */
;;;3019     TIMx->SMCR = tmpsmcr;
000014  8103              STRH     r3,[r0,#8]
;;;3020   }
000016  bd30              POP      {r4,r5,pc}
;;;3021   /**
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;3056     */
;;;3057   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b570              PUSH     {r4-r6,lr}
;;;3058                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;3059   {
;;;3060     uint16_t tmpsmcr = 0;
;;;3061     uint16_t tmpccmr1 = 0;
;;;3062     uint16_t tmpccer = 0;
;;;3063       
;;;3064     /* Check the parameters */
;;;3065     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3066     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;3067     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;3068     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;3069   
;;;3070     /* Get the TIMx SMCR register value */
;;;3071     tmpsmcr = TIMx->SMCR;
000002  8905              LDRH     r5,[r0,#8]
;;;3072   
;;;3073     /* Get the TIMx CCMR1 register value */
;;;3074     tmpccmr1 = TIMx->CCMR1;
000004  8b04              LDRH     r4,[r0,#0x18]
;;;3075   
;;;3076     /* Get the TIMx CCER register value */
;;;3077     tmpccer = TIMx->CCER;
000006  8c06              LDRH     r6,[r0,#0x20]
;;;3078   
;;;3079     /* Set the encoder Mode */
;;;3080     tmpsmcr &= (uint16_t)~TIM_SMCR_SMS;
000008  f0250507          BIC      r5,r5,#7
;;;3081     tmpsmcr |= TIM_EncoderMode;
00000c  430d              ORRS     r5,r5,r1
;;;3082   
;;;3083     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;3084     tmpccmr1 &= ((uint16_t)~TIM_CCMR1_CC1S) & ((uint16_t)~TIM_CCMR1_CC2S);
00000e  f64f41fc          MOV      r1,#0xfcfc
000012  400c              ANDS     r4,r4,r1
;;;3085     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
000014  f2401101          MOV      r1,#0x101
000018  430c              ORRS     r4,r4,r1
;;;3086   
;;;3087     /* Set the TI1 and the TI2 Polarities */
;;;3088     tmpccer &= ((uint16_t)~TIM_CCER_CC1P) & ((uint16_t)~TIM_CCER_CC2P);
;;;3089     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
00001a  f64f71ff          MOV      r1,#0xffff
00001e  ea011103          AND      r1,r1,r3,LSL #4
000022  f0260622          BIC      r6,r6,#0x22           ;3088
000026  4311              ORRS     r1,r1,r2
000028  4331              ORRS     r1,r1,r6
;;;3090   
;;;3091     /* Write to TIMx SMCR */
;;;3092     TIMx->SMCR = tmpsmcr;
00002a  8105              STRH     r5,[r0,#8]
;;;3093   
;;;3094     /* Write to TIMx CCMR1 */
;;;3095     TIMx->CCMR1 = tmpccmr1;
00002c  8304              STRH     r4,[r0,#0x18]
;;;3096   
;;;3097     /* Write to TIMx CCER */
;;;3098     TIMx->CCER = tmpccer;
00002e  8401              STRH     r1,[r0,#0x20]
;;;3099   }
000030  bd70              POP      {r4-r6,pc}
;;;3100   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;1115     */
;;;1116   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1117   {
;;;1118     uint16_t tmpccmr1 = 0;
;;;1119   
;;;1120     /* Check the parameters */
;;;1121     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1122     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1123     tmpccmr1 = TIMx->CCMR1;
;;;1124   
;;;1125     /* Reset the OC1M Bits */
;;;1126     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1M;
000002  f0220270          BIC      r2,r2,#0x70
;;;1127   
;;;1128     /* Configure The Forced output Mode */
;;;1129     tmpccmr1 |= TIM_ForcedAction;
000006  430a              ORRS     r2,r2,r1
;;;1130   
;;;1131     /* Write to TIMx CCMR1 register */
;;;1132     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1133   }
00000a  4770              BX       lr
;;;1134   
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;1144     */
;;;1145   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1146   {
;;;1147     uint16_t tmpccmr1 = 0;
;;;1148   
;;;1149     /* Check the parameters */
;;;1150     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1151     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1152     tmpccmr1 = TIMx->CCMR1;
;;;1153   
;;;1154     /* Reset the OC2M Bits */
;;;1155     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC2M;
;;;1156   
;;;1157     /* Configure The Forced output Mode */
;;;1158     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f42242e0          BIC      r2,r2,#0x7000         ;1155
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1159   
;;;1160     /* Write to TIMx CCMR1 register */
;;;1161     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1162   }
000012  4770              BX       lr
;;;1163   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1172     */
;;;1173   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1174   {
;;;1175     uint16_t tmpccmr2 = 0;
;;;1176   
;;;1177     /* Check the parameters */
;;;1178     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1179     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1180   
;;;1181     tmpccmr2 = TIMx->CCMR2;
;;;1182   
;;;1183     /* Reset the OC1M Bits */
;;;1184     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3M;
000002  f0220270          BIC      r2,r2,#0x70
;;;1185   
;;;1186     /* Configure The Forced output Mode */
;;;1187     tmpccmr2 |= TIM_ForcedAction;
000006  430a              ORRS     r2,r2,r1
;;;1188   
;;;1189     /* Write to TIMx CCMR2 register */
;;;1190     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1191   }
00000a  4770              BX       lr
;;;1192   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1201     */
;;;1202   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1203   {
;;;1204     uint16_t tmpccmr2 = 0;
;;;1205   
;;;1206     /* Check the parameters */
;;;1207     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1208     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1209     tmpccmr2 = TIMx->CCMR2;
;;;1210   
;;;1211     /* Reset the OC2M Bits */
;;;1212     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC4M;
;;;1213   
;;;1214     /* Configure The Forced output Mode */
;;;1215     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f42242e0          BIC      r2,r2,#0x7000         ;1212
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1216   
;;;1217     /* Write to TIMx CCMR2 register */
;;;1218     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1219   }
000012  4770              BX       lr
;;;1220   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;2399     */
;;;2400   void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;2401   { 
;;;2402     /* Check the parameters */
;;;2403     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2404     assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;2405    
;;;2406     /* Set the event sources */
;;;2407     TIMx->EGR = TIM_EventSource;
;;;2408   }
000002  4770              BX       lr
;;;2409   
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2021     */
;;;2022   uint32_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  6b40              LDR      r0,[r0,#0x34]
;;;2023   {
;;;2024     /* Check the parameters */
;;;2025     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2026   
;;;2027     /* Get the Capture 1 Register value */
;;;2028     return TIMx->CCR1;
;;;2029   }
000002  4770              BX       lr
;;;2030   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2036     */
;;;2037   uint32_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  6b80              LDR      r0,[r0,#0x38]
;;;2038   {
;;;2039     /* Check the parameters */
;;;2040     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2041   
;;;2042     /* Get the Capture 2 Register value */
;;;2043     return TIMx->CCR2;
;;;2044   }
000002  4770              BX       lr
;;;2045   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2050     */
;;;2051   uint32_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;2052   {
;;;2053     /* Check the parameters */
;;;2054     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2055   
;;;2056     /* Get the Capture 3 Register value */
;;;2057     return TIMx->CCR3;
;;;2058   }
000002  4770              BX       lr
;;;2059   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2064     */
;;;2065   uint32_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  6c00              LDR      r0,[r0,#0x40]
;;;2066   {
;;;2067     /* Check the parameters */
;;;2068     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2069   
;;;2070     /* Get the Capture 4 Register value */
;;;2071     return TIMx->CCR4;
;;;2072   }
000002  4770              BX       lr
;;;2073   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;431      */
;;;432    uint32_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  6a40              LDR      r0,[r0,#0x24]
;;;433    {
;;;434      /* Check the parameters */
;;;435      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;436    
;;;437      /* Get the Counter Register value */
;;;438      return TIMx->CNT;
;;;439    }
000002  4770              BX       lr
;;;440    
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2432     */
;;;2433   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2434   { 
;;;2435     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2436     /* Check the parameters */
;;;2437     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2438     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2439   
;;;2440     
;;;2441     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000004  8a12              LDRH     r2,[r2,#0x10]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L35.12|
;;;2442     {
;;;2443       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L35.12|
;;;2444     }
;;;2445     else
;;;2446     {
;;;2447       bitstatus = RESET;
;;;2448     }
;;;2449     return bitstatus;
;;;2450   }
00000c  4770              BX       lr
;;;2451   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2502     */
;;;2503   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  4602              MOV      r2,r0
;;;2504   {
;;;2505     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2506     uint16_t itstatus = 0x0, itenable = 0x0;
;;;2507     /* Check the parameters */
;;;2508     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2509     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2510      
;;;2511     itstatus = TIMx->SR & TIM_IT;
000004  8a13              LDRH     r3,[r2,#0x10]
;;;2512     
;;;2513     itenable = TIMx->DIER & TIM_IT;
000006  8992              LDRH     r2,[r2,#0xc]
000008  420b              TST      r3,r1                 ;2511
00000a  ea020201          AND      r2,r2,r1
00000e  d002              BEQ      |L36.22|
;;;2514     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
000010  2a00              CMP      r2,#0
000012  d000              BEQ      |L36.22|
;;;2515     {
;;;2516       bitstatus = SET;
000014  2001              MOVS     r0,#1
                  |L36.22|
;;;2517     }
;;;2518     else
;;;2519     {
;;;2520       bitstatus = RESET;
;;;2521     }
;;;2522     return bitstatus;
;;;2523   }
000016  4770              BX       lr
;;;2524   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;445      */
;;;446    uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  8d00              LDRH     r0,[r0,#0x28]
;;;447    {
;;;448      /* Check the parameters */
;;;449      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;450    
;;;451      /* Get the Prescaler Register value */
;;;452      return TIMx->PSC;
;;;453    }
000002  4770              BX       lr
;;;454    
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=1

                  TIM_ICInit PROC
;;;1889     */
;;;1890   void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1891   {
000004  460c              MOV      r4,r1
;;;1892     /* Check the parameters */
;;;1893     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1894     assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;1895     assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;1896     assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;1897     assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;1898     
;;;1899     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000006  880e              LDRH     r6,[r1,#0]
;;;1900     {
;;;1901       /* TI1 Configuration */
;;;1902       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000008  8849              LDRH     r1,[r1,#2]
00000a  88a2              LDRH     r2,[r4,#4]
00000c  8923              LDRH     r3,[r4,#8]
00000e  4605              MOV      r5,r0                 ;1891
000010  b316              CBZ      r6,|L38.88|
;;;1903                  TIM_ICInitStruct->TIM_ICSelection,
;;;1904                  TIM_ICInitStruct->TIM_ICFilter);
;;;1905       /* Set the Input Capture Prescaler value */
;;;1906       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1907     }
;;;1908     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000012  2e04              CMP      r6,#4
000014  d028              BEQ      |L38.104|
;;;1909     {
;;;1910       /* TI2 Configuration */
;;;1911       assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1912       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;1913                  TIM_ICInitStruct->TIM_ICSelection,
;;;1914                  TIM_ICInitStruct->TIM_ICFilter);
;;;1915       /* Set the Input Capture Prescaler value */
;;;1916       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1917     }
;;;1918     else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
000016  2e08              CMP      r6,#8
000018  8c2e              LDRH     r6,[r5,#0x20]
00001a  f64f70ff          MOV      r0,#0xffff
00001e  d02b              BEQ      |L38.120|
000020  f4265680          BIC      r6,r6,#0x1000
000024  842e              STRH     r6,[r5,#0x20]
000026  8baf              LDRH     r7,[r5,#0x1c]
000028  8c2e              LDRH     r6,[r5,#0x20]
00002a  ea002202          AND      r2,r0,r2,LSL #8
00002e  ea003101          AND      r1,r0,r1,LSL #12
000032  f4274773          BIC      r7,r7,#0xf300
000036  433a              ORRS     r2,r2,r7
000038  ea003003          AND      r0,r0,r3,LSL #12
00003c  4310              ORRS     r0,r0,r2
00003e  f4264220          BIC      r2,r6,#0xa000
000042  430a              ORRS     r2,r2,r1
000044  f4425180          ORR      r1,r2,#0x1000
000048  83a8              STRH     r0,[r5,#0x1c]
00004a  8429              STRH     r1,[r5,#0x20]
;;;1919     {
;;;1920       /* TI3 Configuration */
;;;1921       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1922       TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
;;;1923                  TIM_ICInitStruct->TIM_ICSelection,
;;;1924                  TIM_ICInitStruct->TIM_ICFilter);
;;;1925       /* Set the Input Capture Prescaler value */
;;;1926       TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1927     }
;;;1928     else
;;;1929     {
;;;1930       /* TI4 Configuration */
;;;1931       assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1932       TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;1933                  TIM_ICInitStruct->TIM_ICSelection,
;;;1934                  TIM_ICInitStruct->TIM_ICFilter);
;;;1935       /* Set the Input Capture Prescaler value */
;;;1936       TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00004c  88e1              LDRH     r1,[r4,#6]
00004e  4628              MOV      r0,r5
000050  e8bd41f0          POP      {r4-r8,lr}
000054  f7ffbffe          B.W      TIM_SetIC4Prescaler
                  |L38.88|
000058  f7fffffe          BL       TI1_Config
00005c  88e1              LDRH     r1,[r4,#6]            ;1906
00005e  4628              MOV      r0,r5                 ;1906
000060  e8bd41f0          POP      {r4-r8,lr}            ;1906
000064  f7ffbffe          B.W      TIM_SetIC1Prescaler
                  |L38.104|
000068  f7fffffe          BL       TI2_Config
00006c  88e1              LDRH     r1,[r4,#6]            ;1916
00006e  4628              MOV      r0,r5                 ;1916
000070  e8bd41f0          POP      {r4-r8,lr}            ;1916
000074  f7ffbffe          B.W      TIM_SetIC2Prescaler
                  |L38.120|
000078  f4267680          BIC      r6,r6,#0x100          ;1916
00007c  842e              STRH     r6,[r5,#0x20]         ;1916
00007e  8baf              LDRH     r7,[r5,#0x1c]         ;1916
000080  8c2e              LDRH     r6,[r5,#0x20]         ;1916
000082  ea002101          AND      r1,r0,r1,LSL #8       ;1916
000086  ea001003          AND      r0,r0,r3,LSL #4       ;1916
00008a  4310              ORRS     r0,r0,r2              ;1916
00008c  f02707f3          BIC      r7,r7,#0xf3           ;1916
000090  4338              ORRS     r0,r0,r7              ;1916
000092  f4266220          BIC      r2,r6,#0xa00          ;1916
000096  430a              ORRS     r2,r2,r1              ;1916
000098  f4427180          ORR      r1,r2,#0x100          ;1916
00009c  83a8              STRH     r0,[r5,#0x1c]         ;1916
00009e  8429              STRH     r1,[r5,#0x20]         ;1916
0000a0  88e1              LDRH     r1,[r4,#6]            ;1926
0000a2  4628              MOV      r0,r5                 ;1926
0000a4  e8bd41f0          POP      {r4-r8,lr}            ;1926
0000a8  f7ffbffe          B.W      TIM_SetIC3Prescaler
;;;1937     }
;;;1938   }
;;;1939   
                          ENDP


                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;1945     */
;;;1946   void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;1947   {
;;;1948     /* Set the default configuration */
;;;1949     TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;1950     TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;1951     TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2201              MOVS     r2,#1
000008  8082              STRH     r2,[r0,#4]
;;;1952     TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;1953     TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000c  8101              STRH     r1,[r0,#8]
;;;1954   }
00000e  4770              BX       lr
;;;1955   
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;2361     */
;;;2362   void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;2363   {  
;;;2364     /* Check the parameters */
;;;2365     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2366     assert_param(IS_TIM_IT(TIM_IT));
;;;2367     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2368     
;;;2369     if (NewState != DISABLE)
;;;2370     {
;;;2371       /* Enable the Interrupt sources */
;;;2372       TIMx->DIER |= TIM_IT;
;;;2373     }
;;;2374     else
;;;2375     {
;;;2376       /* Disable the Interrupt sources */
;;;2377       TIMx->DIER &= (uint16_t)~TIM_IT;
000002  8982              LDRH     r2,[r0,#0xc]
000004  d001              BEQ      |L40.10|
000006  430a              ORRS     r2,r2,r1              ;2372
000008  e000              B        |L40.12|
                  |L40.10|
00000a  438a              BICS     r2,r2,r1
                  |L40.12|
00000c  8182              STRH     r2,[r0,#0xc]          ;2372
;;;2378     }
;;;2379   }
00000e  4770              BX       lr
;;;2380   
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;2693     */
;;;2694   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  b500              PUSH     {lr}
;;;2695   {
000002  4603              MOV      r3,r0
;;;2696     /* Check the parameters */
;;;2697     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2698     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2699   
;;;2700     /* Select the Internal Trigger */
;;;2701     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
000004  f7fffffe          BL       TIM_SelectInputTrigger
;;;2702   
;;;2703     /* Select the External clock mode1 */
;;;2704     TIMx->SMCR |= TIM_SlaveMode_External1;
000008  8918              LDRH     r0,[r3,#8]
00000a  f0400007          ORR      r0,r0,#7
00000e  8118              STRH     r0,[r3,#8]
;;;2705   }
000010  bd00              POP      {pc}
;;;2706   
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;2672     */
;;;2673   void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;2674   {
;;;2675     /* Check the parameters */
;;;2676     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2677   
;;;2678     /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;2679     TIMx->SMCR &=  (uint16_t)~TIM_SMCR_SMS;
000002  f0210107          BIC      r1,r1,#7
000006  8101              STRH     r1,[r0,#8]
;;;2680   }
000008  4770              BX       lr
;;;2681   
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1346     */
;;;1347   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1348   {
;;;1349     uint16_t tmpccmr1 = 0;
;;;1350   
;;;1351     /* Check the parameters */
;;;1352     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1353     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1354   
;;;1355     /* Get the TIMx CCMR1 register value */
;;;1356     tmpccmr1 = TIMx->CCMR1;
;;;1357   
;;;1358     /* Reset the OC1FE Bit */
;;;1359     tmpccmr1 &= (uint16_t)~TIM_CCMR1_OC1FE;
000002  f0220204          BIC      r2,r2,#4
;;;1360   
;;;1361     /* Enable or Disable the Output Compare Fast Bit */
;;;1362     tmpccmr1 |= TIM_OCFast;
000006  430a              ORRS     r2,r2,r1
;;;1363   
;;;1364     /* Write to TIMx CCMR1 */
;;;1365     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1366   }
00000a  4770              BX       lr
;;;1367   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM_OC1Init PROC
;;;664      */
;;;665    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;666    {
;;;667      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;668       
;;;669      /* Check the parameters */
;;;670      assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;671      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;672      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;673      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;674    
;;;675      /* Disable the Channel 1: Reset the CC1E Bit */
;;;676      TIMx->CCER &= (uint16_t)~TIM_CCER_CC1E;
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  8402              STRH     r2,[r0,#0x20]
;;;677      
;;;678      /* Get the TIMx CCER register value */
;;;679      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;680      /* Get the TIMx CR2 register value */
;;;681      tmpcr2 =  TIMx->CR2;
00000c  8883              LDRH     r3,[r0,#4]
;;;682      
;;;683      /* Get the TIMx CCMR1 register value */
;;;684      tmpccmrx = TIMx->CCMR1;
00000e  8b04              LDRH     r4,[r0,#0x18]
;;;685        
;;;686      /* Reset the Output Compare Mode Bits */
;;;687      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC1M;
;;;688      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC1S;
;;;689      /* Select the Output Compare Mode */
;;;690      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
;;;691      
;;;692      /* Reset the Output Polarity level */
;;;693      tmpccer &= (uint16_t)~TIM_CCER_CC1P;
000010  f0220202          BIC      r2,r2,#2
000014  f0240573          BIC      r5,r4,#0x73           ;688
000018  880c              LDRH     r4,[r1,#0]            ;690
00001a  432c              ORRS     r4,r4,r5              ;690
;;;694      /* Set the Output Compare Polarity */
;;;695      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
00001c  898d              LDRH     r5,[r1,#0xc]
00001e  4315              ORRS     r5,r5,r2
;;;696      
;;;697      /* Set the Output State */
;;;698      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
000020  884a              LDRH     r2,[r1,#2]
000022  432a              ORRS     r2,r2,r5
;;;699        
;;;700      if((TIMx == TIM1) || (TIMx == TIM8))
000024  4d0c              LDR      r5,|L44.88|
000026  42a8              CMP      r0,r5
000028  d002              BEQ      |L44.48|
00002a  4d0c              LDR      r5,|L44.92|
00002c  42a8              CMP      r0,r5
00002e  d10d              BNE      |L44.76|
                  |L44.48|
;;;701      {
;;;702        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;703        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;704        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;705        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;706        
;;;707        /* Reset the Output N Polarity level */
;;;708        tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
000030  f0220508          BIC      r5,r2,#8
;;;709        /* Set the Output N Polarity */
;;;710        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000034  89ca              LDRH     r2,[r1,#0xe]
;;;711        /* Reset the Output N State */
;;;712        tmpccer &= (uint16_t)~TIM_CCER_CC1NE;
;;;713        
;;;714        /* Set the Output N State */
;;;715        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
;;;716        /* Reset the Output Compare and Output Compare N IDLE State */
;;;717        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1;
;;;718        tmpcr2 &= (uint16_t)~TIM_CR2_OIS1N;
000036  f4237340          BIC      r3,r3,#0x300
00003a  432a              ORRS     r2,r2,r5              ;710
00003c  f0220504          BIC      r5,r2,#4              ;712
000040  888a              LDRH     r2,[r1,#4]            ;715
000042  432a              ORRS     r2,r2,r5              ;715
;;;719        /* Set the Output Idle state */
;;;720        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
000044  8a0d              LDRH     r5,[r1,#0x10]
000046  431d              ORRS     r5,r5,r3
;;;721        /* Set the Output N Idle state */
;;;722        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
000048  8a4b              LDRH     r3,[r1,#0x12]
00004a  432b              ORRS     r3,r3,r5
                  |L44.76|
;;;723      }
;;;724      /* Write to TIMx CR2 */
;;;725      TIMx->CR2 = tmpcr2;
00004c  8083              STRH     r3,[r0,#4]
;;;726      
;;;727      /* Write to TIMx CCMR1 */
;;;728      TIMx->CCMR1 = tmpccmrx;
00004e  8304              STRH     r4,[r0,#0x18]
;;;729      
;;;730      /* Set the Capture Compare Register value */
;;;731      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse;
000050  6889              LDR      r1,[r1,#8]
000052  6341              STR      r1,[r0,#0x34]
;;;732      
;;;733      /* Write to TIMx CCER */
;;;734      TIMx->CCER = tmpccer;
000054  8402              STRH     r2,[r0,#0x20]
;;;735    }
000056  bd30              POP      {r4,r5,pc}
;;;736    
                          ENDP

                  |L44.88|
                          DCD      0x40010000
                  |L44.92|
                          DCD      0x40010400

                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;1611     */
;;;1612   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1613   {
;;;1614     uint16_t tmpccer = 0;
;;;1615     /* Check the parameters */
;;;1616     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1617     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1618      
;;;1619     tmpccer = TIMx->CCER;
;;;1620   
;;;1621     /* Set or Reset the CC1NP Bit */
;;;1622     tmpccer &= (uint16_t)~TIM_CCER_CC1NP;
000002  f0220208          BIC      r2,r2,#8
;;;1623     tmpccer |= TIM_OCNPolarity;
000006  430a              ORRS     r2,r2,r1
;;;1624   
;;;1625     /* Write to TIMx CCER register */
;;;1626     TIMx->CCER = tmpccer;
000008  8402              STRH     r2,[r0,#0x20]
;;;1627   }
00000a  4770              BX       lr
;;;1628   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;1584     */
;;;1585   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1586   {
;;;1587     uint16_t tmpccer = 0;
;;;1588   
;;;1589     /* Check the parameters */
;;;1590     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1591     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1592   
;;;1593     tmpccer = TIMx->CCER;
;;;1594   
;;;1595     /* Set or Reset the CC1P Bit */
;;;1596     tmpccer &= (uint16_t)(~TIM_CCER_CC1P);
000002  f0220202          BIC      r2,r2,#2
;;;1597     tmpccer |= TIM_OCPolarity;
000006  430a              ORRS     r2,r2,r1
;;;1598   
;;;1599     /* Write to TIMx CCER register */
;;;1600     TIMx->CCER = tmpccer;
000008  8402              STRH     r2,[r0,#0x20]
;;;1601   }
00000a  4770              BX       lr
;;;1602   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1229     */
;;;1230   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1231   {
;;;1232     uint16_t tmpccmr1 = 0;
;;;1233   
;;;1234     /* Check the parameters */
;;;1235     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1236     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1237   
;;;1238     tmpccmr1 = TIMx->CCMR1;
;;;1239   
;;;1240     /* Reset the OC1PE Bit */
;;;1241     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC1PE);
000002  f0220208          BIC      r2,r2,#8
;;;1242   
;;;1243     /* Enable or Disable the Output Compare Preload feature */
;;;1244     tmpccmr1 |= TIM_OCPreload;
000006  430a              ORRS     r2,r2,r1
;;;1245   
;;;1246     /* Write to TIMx CCMR1 register */
;;;1247     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1248   }
00000a  4770              BX       lr
;;;1249   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1377     */
;;;1378   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1379   {
;;;1380     uint16_t tmpccmr1 = 0;
;;;1381   
;;;1382     /* Check the parameters */
;;;1383     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1384     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1385   
;;;1386     /* Get the TIMx CCMR1 register value */
;;;1387     tmpccmr1 = TIMx->CCMR1;
;;;1388   
;;;1389     /* Reset the OC2FE Bit */
;;;1390     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2FE);
;;;1391   
;;;1392     /* Enable or Disable the Output Compare Fast Bit */
;;;1393     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226280          BIC      r2,r2,#0x400          ;1390
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1394   
;;;1395     /* Write to TIMx CCMR1 */
;;;1396     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1397   }
000012  4770              BX       lr
;;;1398   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM_OC2Init PROC
;;;745      */
;;;746    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;747    {
;;;748      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;749       
;;;750      /* Check the parameters */
;;;751      assert_param(IS_TIM_LIST2_PERIPH(TIMx)); 
;;;752      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;753      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;754      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;755    
;;;756      /* Disable the Channel 2: Reset the CC2E Bit */
;;;757      TIMx->CCER &= (uint16_t)~TIM_CCER_CC2E;
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f0220210          BIC      r2,r2,#0x10
000008  8402              STRH     r2,[r0,#0x20]
;;;758      
;;;759      /* Get the TIMx CCER register value */  
;;;760      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;761      /* Get the TIMx CR2 register value */
;;;762      tmpcr2 =  TIMx->CR2;
00000c  8883              LDRH     r3,[r0,#4]
;;;763      
;;;764      /* Get the TIMx CCMR1 register value */
;;;765      tmpccmrx = TIMx->CCMR1;
00000e  8b04              LDRH     r4,[r0,#0x18]
;;;766        
;;;767      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;768      tmpccmrx &= (uint16_t)~TIM_CCMR1_OC2M;
;;;769      tmpccmrx &= (uint16_t)~TIM_CCMR1_CC2S;
;;;770      
;;;771      /* Select the Output Compare Mode */
;;;772      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000010  880d              LDRH     r5,[r1,#0]
000012  f42446e6          BIC      r6,r4,#0x7300         ;769
000016  f64f74ff          MOV      r4,#0xffff
00001a  ea042505          AND      r5,r4,r5,LSL #8
00001e  4335              ORRS     r5,r5,r6
;;;773      
;;;774      /* Reset the Output Polarity level */
;;;775      tmpccer &= (uint16_t)~TIM_CCER_CC2P;
;;;776      /* Set the Output Compare Polarity */
;;;777      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000020  898e              LDRH     r6,[r1,#0xc]
000022  f0220220          BIC      r2,r2,#0x20           ;775
000026  ea041606          AND      r6,r4,r6,LSL #4
00002a  4316              ORRS     r6,r6,r2
;;;778      
;;;779      /* Set the Output State */
;;;780      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
00002c  884a              LDRH     r2,[r1,#2]
00002e  ea041202          AND      r2,r4,r2,LSL #4
000032  4332              ORRS     r2,r2,r6
;;;781        
;;;782      if((TIMx == TIM1) || (TIMx == TIM8))
000034  4e10              LDR      r6,|L49.120|
000036  42b0              CMP      r0,r6
000038  d002              BEQ      |L49.64|
00003a  4e10              LDR      r6,|L49.124|
00003c  42b0              CMP      r0,r6
00003e  d115              BNE      |L49.108|
                  |L49.64|
;;;783      {
;;;784        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;785        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;786        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;787        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;788        
;;;789        /* Reset the Output N Polarity level */
;;;790        tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
000040  f0220680          BIC      r6,r2,#0x80
;;;791        /* Set the Output N Polarity */
;;;792        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
000044  89ca              LDRH     r2,[r1,#0xe]
;;;793        /* Reset the Output N State */
;;;794        tmpccer &= (uint16_t)~TIM_CCER_CC2NE;
;;;795        
;;;796        /* Set the Output N State */
;;;797        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
;;;798        /* Reset the Output Compare and Output Compare N IDLE State */
;;;799        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2;
;;;800        tmpcr2 &= (uint16_t)~TIM_CR2_OIS2N;
000046  f4236340          BIC      r3,r3,#0xc00
00004a  ea041202          AND      r2,r4,r2,LSL #4       ;792
00004e  4332              ORRS     r2,r2,r6              ;792
000050  f0220640          BIC      r6,r2,#0x40           ;794
000054  888a              LDRH     r2,[r1,#4]            ;797
000056  ea041202          AND      r2,r4,r2,LSL #4       ;797
00005a  4332              ORRS     r2,r2,r6              ;797
;;;801        /* Set the Output Idle state */
;;;802        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
00005c  8a0e              LDRH     r6,[r1,#0x10]
00005e  ea040686          AND      r6,r4,r6,LSL #2
000062  431e              ORRS     r6,r6,r3
;;;803        /* Set the Output N Idle state */
;;;804        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
000064  8a4b              LDRH     r3,[r1,#0x12]
000066  ea040383          AND      r3,r4,r3,LSL #2
00006a  4333              ORRS     r3,r3,r6
                  |L49.108|
;;;805      }
;;;806      /* Write to TIMx CR2 */
;;;807      TIMx->CR2 = tmpcr2;
00006c  8083              STRH     r3,[r0,#4]
;;;808      
;;;809      /* Write to TIMx CCMR1 */
;;;810      TIMx->CCMR1 = tmpccmrx;
00006e  8305              STRH     r5,[r0,#0x18]
;;;811      
;;;812      /* Set the Capture Compare Register value */
;;;813      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
000070  6889              LDR      r1,[r1,#8]
000072  6381              STR      r1,[r0,#0x38]
;;;814      
;;;815      /* Write to TIMx CCER */
;;;816      TIMx->CCER = tmpccer;
000074  8402              STRH     r2,[r0,#0x20]
;;;817    }
000076  bd70              POP      {r4-r6,pc}
;;;818    
                          ENDP

                  |L49.120|
                          DCD      0x40010000
                  |L49.124|
                          DCD      0x40010400

                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;1665     */
;;;1666   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1667   {
;;;1668     uint16_t tmpccer = 0;
;;;1669   
;;;1670     /* Check the parameters */
;;;1671     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1672     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1673     
;;;1674     tmpccer = TIMx->CCER;
;;;1675   
;;;1676     /* Set or Reset the CC2NP Bit */
;;;1677     tmpccer &= (uint16_t)~TIM_CCER_CC2NP;
;;;1678     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
000002  f64f73ff          MOV      r3,#0xffff
000006  f0220280          BIC      r2,r2,#0x80           ;1677
00000a  ea031101          AND      r1,r3,r1,LSL #4
00000e  4311              ORRS     r1,r1,r2
;;;1679   
;;;1680     /* Write to TIMx CCER register */
;;;1681     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1682   }
000012  4770              BX       lr
;;;1683   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;1638     */
;;;1639   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1640   {
;;;1641     uint16_t tmpccer = 0;
;;;1642   
;;;1643     /* Check the parameters */
;;;1644     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1645     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1646   
;;;1647     tmpccer = TIMx->CCER;
;;;1648   
;;;1649     /* Set or Reset the CC2P Bit */
;;;1650     tmpccer &= (uint16_t)(~TIM_CCER_CC2P);
;;;1651     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
000002  f64f73ff          MOV      r3,#0xffff
000006  f0220220          BIC      r2,r2,#0x20           ;1650
00000a  ea031101          AND      r1,r3,r1,LSL #4
00000e  4311              ORRS     r1,r1,r2
;;;1652   
;;;1653     /* Write to TIMx CCER register */
;;;1654     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1655   }
000012  4770              BX       lr
;;;1656   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1259     */
;;;1260   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1261   {
;;;1262     uint16_t tmpccmr1 = 0;
;;;1263   
;;;1264     /* Check the parameters */
;;;1265     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1266     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1267   
;;;1268     tmpccmr1 = TIMx->CCMR1;
;;;1269   
;;;1270     /* Reset the OC2PE Bit */
;;;1271     tmpccmr1 &= (uint16_t)(~TIM_CCMR1_OC2PE);
;;;1272   
;;;1273     /* Enable or Disable the Output Compare Preload feature */
;;;1274     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226200          BIC      r2,r2,#0x800          ;1271
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1275   
;;;1276     /* Write to TIMx CCMR1 register */
;;;1277     TIMx->CCMR1 = tmpccmr1;
000010  8301              STRH     r1,[r0,#0x18]
;;;1278   }
000012  4770              BX       lr
;;;1279   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1407     */
;;;1408   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1409   {
;;;1410     uint16_t tmpccmr2 = 0;
;;;1411     
;;;1412     /* Check the parameters */
;;;1413     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1414     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1415   
;;;1416     /* Get the TIMx CCMR2 register value */
;;;1417     tmpccmr2 = TIMx->CCMR2;
;;;1418   
;;;1419     /* Reset the OC3FE Bit */
;;;1420     tmpccmr2 &= (uint16_t)~TIM_CCMR2_OC3FE;
000002  f0220204          BIC      r2,r2,#4
;;;1421   
;;;1422     /* Enable or Disable the Output Compare Fast Bit */
;;;1423     tmpccmr2 |= TIM_OCFast;
000006  430a              ORRS     r2,r2,r1
;;;1424   
;;;1425     /* Write to TIMx CCMR2 */
;;;1426     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1427   }
00000a  4770              BX       lr
;;;1428   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM_OC3Init PROC
;;;826      */
;;;827    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;828    {
;;;829      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;830       
;;;831      /* Check the parameters */
;;;832      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;833      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;834      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;835      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;836    
;;;837      /* Disable the Channel 3: Reset the CC2E Bit */
;;;838      TIMx->CCER &= (uint16_t)~TIM_CCER_CC3E;
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f4227280          BIC      r2,r2,#0x100
000008  8402              STRH     r2,[r0,#0x20]
;;;839      
;;;840      /* Get the TIMx CCER register value */
;;;841      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;842      /* Get the TIMx CR2 register value */
;;;843      tmpcr2 =  TIMx->CR2;
00000c  8883              LDRH     r3,[r0,#4]
;;;844      
;;;845      /* Get the TIMx CCMR2 register value */
;;;846      tmpccmrx = TIMx->CCMR2;
00000e  8b84              LDRH     r4,[r0,#0x1c]
;;;847        
;;;848      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;849      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC3M;
;;;850      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC3S;  
;;;851      /* Select the Output Compare Mode */
;;;852      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
000010  880d              LDRH     r5,[r1,#0]
000012  f0240473          BIC      r4,r4,#0x73           ;850
000016  4325              ORRS     r5,r5,r4
;;;853      
;;;854      /* Reset the Output Polarity level */
;;;855      tmpccer &= (uint16_t)~TIM_CCER_CC3P;
;;;856      /* Set the Output Compare Polarity */
;;;857      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
000018  898e              LDRH     r6,[r1,#0xc]
00001a  f64f74ff          MOV      r4,#0xffff
00001e  f4227200          BIC      r2,r2,#0x200          ;855
000022  ea042606          AND      r6,r4,r6,LSL #8
000026  4316              ORRS     r6,r6,r2
;;;858      
;;;859      /* Set the Output State */
;;;860      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
000028  884a              LDRH     r2,[r1,#2]
00002a  ea042202          AND      r2,r4,r2,LSL #8
00002e  4332              ORRS     r2,r2,r6
;;;861        
;;;862      if((TIMx == TIM1) || (TIMx == TIM8))
000030  4e10              LDR      r6,|L54.116|
000032  42b0              CMP      r0,r6
000034  d002              BEQ      |L54.60|
000036  4e10              LDR      r6,|L54.120|
000038  42b0              CMP      r0,r6
00003a  d115              BNE      |L54.104|
                  |L54.60|
;;;863      {
;;;864        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;865        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;866        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;867        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;868        
;;;869        /* Reset the Output N Polarity level */
;;;870        tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
00003c  f4226600          BIC      r6,r2,#0x800
;;;871        /* Set the Output N Polarity */
;;;872        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
000040  89ca              LDRH     r2,[r1,#0xe]
;;;873        /* Reset the Output N State */
;;;874        tmpccer &= (uint16_t)~TIM_CCER_CC3NE;
;;;875        
;;;876        /* Set the Output N State */
;;;877        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
;;;878        /* Reset the Output Compare and Output Compare N IDLE State */
;;;879        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3;
;;;880        tmpcr2 &= (uint16_t)~TIM_CR2_OIS3N;
000042  f4235340          BIC      r3,r3,#0x3000
000046  ea042202          AND      r2,r4,r2,LSL #8       ;872
00004a  4332              ORRS     r2,r2,r6              ;872
00004c  f4226680          BIC      r6,r2,#0x400          ;874
000050  888a              LDRH     r2,[r1,#4]            ;877
000052  ea042202          AND      r2,r4,r2,LSL #8       ;877
000056  4332              ORRS     r2,r2,r6              ;877
;;;881        /* Set the Output Idle state */
;;;882        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000058  8a0e              LDRH     r6,[r1,#0x10]
00005a  ea041606          AND      r6,r4,r6,LSL #4
00005e  431e              ORRS     r6,r6,r3
;;;883        /* Set the Output N Idle state */
;;;884        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
000060  8a4b              LDRH     r3,[r1,#0x12]
000062  ea041303          AND      r3,r4,r3,LSL #4
000066  4333              ORRS     r3,r3,r6
                  |L54.104|
;;;885      }
;;;886      /* Write to TIMx CR2 */
;;;887      TIMx->CR2 = tmpcr2;
000068  8083              STRH     r3,[r0,#4]
;;;888      
;;;889      /* Write to TIMx CCMR2 */
;;;890      TIMx->CCMR2 = tmpccmrx;
00006a  8385              STRH     r5,[r0,#0x1c]
;;;891      
;;;892      /* Set the Capture Compare Register value */
;;;893      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
00006c  6889              LDR      r1,[r1,#8]
00006e  63c1              STR      r1,[r0,#0x3c]
;;;894      
;;;895      /* Write to TIMx CCER */
;;;896      TIMx->CCER = tmpccer;
000070  8402              STRH     r2,[r0,#0x20]
;;;897    }
000072  bd70              POP      {r4-r6,pc}
;;;898    
                          ENDP

                  |L54.116|
                          DCD      0x40010000
                  |L54.120|
                          DCD      0x40010400

                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;1719     */
;;;1720   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1721   {
;;;1722     uint16_t tmpccer = 0;
;;;1723    
;;;1724     /* Check the parameters */
;;;1725     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1726     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1727       
;;;1728     tmpccer = TIMx->CCER;
;;;1729   
;;;1730     /* Set or Reset the CC3NP Bit */
;;;1731     tmpccer &= (uint16_t)~TIM_CCER_CC3NP;
;;;1732     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226200          BIC      r2,r2,#0x800          ;1731
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1733   
;;;1734     /* Write to TIMx CCER register */
;;;1735     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1736   }
000012  4770              BX       lr
;;;1737   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;1692     */
;;;1693   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1694   {
;;;1695     uint16_t tmpccer = 0;
;;;1696   
;;;1697     /* Check the parameters */
;;;1698     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1699     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1700   
;;;1701     tmpccer = TIMx->CCER;
;;;1702   
;;;1703     /* Set or Reset the CC3P Bit */
;;;1704     tmpccer &= (uint16_t)~TIM_CCER_CC3P;
;;;1705     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4227200          BIC      r2,r2,#0x200          ;1704
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1706   
;;;1707     /* Write to TIMx CCER register */
;;;1708     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1709   }
000012  4770              BX       lr
;;;1710   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1288     */
;;;1289   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1290   {
;;;1291     uint16_t tmpccmr2 = 0;
;;;1292   
;;;1293     /* Check the parameters */
;;;1294     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1295     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1296   
;;;1297     tmpccmr2 = TIMx->CCMR2;
;;;1298   
;;;1299     /* Reset the OC3PE Bit */
;;;1300     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC3PE);
000002  f0220208          BIC      r2,r2,#8
;;;1301   
;;;1302     /* Enable or Disable the Output Compare Preload feature */
;;;1303     tmpccmr2 |= TIM_OCPreload;
000006  430a              ORRS     r2,r2,r1
;;;1304   
;;;1305     /* Write to TIMx CCMR2 register */
;;;1306     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1307   }
00000a  4770              BX       lr
;;;1308   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1437     */
;;;1438   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1439   {
;;;1440     uint16_t tmpccmr2 = 0;
;;;1441   
;;;1442     /* Check the parameters */
;;;1443     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1444     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1445   
;;;1446     /* Get the TIMx CCMR2 register value */
;;;1447     tmpccmr2 = TIMx->CCMR2;
;;;1448   
;;;1449     /* Reset the OC4FE Bit */
;;;1450     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4FE);
;;;1451   
;;;1452     /* Enable or Disable the Output Compare Fast Bit */
;;;1453     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226280          BIC      r2,r2,#0x400          ;1450
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1454   
;;;1455     /* Write to TIMx CCMR2 */
;;;1456     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1457   }
000012  4770              BX       lr
;;;1458   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM_OC4Init PROC
;;;906      */
;;;907    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b570              PUSH     {r4-r6,lr}
;;;908    {
;;;909      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;910       
;;;911      /* Check the parameters */
;;;912      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;913      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;914      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;915      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;916    
;;;917      /* Disable the Channel 4: Reset the CC4E Bit */
;;;918      TIMx->CCER &= (uint16_t)~TIM_CCER_CC4E;
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f4225280          BIC      r2,r2,#0x1000
000008  8402              STRH     r2,[r0,#0x20]
;;;919      
;;;920      /* Get the TIMx CCER register value */
;;;921      tmpccer = TIMx->CCER;
00000a  8c05              LDRH     r5,[r0,#0x20]
;;;922      /* Get the TIMx CR2 register value */
;;;923      tmpcr2 =  TIMx->CR2;
00000c  8882              LDRH     r2,[r0,#4]
;;;924      
;;;925      /* Get the TIMx CCMR2 register value */
;;;926      tmpccmrx = TIMx->CCMR2;
00000e  8b83              LDRH     r3,[r0,#0x1c]
;;;927        
;;;928      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;929      tmpccmrx &= (uint16_t)~TIM_CCMR2_OC4M;
;;;930      tmpccmrx &= (uint16_t)~TIM_CCMR2_CC4S;
;;;931      
;;;932      /* Select the Output Compare Mode */
;;;933      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000010  880c              LDRH     r4,[r1,#0]
000012  f42346e6          BIC      r6,r3,#0x7300         ;930
000016  f64f73ff          MOV      r3,#0xffff
00001a  ea032404          AND      r4,r3,r4,LSL #8
00001e  4334              ORRS     r4,r4,r6
;;;934      
;;;935      /* Reset the Output Polarity level */
;;;936      tmpccer &= (uint16_t)~TIM_CCER_CC4P;
000020  f4255600          BIC      r6,r5,#0x2000
;;;937      /* Set the Output Compare Polarity */
;;;938      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000024  898d              LDRH     r5,[r1,#0xc]
000026  ea033505          AND      r5,r3,r5,LSL #12
00002a  4335              ORRS     r5,r5,r6
;;;939      
;;;940      /* Set the Output State */
;;;941      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
00002c  884e              LDRH     r6,[r1,#2]
00002e  ea033606          AND      r6,r3,r6,LSL #12
000032  432e              ORRS     r6,r6,r5
;;;942      
;;;943      if((TIMx == TIM1) || (TIMx == TIM8))
000034  4d08              LDR      r5,|L59.88|
000036  42a8              CMP      r0,r5
000038  d002              BEQ      |L59.64|
00003a  4d08              LDR      r5,|L59.92|
00003c  42a8              CMP      r0,r5
00003e  d105              BNE      |L59.76|
                  |L59.64|
;;;944      {
;;;945        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;946        /* Reset the Output Compare IDLE State */
;;;947        tmpcr2 &=(uint16_t) ~TIM_CR2_OIS4;
000040  f4224580          BIC      r5,r2,#0x4000
;;;948        /* Set the Output Idle state */
;;;949        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000044  8a0a              LDRH     r2,[r1,#0x10]
000046  ea031282          AND      r2,r3,r2,LSL #6
00004a  432a              ORRS     r2,r2,r5
                  |L59.76|
;;;950      }
;;;951      /* Write to TIMx CR2 */
;;;952      TIMx->CR2 = tmpcr2;
00004c  8082              STRH     r2,[r0,#4]
;;;953      
;;;954      /* Write to TIMx CCMR2 */  
;;;955      TIMx->CCMR2 = tmpccmrx;
00004e  8384              STRH     r4,[r0,#0x1c]
;;;956        
;;;957      /* Set the Capture Compare Register value */
;;;958      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
000050  6889              LDR      r1,[r1,#8]
000052  6401              STR      r1,[r0,#0x40]
;;;959      
;;;960      /* Write to TIMx CCER */
;;;961      TIMx->CCER = tmpccer;
000054  8406              STRH     r6,[r0,#0x20]
;;;962    }
000056  bd70              POP      {r4-r6,pc}
;;;963    
                          ENDP

                  |L59.88|
                          DCD      0x40010000
                  |L59.92|
                          DCD      0x40010400

                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;1746     */
;;;1747   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1748   {
;;;1749     uint16_t tmpccer = 0;
;;;1750   
;;;1751     /* Check the parameters */
;;;1752     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1753     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1754   
;;;1755     tmpccer = TIMx->CCER;
;;;1756   
;;;1757     /* Set or Reset the CC4P Bit */
;;;1758     tmpccer &= (uint16_t)~TIM_CCER_CC4P;
;;;1759     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4225200          BIC      r2,r2,#0x2000         ;1758
00000a  ea033101          AND      r1,r3,r1,LSL #12
00000e  4311              ORRS     r1,r1,r2
;;;1760   
;;;1761     /* Write to TIMx CCER register */
;;;1762     TIMx->CCER = tmpccer;
000010  8401              STRH     r1,[r0,#0x20]
;;;1763   }
000012  4770              BX       lr
;;;1764   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1317     */
;;;1318   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1319   {
;;;1320     uint16_t tmpccmr2 = 0;
;;;1321   
;;;1322     /* Check the parameters */
;;;1323     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1324     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1325   
;;;1326     tmpccmr2 = TIMx->CCMR2;
;;;1327   
;;;1328     /* Reset the OC4PE Bit */
;;;1329     tmpccmr2 &= (uint16_t)(~TIM_CCMR2_OC4PE);
;;;1330   
;;;1331     /* Enable or Disable the Output Compare Preload feature */
;;;1332     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
000002  f64f73ff          MOV      r3,#0xffff
000006  f4226200          BIC      r2,r2,#0x800          ;1329
00000a  ea032101          AND      r1,r3,r1,LSL #8
00000e  4311              ORRS     r1,r1,r2
;;;1333   
;;;1334     /* Write to TIMx CCMR2 register */
;;;1335     TIMx->CCMR2 = tmpccmr2;
000010  8381              STRH     r1,[r0,#0x1c]
;;;1336   }
000012  4770              BX       lr
;;;1337   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;969      */
;;;970    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;971    {
;;;972      /* Set the default configuration */
;;;973      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;974      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;975      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;976      TIM_OCInitStruct->TIM_Pulse = 0x00000000;
;;;977      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
000008  6081              STR      r1,[r0,#8]
00000a  8181              STRH     r1,[r0,#0xc]
;;;978      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  81c1              STRH     r1,[r0,#0xe]
;;;979      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8201              STRH     r1,[r0,#0x10]
;;;980      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  8241              STRH     r1,[r0,#0x12]
;;;981    }
000012  4770              BX       lr
;;;982    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;1964     */
;;;1965   void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1966   {
000004  460c              MOV      r4,r1
;;;1967     uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000006  2600              MOVS     r6,#0
;;;1968     uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
;;;1969   
;;;1970     /* Check the parameters */
;;;1971     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1972   
;;;1973     /* Select the Opposite Input Polarity */
;;;1974     if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
000008  8849              LDRH     r1,[r1,#2]
00000a  4607              MOV      r7,r0                 ;1966
00000c  2501              MOVS     r5,#1                 ;1968
00000e  b901              CBNZ     r1,|L63.18|
;;;1975     {
;;;1976       icoppositepolarity = TIM_ICPolarity_Falling;
000010  2602              MOVS     r6,#2
                  |L63.18|
;;;1977     }
;;;1978     else
;;;1979     {
;;;1980       icoppositepolarity = TIM_ICPolarity_Rising;
;;;1981     }
;;;1982     /* Select the Opposite Input */
;;;1983     if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000012  88a2              LDRH     r2,[r4,#4]
000014  2a01              CMP      r2,#1
000016  d100              BNE      |L63.26|
;;;1984     {
;;;1985       icoppositeselection = TIM_ICSelection_IndirectTI;
000018  2502              MOVS     r5,#2
                  |L63.26|
;;;1986     }
;;;1987     else
;;;1988     {
;;;1989       icoppositeselection = TIM_ICSelection_DirectTI;
;;;1990     }
;;;1991     if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
00001a  8820              LDRH     r0,[r4,#0]
;;;1992     {
;;;1993       /* TI1 Configuration */
;;;1994       TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
00001c  8923              LDRH     r3,[r4,#8]
00001e  2800              CMP      r0,#0                 ;1991
;;;1995                  TIM_ICInitStruct->TIM_ICFilter);
;;;1996       /* Set the Input Capture Prescaler value */
;;;1997       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;1998       /* TI2 Configuration */
;;;1999       TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
;;;2000       /* Set the Input Capture Prescaler value */
;;;2001       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;2002     }
;;;2003     else
;;;2004     { 
;;;2005       /* TI2 Configuration */
;;;2006       TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000020  4638              MOV      r0,r7
000022  d011              BEQ      |L63.72|
000024  f7fffffe          BL       TI2_Config
;;;2007                  TIM_ICInitStruct->TIM_ICFilter);
;;;2008       /* Set the Input Capture Prescaler value */
;;;2009       TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000028  88e1              LDRH     r1,[r4,#6]
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       TIM_SetIC2Prescaler
;;;2010       /* TI1 Configuration */
;;;2011       TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000030  8923              LDRH     r3,[r4,#8]
000032  462a              MOV      r2,r5
000034  4631              MOV      r1,r6
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       TI1_Config
;;;2012       /* Set the Input Capture Prescaler value */
;;;2013       TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00003c  88e1              LDRH     r1,[r4,#6]
00003e  4638              MOV      r0,r7
000040  e8bd41f0          POP      {r4-r8,lr}
000044  f7ffbffe          B.W      TIM_SetIC1Prescaler
                  |L63.72|
000048  f7fffffe          BL       TI1_Config
00004c  88e1              LDRH     r1,[r4,#6]            ;1997
00004e  4638              MOV      r0,r7                 ;1997
000050  f7fffffe          BL       TIM_SetIC1Prescaler
000054  8923              LDRH     r3,[r4,#8]            ;1999
000056  462a              MOV      r2,r5                 ;1999
000058  4631              MOV      r1,r6                 ;1999
00005a  4638              MOV      r0,r7                 ;1999
00005c  f7fffffe          BL       TI2_Config
000060  88e1              LDRH     r1,[r4,#6]            ;2001
000062  4638              MOV      r0,r7                 ;2001
000064  e8bd41f0          POP      {r4-r8,lr}            ;2001
000068  f7ffbffe          B.W      TIM_SetIC2Prescaler
;;;2014     }
;;;2015   }
;;;2016   
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;353      */
;;;354    void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;355    {
;;;356      /* Check the parameters */
;;;357      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;358      assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;359      /* Set the Prescaler value */
;;;360      TIMx->PSC = Prescaler;
;;;361      /* Set or reset the UG Bit */
;;;362      TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;363    }
000004  4770              BX       lr
;;;364    
                          ENDP


                          AREA ||i.TIM_RemapConfig||, CODE, READONLY, ALIGN=1

                  TIM_RemapConfig PROC
;;;3159     */
;;;3160   void TIM_RemapConfig(TIM_TypeDef* TIMx, uint16_t TIM_Remap)
000000  f8a01050          STRH     r1,[r0,#0x50]
;;;3161   {
;;;3162    /* Check the parameters */
;;;3163     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;3164     assert_param(IS_TIM_REMAP(TIM_Remap));
;;;3165   
;;;3166     /* Set the Timer remapping configuration */
;;;3167     TIMx->OR =  TIM_Remap;
;;;3168   }
000004  4770              BX       lr
;;;3169   /**
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;2633     */
;;;2634   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2635   {
;;;2636     /* Check the parameters */
;;;2637     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2638     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2639   
;;;2640     if (NewState != DISABLE)
;;;2641     {
;;;2642       /* Set the CCDS Bit */
;;;2643       TIMx->CR2 |= TIM_CR2_CCDS;
;;;2644     }
;;;2645     else
;;;2646     {
;;;2647       /* Reset the CCDS Bit */
;;;2648       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCDS;
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L66.12|
000006  f0410108          ORR      r1,r1,#8              ;2643
00000a  e001              B        |L66.16|
                  |L66.12|
00000c  f0210108          BIC      r1,r1,#8
                  |L66.16|
000010  8081              STRH     r1,[r0,#4]            ;2643
;;;2649     }
;;;2650   }
000012  4770              BX       lr
;;;2651   /**
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;2279     */
;;;2280   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2281   {
;;;2282     /* Check the parameters */
;;;2283     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;2284     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2285   
;;;2286     if (NewState != DISABLE)
;;;2287     {
;;;2288       /* Set the COM Bit */
;;;2289       TIMx->CR2 |= TIM_CR2_CCUS;
;;;2290     }
;;;2291     else
;;;2292     {
;;;2293       /* Reset the COM Bit */
;;;2294       TIMx->CR2 &= (uint16_t)~TIM_CR2_CCUS;
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L67.12|
000006  f0410104          ORR      r1,r1,#4              ;2289
00000a  e001              B        |L67.16|
                  |L67.12|
00000c  f0210104          BIC      r1,r1,#4
                  |L67.16|
000010  8081              STRH     r1,[r0,#4]            ;2289
;;;2295     }
;;;2296   }
000012  4770              BX       lr
;;;2297   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;3108     */
;;;3109   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;3110   {
;;;3111     /* Check the parameters */
;;;3112     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;3113     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;3114   
;;;3115     if (NewState != DISABLE)
;;;3116     {
;;;3117       /* Set the TI1S Bit */
;;;3118       TIMx->CR2 |= TIM_CR2_TI1S;
;;;3119     }
;;;3120     else
;;;3121     {
;;;3122       /* Reset the TI1S Bit */
;;;3123       TIMx->CR2 &= (uint16_t)~TIM_CR2_TI1S;
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L68.12|
000006  f0410180          ORR      r1,r1,#0x80           ;3118
00000a  e001              B        |L68.16|
                  |L68.12|
00000c  f0210180          BIC      r1,r1,#0x80
                  |L68.16|
000010  8081              STRH     r1,[r0,#4]            ;3118
;;;3124     }
;;;3125   }
000012  4770              BX       lr
;;;3126   /**
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;2878     */
;;;2879   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  8902              LDRH     r2,[r0,#8]
;;;2880   {
;;;2881     uint16_t tmpsmcr = 0;
;;;2882   
;;;2883     /* Check the parameters */
;;;2884     assert_param(IS_TIM_LIST1_PERIPH(TIMx)); 
;;;2885     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;2886   
;;;2887     /* Get the TIMx SMCR register value */
;;;2888     tmpsmcr = TIMx->SMCR;
;;;2889   
;;;2890     /* Reset the TS Bits */
;;;2891     tmpsmcr &= (uint16_t)~TIM_SMCR_TS;
000002  f0220270          BIC      r2,r2,#0x70
;;;2892   
;;;2893     /* Set the Input Trigger source */
;;;2894     tmpsmcr |= TIM_InputTriggerSource;
000006  430a              ORRS     r2,r2,r1
;;;2895   
;;;2896     /* Write to TIMx SMCR */
;;;2897     TIMx->SMCR = tmpsmcr;
000008  8102              STRH     r2,[r0,#8]
;;;2898   }
00000a  4770              BX       lr
;;;2899   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2968     */
;;;2969   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2970   {
;;;2971     /* Check the parameters */
;;;2972     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2973     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2974   
;;;2975     /* Reset the MSM Bit */
;;;2976     TIMx->SMCR &= (uint16_t)~TIM_SMCR_MSM;
000002  f0220280          BIC      r2,r2,#0x80
000006  8102              STRH     r2,[r0,#8]
;;;2977     
;;;2978     /* Set or Reset the MSM Bit */
;;;2979     TIMx->SMCR |= TIM_MasterSlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  8102              STRH     r2,[r0,#8]
;;;2980   }
00000e  4770              BX       lr
;;;2981   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;1005     */
;;;1006   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000000  b530              PUSH     {r4,r5,lr}
;;;1007   {
;;;1008     uint32_t tmp = 0;
;;;1009     uint16_t tmp1 = 0;
;;;1010   
;;;1011     /* Check the parameters */
;;;1012     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1013     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1014     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;1015   
;;;1016     tmp = (uint32_t) TIMx;
;;;1017     tmp += CCMR_OFFSET;
;;;1018   
;;;1019     tmp1 = CCER_CCE_SET << (uint16_t)TIM_Channel;
000002  2401              MOVS     r4,#1
;;;1020   
;;;1021     /* Disable the Channel: Reset the CCxE Bit */
;;;1022     TIMx->CCER &= (uint16_t) ~tmp1;
000004  8c05              LDRH     r5,[r0,#0x20]
000006  f1000318          ADD      r3,r0,#0x18           ;1017
00000a  408c              LSLS     r4,r4,r1              ;1019
00000c  43a5              BICS     r5,r5,r4
00000e  8405              STRH     r5,[r0,#0x20]
000010  b191              CBZ      r1,|L71.56|
;;;1023   
;;;1024     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000012  2908              CMP      r1,#8
000014  d010              BEQ      |L71.56|
;;;1025     {
;;;1026       tmp += (TIM_Channel>>1);
;;;1027   
;;;1028       /* Reset the OCxM bits in the CCMRx register */
;;;1029       *(__IO uint32_t *) tmp &= CCMR_OC13M_MASK;
;;;1030      
;;;1031       /* Configure the OCxM bits in the CCMRx register */
;;;1032       *(__IO uint32_t *) tmp |= TIM_OCMode;
;;;1033     }
;;;1034     else
;;;1035     {
;;;1036       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000016  1f09              SUBS     r1,r1,#4
000018  f3c1004e          UBFX     r0,r1,#1,#15
00001c  4418              ADD      r0,r0,r3
;;;1037   
;;;1038       /* Reset the OCxM bits in the CCMRx register */
;;;1039       *(__IO uint32_t *) tmp &= CCMR_OC24M_MASK;
00001e  6801              LDR      r1,[r0,#0]
000020  f64873ff          MOV      r3,#0x8fff
000024  4019              ANDS     r1,r1,r3
000026  6001              STR      r1,[r0,#0]
;;;1040       
;;;1041       /* Configure the OCxM bits in the CCMRx register */
;;;1042       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000028  6801              LDR      r1,[r0,#0]
00002a  f64f73ff          MOV      r3,#0xffff
00002e  ea032202          AND      r2,r3,r2,LSL #8
                  |L71.50|
000032  4311              ORRS     r1,r1,r2              ;1032
000034  6001              STR      r1,[r0,#0]            ;1032
;;;1043     }
;;;1044   }
000036  bd30              POP      {r4,r5,pc}
                  |L71.56|
000038  eb030051          ADD      r0,r3,r1,LSR #1       ;1026
00003c  6801              LDR      r1,[r0,#0]            ;1029
00003e  f64f738f          MOV      r3,#0xff8f            ;1029
000042  4019              ANDS     r1,r1,r3              ;1029
000044  6001              STR      r1,[r0,#0]            ;1029
000046  6801              LDR      r1,[r0,#0]            ;1032
000048  e7f3              B        |L71.50|
;;;1045   
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;542      */
;;;543    void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;544    {
;;;545      /* Check the parameters */
;;;546      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;547      assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;548    
;;;549      /* Reset the OPM Bit */
;;;550      TIMx->CR1 &= (uint16_t)~TIM_CR1_OPM;
000002  f0220208          BIC      r2,r2,#8
000006  8002              STRH     r2,[r0,#0]
;;;551    
;;;552      /* Configure the OPM Mode */
;;;553      TIMx->CR1 |= TIM_OPMode;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;554    }
00000e  4770              BX       lr
;;;555    
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2921     */
;;;2922   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2923   {
;;;2924     /* Check the parameters */
;;;2925     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;2926     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2927   
;;;2928     /* Reset the MMS Bits */
;;;2929     TIMx->CR2 &= (uint16_t)~TIM_CR2_MMS;
000002  f0220270          BIC      r2,r2,#0x70
000006  8082              STRH     r2,[r0,#4]
;;;2930     /* Select the TRGO source */
;;;2931     TIMx->CR2 |=  TIM_TRGOSource;
000008  8882              LDRH     r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  8082              STRH     r2,[r0,#4]
;;;2932   }
00000e  4770              BX       lr
;;;2933   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2945     */
;;;2946   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2947   {
;;;2948     /* Check the parameters */
;;;2949     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2950     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2951   
;;;2952     /* Reset the SMS Bits */
;;;2953     TIMx->SMCR &= (uint16_t)~TIM_SMCR_SMS;
000002  f0220207          BIC      r2,r2,#7
000006  8102              STRH     r2,[r0,#8]
;;;2954   
;;;2955     /* Select the Slave Mode */
;;;2956     TIMx->SMCR |= TIM_SlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  8102              STRH     r2,[r0,#8]
;;;2957   }
00000e  4770              BX       lr
;;;2958   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;417      */
;;;418    void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint32_t Autoreload)
000000  62c1              STR      r1,[r0,#0x2c]
;;;419    {
;;;420      /* Check the parameters */
;;;421      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;422      
;;;423      /* Set the Autoreload Register value */
;;;424      TIMx->ARR = Autoreload;
;;;425    }
000002  4770              BX       lr
;;;426    
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;565      */
;;;566    void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;567    {
;;;568      /* Check the parameters */
;;;569      assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;570      assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;571    
;;;572      /* Reset the CKD Bits */
;;;573      TIMx->CR1 &= (uint16_t)(~TIM_CR1_CKD);
000002  f4227240          BIC      r2,r2,#0x300
000006  8002              STRH     r2,[r0,#0]
;;;574    
;;;575      /* Set the CKD value */
;;;576      TIMx->CR1 |= TIM_CKD;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;577    }
00000e  4770              BX       lr
;;;578    
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;1051     */
;;;1052   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint32_t Compare1)
000000  6341              STR      r1,[r0,#0x34]
;;;1053   {
;;;1054     /* Check the parameters */
;;;1055     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1056   
;;;1057     /* Set the Capture Compare1 Register value */
;;;1058     TIMx->CCR1 = Compare1;
;;;1059   }
000002  4770              BX       lr
;;;1060   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;1067     */
;;;1068   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint32_t Compare2)
000000  6381              STR      r1,[r0,#0x38]
;;;1069   {
;;;1070     /* Check the parameters */
;;;1071     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1072   
;;;1073     /* Set the Capture Compare2 Register value */
;;;1074     TIMx->CCR2 = Compare2;
;;;1075   }
000002  4770              BX       lr
;;;1076   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;1082     */
;;;1083   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint32_t Compare3)
000000  63c1              STR      r1,[r0,#0x3c]
;;;1084   {
;;;1085     /* Check the parameters */
;;;1086     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1087   
;;;1088     /* Set the Capture Compare3 Register value */
;;;1089     TIMx->CCR3 = Compare3;
;;;1090   }
000002  4770              BX       lr
;;;1091   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;1097     */
;;;1098   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint32_t Compare4)
000000  6401              STR      r1,[r0,#0x40]
;;;1099   {
;;;1100     /* Check the parameters */
;;;1101     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1102   
;;;1103     /* Set the Capture Compare4 Register value */
;;;1104     TIMx->CCR4 = Compare4;
;;;1105   }
000002  4770              BX       lr
;;;1106   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;402      */
;;;403    void TIM_SetCounter(TIM_TypeDef* TIMx, uint32_t Counter)
000000  6241              STR      r1,[r0,#0x24]
;;;404    {
;;;405      /* Check the parameters */
;;;406       assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;407    
;;;408      /* Set the Counter Register value */
;;;409      TIMx->CNT = Counter;
;;;410    }
000002  4770              BX       lr
;;;411    
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2084     */
;;;2085   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2086   {
;;;2087     /* Check the parameters */
;;;2088     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2089     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2090   
;;;2091     /* Reset the IC1PSC Bits */
;;;2092     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC1PSC;
000002  f022020c          BIC      r2,r2,#0xc
000006  8302              STRH     r2,[r0,#0x18]
;;;2093   
;;;2094     /* Set the IC1PSC value */
;;;2095     TIMx->CCMR1 |= TIM_ICPSC;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  430a              ORRS     r2,r2,r1
00000c  8302              STRH     r2,[r0,#0x18]
;;;2096   }
00000e  4770              BX       lr
;;;2097   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2109     */
;;;2110   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2111   {
;;;2112     /* Check the parameters */
;;;2113     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2114     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2115   
;;;2116     /* Reset the IC2PSC Bits */
;;;2117     TIMx->CCMR1 &= (uint16_t)~TIM_CCMR1_IC2PSC;
000002  f4226240          BIC      r2,r2,#0xc00
000006  8302              STRH     r2,[r0,#0x18]
;;;2118   
;;;2119     /* Set the IC2PSC value */
;;;2120     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032101          AND      r1,r3,r1,LSL #8
000012  430a              ORRS     r2,r2,r1
000014  8302              STRH     r2,[r0,#0x18]
;;;2121   }
000016  4770              BX       lr
;;;2122   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2133     */
;;;2134   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2135   {
;;;2136     /* Check the parameters */
;;;2137     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2138     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2139   
;;;2140     /* Reset the IC3PSC Bits */
;;;2141     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC3PSC;
000002  f022020c          BIC      r2,r2,#0xc
000006  8382              STRH     r2,[r0,#0x1c]
;;;2142   
;;;2143     /* Set the IC3PSC value */
;;;2144     TIMx->CCMR2 |= TIM_ICPSC;
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  430a              ORRS     r2,r2,r1
00000c  8382              STRH     r2,[r0,#0x1c]
;;;2145   }
00000e  4770              BX       lr
;;;2146   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2157     */
;;;2158   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2159   {  
;;;2160     /* Check the parameters */
;;;2161     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2162     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2163   
;;;2164     /* Reset the IC4PSC Bits */
;;;2165     TIMx->CCMR2 &= (uint16_t)~TIM_CCMR2_IC4PSC;
000002  f4226240          BIC      r2,r2,#0xc00
000006  8382              STRH     r2,[r0,#0x1c]
;;;2166   
;;;2167     /* Set the IC4PSC value */
;;;2168     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  f64f73ff          MOV      r3,#0xffff
00000e  ea032101          AND      r1,r3,r1,LSL #8
000012  430a              ORRS     r2,r2,r1
000014  8382              STRH     r2,[r0,#0x1c]
;;;2169   }
000016  4770              BX       lr
;;;2170   /**
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;2723     */
;;;2724   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  b570              PUSH     {r4-r6,lr}
;;;2725                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;2726   {
000002  4616              MOV      r6,r2
000004  460d              MOV      r5,r1
;;;2727     /* Check the parameters */
;;;2728     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;2729     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;2730     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;2731   
;;;2732     /* Configure the Timer Input Clock Source */
;;;2733     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
000006  2960              CMP      r1,#0x60
000008  4604              MOV      r4,r0                 ;2726
;;;2734     {
;;;2735       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
;;;2736     }
;;;2737     else
;;;2738     {
;;;2739       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00000a  f04f0201          MOV      r2,#1
00000e  4631              MOV      r1,r6
000010  d00a              BEQ      |L86.40|
000012  f7fffffe          BL       TI1_Config
                  |L86.22|
;;;2740     }
;;;2741     /* Select the Trigger source */
;;;2742     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
000016  4629              MOV      r1,r5
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       TIM_SelectInputTrigger
;;;2743     /* Select the External clock mode1 */
;;;2744     TIMx->SMCR |= TIM_SlaveMode_External1;
00001e  8920              LDRH     r0,[r4,#8]
000020  f0400007          ORR      r0,r0,#7
000024  8120              STRH     r0,[r4,#8]
;;;2745   }
000026  bd70              POP      {r4-r6,pc}
                  |L86.40|
000028  f7fffffe          BL       TI2_Config
00002c  e7f3              B        |L86.22|
;;;2746   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;281      */
;;;282    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;283    {
;;;284      uint16_t tmpcr1 = 0;
;;;285    
;;;286      /* Check the parameters */
;;;287      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;288      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;289      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;290    
;;;291      tmpcr1 = TIMx->CR1;  
000002  8802              LDRH     r2,[r0,#0]
;;;292    
;;;293      if((TIMx == TIM1) || (TIMx == TIM8)||
000004  4c16              LDR      r4,|L87.96|
000006  4d17              LDR      r5,|L87.100|
000008  42a0              CMP      r0,r4
00000a  d00d              BEQ      |L87.40|
00000c  42a8              CMP      r0,r5
00000e  d00b              BEQ      |L87.40|
;;;294         (TIMx == TIM2) || (TIMx == TIM3)||
000010  f1b04f80          CMP      r0,#0x40000000
000014  d008              BEQ      |L87.40|
000016  4b14              LDR      r3,|L87.104|
000018  4298              CMP      r0,r3
00001a  d005              BEQ      |L87.40|
;;;295         (TIMx == TIM4) || (TIMx == TIM5)) 
00001c  4b13              LDR      r3,|L87.108|
00001e  4298              CMP      r0,r3
000020  d002              BEQ      |L87.40|
000022  4b13              LDR      r3,|L87.112|
000024  4298              CMP      r0,r3
000026  d103              BNE      |L87.48|
                  |L87.40|
;;;296      {
;;;297        /* Select the Counter Mode */
;;;298        tmpcr1 &= (uint16_t)(~(TIM_CR1_DIR | TIM_CR1_CMS));
000028  f0220370          BIC      r3,r2,#0x70
;;;299        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
00002c  884a              LDRH     r2,[r1,#2]
00002e  431a              ORRS     r2,r2,r3
                  |L87.48|
;;;300      }
;;;301     
;;;302      if((TIMx != TIM6) && (TIMx != TIM7))
000030  4b10              LDR      r3,|L87.116|
000032  4298              CMP      r0,r3
000034  d006              BEQ      |L87.68|
000036  4b10              LDR      r3,|L87.120|
000038  4298              CMP      r0,r3
00003a  d003              BEQ      |L87.68|
;;;303      {
;;;304        /* Set the clock division */
;;;305        tmpcr1 &=  (uint16_t)(~TIM_CR1_CKD);
00003c  f4227340          BIC      r3,r2,#0x300
;;;306        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
000040  890a              LDRH     r2,[r1,#8]
000042  431a              ORRS     r2,r2,r3
                  |L87.68|
;;;307      }
;;;308    
;;;309      TIMx->CR1 = tmpcr1;
000044  8002              STRH     r2,[r0,#0]
;;;310    
;;;311      /* Set the Autoreload value */
;;;312      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
000046  684a              LDR      r2,[r1,#4]
000048  62c2              STR      r2,[r0,#0x2c]
;;;313     
;;;314      /* Set the Prescaler value */
;;;315      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
00004a  880a              LDRH     r2,[r1,#0]
00004c  8502              STRH     r2,[r0,#0x28]
;;;316        
;;;317      if ((TIMx == TIM1) || (TIMx == TIM8))  
00004e  42a0              CMP      r0,r4
000050  d001              BEQ      |L87.86|
000052  42a8              CMP      r0,r5
000054  d101              BNE      |L87.90|
                  |L87.86|
;;;318      {
;;;319        /* Set the Repetition Counter value */
;;;320        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
000056  7a89              LDRB     r1,[r1,#0xa]
000058  8601              STRH     r1,[r0,#0x30]
                  |L87.90|
;;;321      }
;;;322    
;;;323      /* Generate an update event to reload the Prescaler 
;;;324         and the repetition counter(only for TIM1 and TIM8) value immediatly */
;;;325      TIMx->EGR = TIM_PSCReloadMode_Immediate;          
00005a  2101              MOVS     r1,#1
00005c  8281              STRH     r1,[r0,#0x14]
;;;326    }
00005e  bd30              POP      {r4,r5,pc}
;;;327    
                          ENDP

                  |L87.96|
                          DCD      0x40010000
                  |L87.100|
                          DCD      0x40010400
                  |L87.104|
                          DCD      0x40000400
                  |L87.108|
                          DCD      0x40000800
                  |L87.112|
                          DCD      0x40000c00
                  |L87.116|
                          DCD      0x40001000
                  |L87.120|
                          DCD      0x40001400

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;333      */
;;;334    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f04f31ff          MOV      r1,#0xffffffff
;;;335    {
;;;336      /* Set the default configuration */
;;;337      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFFFFFF;
;;;338      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000004  6041              STR      r1,[r0,#4]
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;339      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  8101              STRH     r1,[r0,#8]
;;;340      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;341      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7281              STRB     r1,[r0,#0xa]
;;;342    }
000010  4770              BX       lr
;;;343    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;461      */
;;;462    void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;463    {
;;;464      /* Check the parameters */
;;;465      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;466      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;467    
;;;468      if (NewState != DISABLE)
;;;469      {
;;;470        /* Set the Update Disable Bit */
;;;471        TIMx->CR1 |= TIM_CR1_UDIS;
;;;472      }
;;;473      else
;;;474      {
;;;475        /* Reset the Update Disable Bit */
;;;476        TIMx->CR1 &= (uint16_t)~TIM_CR1_UDIS;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L89.12|
000006  f0410102          ORR      r1,r1,#2              ;471
00000a  e001              B        |L89.16|
                  |L89.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L89.16|
000010  8001              STRH     r1,[r0,#0]            ;471
;;;477      }
;;;478    }
000012  4770              BX       lr
;;;479    
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;490      */
;;;491    void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  2900              CMP      r1,#0
;;;492    {
;;;493      /* Check the parameters */
;;;494      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;495      assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;496    
;;;497      if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;498      {
;;;499        /* Set the URS Bit */
;;;500        TIMx->CR1 |= TIM_CR1_URS;
;;;501      }
;;;502      else
;;;503      {
;;;504        /* Reset the URS Bit */
;;;505        TIMx->CR1 &= (uint16_t)~TIM_CR1_URS;
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L90.12|
000006  f0410104          ORR      r1,r1,#4              ;500
00000a  e001              B        |L90.16|
                  |L90.12|
00000c  f0210104          BIC      r1,r1,#4
                  |L90.16|
000010  8001              STRH     r1,[r0,#0]            ;500
;;;506      }
;;;507    }
000012  4770              BX       lr
;;;508    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Libraries\\CMSIS\\stm32f4xx_tim.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_tim_c_c458916b____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___15_stm32f4xx_tim_c_c458916b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_tim_c_c458916b____REVSH|
#line 128
|__asm___15_stm32f4xx_tim_c_c458916b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
