; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\MEDIA_USB_KEY\usbh_core.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\MEDIA_USB_KEY\usbh_core.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\MEDIA_USB_KEY\usbh_core.crf Libraries\STM32_USB_HOST_Library\usbh_core.c]
                          THUMB

                          AREA ||i.USBH_Connect||, CODE, READONLY, ALIGN=1

                  USBH_Connect PROC
;;;110      */
;;;111    void USBH_Connect (void *pdev)
000000  f8d024ac          LDR      r2,[r0,#0x4ac]
;;;112    {
;;;113      USB_OTG_CORE_HANDLE *ppdev = pdev;
;;;114      ppdev->host.port_cb->ConnStatus = 1;
000004  2101              MOVS     r1,#1
000006  7211              STRB     r1,[r2,#8]
;;;115      ppdev->host.port_cb->ConnHandled = 0; 
000008  f8d004ac          LDR      r0,[r0,#0x4ac]
00000c  2100              MOVS     r1,#0
00000e  7281              STRB     r1,[r0,#0xa]
;;;116    }
000010  4770              BX       lr
;;;117    
                          ENDP


                          AREA ||i.USBH_DeInit||, CODE, READONLY, ALIGN=1

                  USBH_DeInit PROC
;;;183      */
;;;184    USBH_Status USBH_DeInit(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  b570              PUSH     {r4-r6,lr}
;;;185    {
000002  460c              MOV      r4,r1
;;;186      /* Software Init */
;;;187      
;;;188      phost->gState = HOST_IDLE;
000004  2100              MOVS     r1,#0
000006  7021              STRB     r1,[r4,#0]
;;;189      phost->gStateBkp = HOST_IDLE; 
000008  7061              STRB     r1,[r4,#1]
;;;190      phost->EnumState = ENUM_IDLE;
00000a  70a1              STRB     r1,[r4,#2]
;;;191      phost->RequestState = CMD_SEND;  
00000c  2201              MOVS     r2,#1
00000e  4605              MOV      r5,r0                 ;185
000010  70e2              STRB     r2,[r4,#3]
;;;192      
;;;193      phost->Control.state = CTRL_SETUP;
000012  7722              STRB     r2,[r4,#0x1c]
;;;194      phost->Control.ep0size = USB_OTG_MAX_EP0_SIZE;  
000014  2040              MOVS     r0,#0x40
000016  71a0              STRB     r0,[r4,#6]
;;;195      
;;;196      phost->device_prop.address = USBH_DEVICE_ADDRESS_DEFAULT;
000018  f8841020          STRB     r1,[r4,#0x20]
;;;197      phost->device_prop.speed = HPRT0_PRTSPD_FULL_SPEED;
00001c  f8842021          STRB     r2,[r4,#0x21]
;;;198      
;;;199      USBH_Free_Channel  (pdev, phost->Control.hc_num_in);
000020  7921              LDRB     r1,[r4,#4]
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       USBH_Free_Channel
;;;200      USBH_Free_Channel  (pdev, phost->Control.hc_num_out);  
000028  7961              LDRB     r1,[r4,#5]
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       USBH_Free_Channel
;;;201      return USBH_OK;
000030  2000              MOVS     r0,#0
;;;202    }
000032  bd70              POP      {r4-r6,pc}
;;;203    
                          ENDP


                          AREA ||i.USBH_Disconnect||, CODE, READONLY, ALIGN=1

                  USBH_Disconnect PROC
;;;124    
;;;125    void USBH_Disconnect (void *pdev)
000000  f8d024ac          LDR      r2,[r0,#0x4ac]
;;;126    {
;;;127      
;;;128      USB_OTG_CORE_HANDLE *ppdev = pdev;
;;;129        
;;;130      /* Make device Not connected flag true */
;;;131      ppdev->host.port_cb->DisconnStatus = 1; 
000004  2101              MOVS     r1,#1
000006  7251              STRB     r1,[r2,#9]
;;;132      ppdev->host.port_cb->DisconnHandled = 0;
000008  f8d004ac          LDR      r0,[r0,#0x4ac]
00000c  2100              MOVS     r1,#0
00000e  72c1              STRB     r1,[r0,#0xb]
;;;133    }
000010  4770              BX       lr
;;;134    
                          ENDP


                          AREA ||i.USBH_ErrorHandle||, CODE, READONLY, ALIGN=1

                  USBH_ErrorHandle PROC
;;;362      */
;;;363    void USBH_ErrorHandle(USBH_HOST *phost, USBH_Status errType)
000000  b570              PUSH     {r4-r6,lr}
;;;364    {
;;;365      /* Error unrecovered or not supported device speed */
;;;366      if ( (errType == USBH_ERROR_SPEED_UNKNOWN) ||
;;;367           (errType == USBH_UNRECOVERED_ERROR) )
;;;368      {
;;;369        phost->usr_cb->UnrecoveredError(); 
;;;370        phost->gState = HOST_ERROR_STATE;   
000002  250c              MOVS     r5,#0xc
000004  4604              MOV      r4,r0                 ;364
000006  2905              CMP      r1,#5                 ;366
000008  d00a              BEQ      |L4.32|
00000a  2904              CMP      r1,#4                 ;367
00000c  d008              BEQ      |L4.32|
;;;371      }  
;;;372      /* USB host restart requested from application layer */
;;;373      else if(errType == USBH_APPLY_DEINIT)
00000e  2906              CMP      r1,#6
000010  d10b              BNE      |L4.42|
;;;374      {
;;;375        phost->gState = HOST_ERROR_STATE;  
000012  7025              STRB     r5,[r4,#0]
;;;376        /* user callback for initalization */
;;;377        phost->usr_cb->Init();
000014  f8d00080          LDR      r0,[r0,#0x80]
000018  6800              LDR      r0,[r0,#0]
00001a  e8bd4070          POP      {r4-r6,lr}
00001e  4700              BX       r0
                  |L4.32|
000020  f8d40080          LDR      r0,[r4,#0x80]         ;369
000024  6c40              LDR      r0,[r0,#0x44]         ;369
000026  4780              BLX      r0                    ;369
000028  7025              STRB     r5,[r4,#0]            ;370
                  |L4.42|
;;;378      } 
;;;379    }
00002a  bd70              POP      {r4-r6,pc}
;;;380    
                          ENDP


                          AREA ||i.USBH_HandleControl||, CODE, READONLY, ALIGN=2

                  USBH_HandleControl PROC
;;;577      */
;;;578    USBH_Status USBH_HandleControl (USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;579    {
;;;580      uint8_t direction;  
;;;581      static uint16_t timeout = 0;
;;;582      USBH_Status status = USBH_OK;
000004  2600              MOVS     r6,#0
000006  4680              MOV      r8,r0                 ;579
;;;583      URB_STATE URB_Status = URB_IDLE;
;;;584      
;;;585      phost->Control.status = CTRL_START;
000008  748e              STRB     r6,[r1,#0x12]
;;;586    
;;;587      
;;;588      switch (phost->Control.state)
00000a  7f08              LDRB     r0,[r1,#0x1c]
00000c  250b              MOVS     r5,#0xb
00000e  2709              MOVS     r7,#9
;;;589      {
;;;590      case CTRL_SETUP:
;;;591        /* send a SETUP packet */
;;;592        USBH_CtlSendSetup     (pdev, 
;;;593    	                   phost->Control.setup.d8 , 
;;;594    	                   phost->Control.hc_num_out);  
;;;595        phost->Control.state = CTRL_SETUP_WAIT;  
;;;596        break; 
;;;597        
;;;598      case CTRL_SETUP_WAIT:
;;;599        
;;;600        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out); 
;;;601        /* case SETUP packet sent successfully */
;;;602        if(URB_Status == URB_DONE)
;;;603        { 
;;;604          direction = (phost->Control.setup.b.bmRequestType & USB_REQ_DIR_MASK);
;;;605          
;;;606          /* check if there is a data stage */
;;;607          if (phost->Control.setup.b.wLength.w != 0 )
;;;608          {        
;;;609            timeout = DATA_STAGE_TIMEOUT;
000010  f8df91b8          LDR      r9,|L5.460|
000014  460c              MOV      r4,r1                 ;579
000016  f04f0b08          MOV      r11,#8                ;588
00001a  f04f0a05          MOV      r10,#5                ;588
00001e  280c              CMP      r0,#0xc               ;588
000020  d217              BCS      |L5.82|
000022  e8dff000          TBB      [pc,r0]               ;588
000026  cf06              DCB      0xcf,0x06
000028  0e394157          DCB      0x0e,0x39,0x41,0x57
00002c  6879829c          DCB      0x68,0x79,0x82,0x9c
000030  adc1              DCB      0xad,0xc1
000032  7962              LDRB     r2,[r4,#5]            ;592
000034  f1040114          ADD      r1,r4,#0x14           ;592
000038  4640              MOV      r0,r8                 ;592
00003a  f7fffffe          BL       USBH_CtlSendSetup
00003e  2002              MOVS     r0,#2                 ;595
000040  e065              B        |L5.270|
000042  7961              LDRB     r1,[r4,#5]            ;600
000044  4640              MOV      r0,r8                 ;600
000046  f7fffffe          BL       HCD_GetURB_State
00004a  2801              CMP      r0,#1                 ;602
00004c  d002              BEQ      |L5.84|
;;;610            if (direction == USB_D2H)
;;;611            {
;;;612              /* Data Direction is IN */
;;;613              phost->Control.state = CTRL_DATA_IN;
;;;614            }
;;;615            else
;;;616            {
;;;617              /* Data Direction is OUT */
;;;618              phost->Control.state = CTRL_DATA_OUT;
;;;619            } 
;;;620          }
;;;621          /* No DATA stage */
;;;622          else
;;;623          {
;;;624            timeout = NODATA_STAGE_TIMEOUT;
;;;625            
;;;626            /* If there is No Data Transfer Stage */
;;;627            if (direction == USB_D2H)
;;;628            {
;;;629              /* Data Direction is IN */
;;;630              phost->Control.state = CTRL_STATUS_OUT;
;;;631            }
;;;632            else
;;;633            {
;;;634              /* Data Direction is OUT */
;;;635              phost->Control.state = CTRL_STATUS_IN;
;;;636            } 
;;;637          }          
;;;638          /* Set the delay timer to enable timeout for data stage completion */
;;;639          phost->Control.timer = HCD_GetCurrentFrame(pdev);
;;;640        }
;;;641        else if(URB_Status == URB_ERROR)
00004e  2803              CMP      r0,#3
000050  d01e              BEQ      |L5.144|
                  |L5.82|
000052  e0b7              B        |L5.452|
                  |L5.84|
000054  7d20              LDRB     r0,[r4,#0x14]         ;604
000056  8b61              LDRH     r1,[r4,#0x1a]         ;607
000058  f0000080          AND      r0,r0,#0x80           ;604
00005c  b151              CBZ      r1,|L5.116|
00005e  f2413288          MOV      r2,#0x1388            ;609
000062  f8a92000          STRH     r2,[r9,#0]            ;609
000066  2880              CMP      r0,#0x80              ;610
000068  d002              BEQ      |L5.112|
00006a  f884a01c          STRB     r10,[r4,#0x1c]        ;618
00006e  e008              B        |L5.130|
                  |L5.112|
000070  2003              MOVS     r0,#3                 ;613
000072  e005              B        |L5.128|
                  |L5.116|
000074  2232              MOVS     r2,#0x32              ;624
000076  f8a92000          STRH     r2,[r9,#0]            ;624
00007a  2880              CMP      r0,#0x80              ;627
00007c  d006              BEQ      |L5.140|
00007e  2007              MOVS     r0,#7                 ;635
                  |L5.128|
000080  7720              STRB     r0,[r4,#0x1c]         ;635
                  |L5.130|
000082  4640              MOV      r0,r8                 ;639
000084  f7fffffe          BL       HCD_GetCurrentFrame
000088  8220              STRH     r0,[r4,#0x10]         ;639
00008a  e09b              B        |L5.452|
                  |L5.140|
00008c  7727              STRB     r7,[r4,#0x1c]         ;630
00008e  e7f8              B        |L5.130|
                  |L5.144|
;;;642        {
;;;643          phost->Control.state = CTRL_ERROR;     
000090  7725              STRB     r5,[r4,#0x1c]
;;;644          phost->Control.status = CTRL_XACTERR;
000092  f884a012          STRB     r10,[r4,#0x12]
000096  e095              B        |L5.452|
;;;645        }    
;;;646        break;
;;;647        
;;;648      case CTRL_DATA_IN:  
;;;649        /* Issue an IN token */ 
;;;650        USBH_CtlReceiveData(pdev,
000098  7923              LDRB     r3,[r4,#4]
00009a  7b22              LDRB     r2,[r4,#0xc]
00009c  4640              MOV      r0,r8
00009e  68a1              LDR      r1,[r4,#8]
0000a0  f7fffffe          BL       USBH_CtlReceiveData
;;;651                            phost->Control.buff, 
;;;652                            phost->Control.length,
;;;653                            phost->Control.hc_num_in);
;;;654     
;;;655        phost->Control.state = CTRL_DATA_IN_WAIT;
0000a4  2004              MOVS     r0,#4
;;;656        break;    
0000a6  e032              B        |L5.270|
;;;657        
;;;658      case CTRL_DATA_IN_WAIT:
;;;659        
;;;660        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
0000a8  7921              LDRB     r1,[r4,#4]
0000aa  4640              MOV      r0,r8
0000ac  f7fffffe          BL       HCD_GetURB_State
;;;661        
;;;662        /* check is DATA packet transfered successfully */
;;;663        if  (URB_Status == URB_DONE)
0000b0  2801              CMP      r0,#1
0000b2  d00d              BEQ      |L5.208|
;;;664        { 
;;;665          phost->Control.state = CTRL_STATUS_OUT;
;;;666        }
;;;667       
;;;668        /* manage error cases*/
;;;669        if  (URB_Status == URB_STALL) 
0000b4  2804              CMP      r0,#4
0000b6  d070              BEQ      |L5.410|
;;;670        { 
;;;671          /* In stall case, return to previous machine state*/
;;;672          phost->gState =   phost->gStateBkp;
;;;673        }   
;;;674        else if (URB_Status == URB_ERROR)
0000b8  2803              CMP      r0,#3
0000ba  d073              BEQ      |L5.420|
                  |L5.188|
;;;675        {
;;;676          /* Device error */
;;;677          phost->Control.state = CTRL_ERROR;    
;;;678        }
;;;679        else if ((HCD_GetCurrentFrame(pdev)- phost->Control.timer) > timeout)
0000bc  4640              MOV      r0,r8
0000be  f7fffffe          BL       HCD_GetCurrentFrame
0000c2  8a21              LDRH     r1,[r4,#0x10]
0000c4  1a41              SUBS     r1,r0,r1
0000c6  f8b90000          LDRH     r0,[r9,#0]  ; timeout
0000ca  4281              CMP      r1,r0
0000cc  d86a              BHI      |L5.420|
0000ce  e079              B        |L5.452|
                  |L5.208|
0000d0  7727              STRB     r7,[r4,#0x1c]         ;665
0000d2  e7f3              B        |L5.188|
;;;680        {
;;;681          /* timeout for IN transfer */
;;;682          phost->Control.state = CTRL_ERROR; 
;;;683        }   
;;;684        break;
;;;685        
;;;686      case CTRL_DATA_OUT:
;;;687        /* Start DATA out transfer (only one DATA packet)*/
;;;688        
;;;689        pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
0000d4  7961              LDRB     r1,[r4,#5]
0000d6  eb081041          ADD      r0,r8,r1,LSL #5
0000da  f89012c5          LDRB     r1,[r0,#0x2c5]
0000de  f0810101          EOR      r1,r1,#1
0000e2  f88012c5          STRB     r1,[r0,#0x2c5]
;;;690        
;;;691        USBH_CtlSendData (pdev,
0000e6  7963              LDRB     r3,[r4,#5]
0000e8  7b22              LDRB     r2,[r4,#0xc]
0000ea  4640              MOV      r0,r8
0000ec  68a1              LDR      r1,[r4,#8]
0000ee  f7fffffe          BL       USBH_CtlSendData
;;;692                          phost->Control.buff, 
;;;693                          phost->Control.length , 
;;;694                          phost->Control.hc_num_out);
;;;695        
;;;696        phost->Control.state = CTRL_DATA_OUT_WAIT;
0000f2  2006              MOVS     r0,#6
;;;697        break;
0000f4  e00b              B        |L5.270|
;;;698        
;;;699      case CTRL_DATA_OUT_WAIT:
;;;700        
;;;701        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);     
0000f6  7961              LDRB     r1,[r4,#5]
0000f8  4640              MOV      r0,r8
0000fa  f7fffffe          BL       HCD_GetURB_State
;;;702        if  (URB_Status == URB_DONE)
0000fe  2801              CMP      r0,#1
000100  d004              BEQ      |L5.268|
;;;703        { /* If the Setup Pkt is sent successful, then change the state */
;;;704          phost->Control.state = CTRL_STATUS_IN;
;;;705        }
;;;706        
;;;707        /* handle error cases */
;;;708        else if  (URB_Status == URB_STALL) 
000102  2804              CMP      r0,#4
000104  d049              BEQ      |L5.410|
;;;709        { 
;;;710          /* In stall case, return to previous machine state*/
;;;711          phost->gState =   phost->gStateBkp;
;;;712        } 
;;;713        else if  (URB_Status == URB_NOTREADY)
000106  2802              CMP      r0,#2
000108  d003              BEQ      |L5.274|
00010a  e041              B        |L5.400|
                  |L5.268|
00010c  2007              MOVS     r0,#7                 ;704
                  |L5.270|
00010e  7720              STRB     r0,[r4,#0x1c]         ;704
000110  e058              B        |L5.452|
                  |L5.274|
;;;714        { 
;;;715          /* Nack received from device */
;;;716          phost->Control.state = CTRL_DATA_OUT;
000112  f884a01c          STRB     r10,[r4,#0x1c]
000116  e055              B        |L5.452|
;;;717        }    
;;;718        else if (URB_Status == URB_ERROR)
;;;719        {
;;;720          /* device error */
;;;721          phost->Control.state = CTRL_ERROR;      
;;;722        } 
;;;723        break;
;;;724        
;;;725        
;;;726      case CTRL_STATUS_IN:
;;;727        /* Send 0 bytes out packet */
;;;728        USBH_CtlReceiveData (pdev,
000118  2200              MOVS     r2,#0
00011a  7923              LDRB     r3,[r4,#4]
00011c  4611              MOV      r1,r2
00011e  4640              MOV      r0,r8
000120  f7fffffe          BL       USBH_CtlReceiveData
;;;729                             0,
;;;730                             0,
;;;731                             phost->Control.hc_num_in);
;;;732        
;;;733        phost->Control.state = CTRL_STATUS_IN_WAIT;
000124  f884b01c          STRB     r11,[r4,#0x1c]
;;;734        
;;;735        break;
000128  e04c              B        |L5.452|
;;;736        
;;;737      case CTRL_STATUS_IN_WAIT:
;;;738        
;;;739        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_in); 
00012a  7921              LDRB     r1,[r4,#4]
00012c  4640              MOV      r0,r8
00012e  f7fffffe          BL       HCD_GetURB_State
000132  4607              MOV      r7,r0
;;;740        
;;;741        if  ( URB_Status == URB_DONE)
000134  2801              CMP      r0,#1
000136  d030              BEQ      |L5.410|
;;;742        { /* Control transfers completed, Exit the State Machine */
;;;743          phost->gState =   phost->gStateBkp;
;;;744        }
;;;745        
;;;746        else if (URB_Status == URB_ERROR)
000138  2f03              CMP      r7,#3
00013a  d033              BEQ      |L5.420|
;;;747        {
;;;748          phost->Control.state = CTRL_ERROR;  
;;;749        }
;;;750        
;;;751        else if((HCD_GetCurrentFrame(pdev)\
00013c  4640              MOV      r0,r8
00013e  f7fffffe          BL       HCD_GetCurrentFrame
000142  8a21              LDRH     r1,[r4,#0x10]
000144  1a41              SUBS     r1,r0,r1
000146  f8b90000          LDRH     r0,[r9,#0]  ; timeout
00014a  4281              CMP      r1,r0
00014c  d82a              BHI      |L5.420|
;;;752          - phost->Control.timer) > timeout)
;;;753        {
;;;754          phost->Control.state = CTRL_ERROR; 
;;;755        }
;;;756         else if(URB_Status == URB_STALL)
00014e  2f04              CMP      r7,#4
000150  d138              BNE      |L5.452|
;;;757        {
;;;758          /* Control transfers completed, Exit the State Machine */
;;;759          phost->gState =   phost->gStateBkp;
000152  7860              LDRB     r0,[r4,#1]
000154  7020              STRB     r0,[r4,#0]
;;;760          phost->Control.status = CTRL_STALL;
000156  2004              MOVS     r0,#4
000158  74a0              STRB     r0,[r4,#0x12]
;;;761          status = USBH_NOT_SUPPORTED;
00015a  2603              MOVS     r6,#3
00015c  e032              B        |L5.452|
;;;762        }
;;;763        break;
;;;764        
;;;765      case CTRL_STATUS_OUT:
;;;766        pdev->host.hc[phost->Control.hc_num_out].toggle_out ^= 1; 
00015e  7961              LDRB     r1,[r4,#5]
;;;767        USBH_CtlSendData (pdev,
000160  2200              MOVS     r2,#0
000162  eb081041          ADD      r0,r8,r1,LSL #5       ;766
000166  f89012c5          LDRB     r1,[r0,#0x2c5]        ;766
00016a  f0810101          EOR      r1,r1,#1              ;766
00016e  f88012c5          STRB     r1,[r0,#0x2c5]        ;766
000172  7963              LDRB     r3,[r4,#5]
000174  4611              MOV      r1,r2
000176  4640              MOV      r0,r8
000178  f7fffffe          BL       USBH_CtlSendData
;;;768                          0,
;;;769                          0,
;;;770                          phost->Control.hc_num_out);
;;;771        
;;;772        phost->Control.state = CTRL_STATUS_OUT_WAIT;
00017c  200a              MOVS     r0,#0xa
;;;773        break;
00017e  e7c6              B        |L5.270|
;;;774        
;;;775      case CTRL_STATUS_OUT_WAIT: 
;;;776        
;;;777        URB_Status = HCD_GetURB_State(pdev , phost->Control.hc_num_out);  
000180  7961              LDRB     r1,[r4,#5]
000182  4640              MOV      r0,r8
000184  f7fffffe          BL       HCD_GetURB_State
;;;778        if  (URB_Status == URB_DONE)
000188  2801              CMP      r0,#1
00018a  d006              BEQ      |L5.410|
;;;779        { 
;;;780          phost->gState =   phost->gStateBkp;    
;;;781        }
;;;782        else if  (URB_Status == URB_NOTREADY)
00018c  2802              CMP      r0,#2
00018e  d007              BEQ      |L5.416|
                  |L5.400|
;;;783        { 
;;;784          phost->Control.state = CTRL_STATUS_OUT;
;;;785        }      
;;;786        else if (URB_Status == URB_ERROR)
000190  2803              CMP      r0,#3
000192  d007              BEQ      |L5.420|
000194  e016              B        |L5.452|
000196  e000              B        |L5.410|
000198  e004              B        |L5.420|
                  |L5.410|
00019a  7860              LDRB     r0,[r4,#1]            ;780
00019c  7020              STRB     r0,[r4,#0]            ;780
00019e  e011              B        |L5.452|
                  |L5.416|
0001a0  7727              STRB     r7,[r4,#0x1c]         ;784
0001a2  e00f              B        |L5.452|
                  |L5.420|
;;;787        {
;;;788          phost->Control.state = CTRL_ERROR;      
0001a4  7725              STRB     r5,[r4,#0x1c]
0001a6  e00d              B        |L5.452|
;;;789        }
;;;790        break;
;;;791        
;;;792      case CTRL_ERROR:
;;;793        /* 
;;;794        After a halt condition is encountered or an error is detected by the 
;;;795        host, a control endpoint is allowed to recover by accepting the next Setup 
;;;796        PID; i.e., recovery actions via some other pipe are not required for control
;;;797        endpoints. For the Default Control Pipe, a device reset will ultimately be 
;;;798        required to clear the halt or error condition if the next Setup PID is not 
;;;799        accepted.
;;;800        */
;;;801        if (++ phost->Control.errorcount <= USBH_MAX_ERROR_COUNT)
0001a8  7ba0              LDRB     r0,[r4,#0xe]
0001aa  1c40              ADDS     r0,r0,#1
0001ac  b2c0              UXTB     r0,r0
0001ae  73a0              STRB     r0,[r4,#0xe]
0001b0  2802              CMP      r0,#2
0001b2  d802              BHI      |L5.442|
;;;802        {
;;;803          /* Do the transmission again, starting from SETUP Packet */
;;;804          phost->Control.state = CTRL_SETUP; 
0001b4  2001              MOVS     r0,#1
0001b6  7708              STRB     r0,[r1,#0x1c]
0001b8  e004              B        |L5.452|
                  |L5.442|
;;;805        }
;;;806        else
;;;807        {
;;;808          phost->Control.status = CTRL_FAIL;
0001ba  f884b012          STRB     r11,[r4,#0x12]
;;;809          phost->gState =   phost->gStateBkp;
0001be  7860              LDRB     r0,[r4,#1]
0001c0  7008              STRB     r0,[r1,#0]
;;;810          
;;;811          status = USBH_FAIL;
0001c2  2602              MOVS     r6,#2
                  |L5.452|
;;;812        }
;;;813        break;
;;;814        
;;;815      default:
;;;816        break;
;;;817      }
;;;818      return status;
0001c4  4630              MOV      r0,r6
;;;819    }
0001c6  e8bd9ff0          POP      {r4-r12,pc}
;;;820    
                          ENDP

0001ca  0000              DCW      0x0000
                  |L5.460|
                          DCD      ||.data||

                          AREA ||i.USBH_HandleEnum||, CODE, READONLY, ALIGN=2

                  USBH_HandleEnum PROC
;;;387      */
;;;388    static USBH_Status USBH_HandleEnum(USB_OTG_CORE_HANDLE *pdev, USBH_HOST *phost)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;389    {
000004  460c              MOV      r4,r1
000006  4680              MOV      r8,r0
;;;390      USBH_Status Status = USBH_BUSY;  
000008  2501              MOVS     r5,#1
;;;391      uint8_t Local_Buffer[64];
;;;392      
;;;393      switch (phost->EnumState)
00000a  7889              LDRB     r1,[r1,#2]
00000c  2600              MOVS     r6,#0
;;;394      {
;;;395      case ENUM_IDLE:  
;;;396        /* Get Device Desc for only 1st 8 bytes : To get EP0 MaxPacketSize */
;;;397        if ( USBH_Get_DevDesc(pdev , phost, 8) == USBH_OK)
;;;398        {
;;;399          phost->Control.ep0size = phost->device_prop.Dev_Desc.bMaxPacketSize;
;;;400          
;;;401          /* Issue Reset  */
;;;402          HCD_ResetPort(pdev);
;;;403          phost->EnumState = ENUM_GET_FULL_DEV_DESC;
;;;404          
;;;405          /* modify control channels configuration for MaxPacket size */
;;;406          USBH_Modify_Channel (pdev,
;;;407                               phost->Control.hc_num_out,
;;;408                               0,
;;;409                               0,
;;;410                               0,
;;;411                               phost->Control.ep0size);
;;;412          
;;;413          USBH_Modify_Channel (pdev,
;;;414                               phost->Control.hc_num_in,
;;;415                               0,
;;;416                               0,
;;;417                               0,
;;;418                               phost->Control.ep0size);      
;;;419        }
;;;420        break;
;;;421        
;;;422      case ENUM_GET_FULL_DEV_DESC:  
;;;423        /* Get FULL Device Desc  */
;;;424        if ( USBH_Get_DevDesc(pdev, phost, USB_DEVICE_DESC_SIZE)\
;;;425          == USBH_OK)
;;;426        {
;;;427          /* user callback for device descriptor available */
;;;428          phost->usr_cb->DeviceDescAvailable(&phost->device_prop.Dev_Desc);      
;;;429          phost->EnumState = ENUM_SET_ADDR;
;;;430        }
;;;431        break;
;;;432       
;;;433      case ENUM_SET_ADDR: 
;;;434        /* set address */
;;;435        if ( USBH_SetAddress(pdev, phost, USBH_DEVICE_ADDRESS) == USBH_OK)
;;;436        {
;;;437          phost->device_prop.address = USBH_DEVICE_ADDRESS;
;;;438          
;;;439          /* user callback for device address assigned */
;;;440          phost->usr_cb->DeviceAddressAssigned();
;;;441          phost->EnumState = ENUM_GET_CFG_DESC;
;;;442          
;;;443          /* modify control channels to update device address */
;;;444          USBH_Modify_Channel (pdev,
;;;445                               phost->Control.hc_num_in,
;;;446                               phost->device_prop.address,
;;;447                               0,
;;;448                               0,
;;;449                               0);
;;;450          
;;;451          USBH_Modify_Channel (pdev,
;;;452                               phost->Control.hc_num_out,
;;;453                               phost->device_prop.address,
;;;454                               0,
;;;455                               0,
;;;456                               0);         
;;;457        }
;;;458        break;
;;;459        
;;;460      case ENUM_GET_CFG_DESC:  
;;;461        /* get standard configuration descriptor */
;;;462        if ( USBH_Get_CfgDesc(pdev, 
;;;463                              phost,
;;;464                              USB_CONFIGURATION_DESC_SIZE) == USBH_OK)
;;;465        {
;;;466          phost->EnumState = ENUM_GET_FULL_CFG_DESC;
;;;467        }
;;;468        break;
;;;469        
;;;470      case ENUM_GET_FULL_CFG_DESC:  
;;;471        /* get FULL config descriptor (config, interface, endpoints) */
;;;472        if (USBH_Get_CfgDesc(pdev, 
;;;473                             phost,
;;;474                             phost->device_prop.Cfg_Desc.wTotalLength) == USBH_OK)
;;;475        {
;;;476          /* User callback for configuration descriptors available */
;;;477          phost->usr_cb->ConfigurationDescAvailable(&phost->device_prop.Cfg_Desc,
;;;478                                                          phost->device_prop.Itf_Desc,
;;;479                                                          phost->device_prop.Ep_Desc[0]);
;;;480          
;;;481          phost->EnumState = ENUM_GET_MFC_STRING_DESC;
;;;482        }
;;;483        break;
;;;484        
;;;485      case ENUM_GET_MFC_STRING_DESC:  
;;;486        if (phost->device_prop.Dev_Desc.iManufacturer != 0)
;;;487        { /* Check that Manufacturer String is available */
;;;488          
;;;489          if ( USBH_Get_StringDesc(pdev,
00000e  20ff              MOVS     r0,#0xff
000010  b092              SUB      sp,sp,#0x48           ;389
000012  462f              MOV      r7,r5                 ;390
000014  290a              CMP      r1,#0xa               ;393
000016  d252              BCS      |L6.190|
000018  e8dff001          TBB      [pc,r1]               ;393
00001c  05233252          DCB      0x05,0x23,0x32,0x52
000020  5b6d8097          DCB      0x5b,0x6d,0x80,0x97
000024  aab4              DCB      0xaa,0xb4
000026  2208              MOVS     r2,#8                 ;397
000028  4621              MOV      r1,r4                 ;397
00002a  4640              MOV      r0,r8                 ;397
00002c  f7fffffe          BL       USBH_Get_DevDesc
000030  2800              CMP      r0,#0                 ;397
000032  d144              BNE      |L6.190|
000034  f8940029          LDRB     r0,[r4,#0x29]         ;399
000038  71a0              STRB     r0,[r4,#6]            ;399
00003a  4640              MOV      r0,r8                 ;402
00003c  f7fffffe          BL       HCD_ResetPort
000040  70a7              STRB     r7,[r4,#2]            ;403
000042  79a0              LDRB     r0,[r4,#6]            ;406
000044  2300              MOVS     r3,#0                 ;406
000046  e9cd6000          STRD     r6,r0,[sp,#0]         ;406
00004a  7961              LDRB     r1,[r4,#5]            ;406
00004c  461a              MOV      r2,r3                 ;406
00004e  4640              MOV      r0,r8                 ;406
000050  f7fffffe          BL       USBH_Modify_Channel
000054  79a0              LDRB     r0,[r4,#6]            ;413
000056  2300              MOVS     r3,#0                 ;413
000058  e9cd6000          STRD     r6,r0,[sp,#0]         ;413
00005c  7921              LDRB     r1,[r4,#4]            ;413
00005e  461a              MOV      r2,r3                 ;413
000060  e02a              B        |L6.184|
000062  2212              MOVS     r2,#0x12              ;424
000064  4621              MOV      r1,r4                 ;424
000066  4640              MOV      r0,r8                 ;424
000068  f7fffffe          BL       USBH_Get_DevDesc
00006c  2800              CMP      r0,#0                 ;424
00006e  d126              BNE      |L6.190|
000070  f8d40080          LDR      r0,[r4,#0x80]         ;428
000074  69c1              LDR      r1,[r0,#0x1c]         ;428
000076  f1040022          ADD      r0,r4,#0x22           ;428
00007a  4788              BLX      r1                    ;428
00007c  2002              MOVS     r0,#2                 ;429
00007e  e07f              B        |L6.384|
000080  2201              MOVS     r2,#1                 ;435
000082  4621              MOV      r1,r4                 ;435
000084  4640              MOV      r0,r8                 ;435
000086  f7fffffe          BL       USBH_SetAddress
00008a  2800              CMP      r0,#0                 ;435
00008c  d17b              BNE      |L6.390|
00008e  1ca4              ADDS     r4,r4,#2              ;435
000090  77a7              STRB     r7,[r4,#0x1e]         ;437
000092  f8d4007e          LDR      r0,[r4,#0x7e]         ;440
000096  6a00              LDR      r0,[r0,#0x20]         ;440
000098  4780              BLX      r0                    ;440
00009a  2003              MOVS     r0,#3                 ;441
00009c  7020              STRB     r0,[r4,#0]            ;441
00009e  9600              STR      r6,[sp,#0]            ;444
0000a0  9601              STR      r6,[sp,#4]            ;444
0000a2  7fa2              LDRB     r2,[r4,#0x1e]         ;444
0000a4  78a1              LDRB     r1,[r4,#2]            ;444
0000a6  2300              MOVS     r3,#0                 ;444
0000a8  4640              MOV      r0,r8                 ;444
0000aa  f7fffffe          BL       USBH_Modify_Channel
0000ae  9600              STR      r6,[sp,#0]            ;451
0000b0  9601              STR      r6,[sp,#4]            ;451
0000b2  7fa2              LDRB     r2,[r4,#0x1e]         ;451
0000b4  78e1              LDRB     r1,[r4,#3]            ;451
0000b6  2300              MOVS     r3,#0                 ;451
                  |L6.184|
0000b8  4640              MOV      r0,r8                 ;451
0000ba  f7fffffe          BL       USBH_Modify_Channel
                  |L6.190|
0000be  e062              B        |L6.390|
0000c0  2209              MOVS     r2,#9                 ;462
0000c2  4621              MOV      r1,r4                 ;462
0000c4  4640              MOV      r0,r8                 ;462
0000c6  f7fffffe          BL       USBH_Get_CfgDesc
0000ca  2800              CMP      r0,#0                 ;462
0000cc  d15b              BNE      |L6.390|
0000ce  2004              MOVS     r0,#4                 ;466
0000d0  e056              B        |L6.384|
0000d2  8ee2              LDRH     r2,[r4,#0x36]         ;472
0000d4  4621              MOV      r1,r4                 ;472
0000d6  4640              MOV      r0,r8                 ;472
0000d8  f7fffffe          BL       USBH_Get_CfgDesc
0000dc  bba0              CBNZ     r0,|L6.328|
0000de  f8d40080          LDR      r0,[r4,#0x80]         ;477
0000e2  f1040250          ADD      r2,r4,#0x50           ;477
0000e6  f104013e          ADD      r1,r4,#0x3e           ;477
0000ea  6a43              LDR      r3,[r0,#0x24]         ;477
0000ec  f1040034          ADD      r0,r4,#0x34           ;477
0000f0  4798              BLX      r3                    ;477
0000f2  2005              MOVS     r0,#5                 ;481
0000f4  e044              B        |L6.384|
0000f6  f8942030          LDRB     r2,[r4,#0x30]         ;486
0000fa  2606              MOVS     r6,#6                 ;393
0000fc  b152              CBZ      r2,|L6.276|
0000fe  9000              STR      r0,[sp,#0]
000100  ab02              ADD      r3,sp,#8
000102  4621              MOV      r1,r4
000104  4640              MOV      r0,r8
000106  f7fffffe          BL       USBH_Get_StringDesc
00010a  b9e8              CBNZ     r0,|L6.328|
;;;490                                   phost,
;;;491                                   phost->device_prop.Dev_Desc.iManufacturer, 
;;;492                                   Local_Buffer , 
;;;493                                   0xff) == USBH_OK)
;;;494          {
;;;495            /* User callback for Manufacturing string */
;;;496            phost->usr_cb->ManufacturerString(Local_Buffer);
00010c  f8d40080          LDR      r0,[r4,#0x80]
;;;497            phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
000110  6a81              LDR      r1,[r0,#0x28]
000112  e011              B        |L6.312|
                  |L6.276|
;;;498          }
;;;499        }
;;;500        else
;;;501        {
;;;502          phost->usr_cb->ManufacturerString("N/A");      
000114  f8d40080          LDR      r0,[r4,#0x80]
;;;503          phost->EnumState = ENUM_GET_PRODUCT_STRING_DESC;
000118  6a81              LDR      r1,[r0,#0x28]
00011a  e012              B        |L6.322|
;;;504        }
;;;505        break;
;;;506        
;;;507      case ENUM_GET_PRODUCT_STRING_DESC:   
;;;508        if (phost->device_prop.Dev_Desc.iProduct != 0)
00011c  f8942031          LDRB     r2,[r4,#0x31]
000120  2607              MOVS     r6,#7                 ;393
000122  b15a              CBZ      r2,|L6.316|
;;;509        { /* Check that Product string is available */
;;;510          if ( USBH_Get_StringDesc(pdev,
000124  9000              STR      r0,[sp,#0]
000126  ab02              ADD      r3,sp,#8
000128  4621              MOV      r1,r4
00012a  4640              MOV      r0,r8
00012c  f7fffffe          BL       USBH_Get_StringDesc
000130  b950              CBNZ     r0,|L6.328|
;;;511                                   phost,
;;;512                                   phost->device_prop.Dev_Desc.iProduct, 
;;;513                                   Local_Buffer, 
;;;514                                   0xff) == USBH_OK)
;;;515          {
;;;516            /* User callback for Product string */
;;;517            phost->usr_cb->ProductString(Local_Buffer);
000132  f8d40080          LDR      r0,[r4,#0x80]
000136  6ac1              LDR      r1,[r0,#0x2c]
                  |L6.312|
000138  a802              ADD      r0,sp,#8              ;496
00013a  e003              B        |L6.324|
                  |L6.316|
;;;518            phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
;;;519          }
;;;520        }
;;;521        else
;;;522        {
;;;523          phost->usr_cb->ProductString("N/A");
00013c  f8d40080          LDR      r0,[r4,#0x80]
000140  6ac1              LDR      r1,[r0,#0x2c]
                  |L6.322|
000142  a013              ADR      r0,|L6.400|
                  |L6.324|
;;;524          phost->EnumState = ENUM_GET_SERIALNUM_STRING_DESC;
;;;525        } 
;;;526        break;
;;;527        
;;;528      case ENUM_GET_SERIALNUM_STRING_DESC:   
;;;529        if (phost->device_prop.Dev_Desc.iSerialNumber != 0)
;;;530        { /* Check that Serial number string is available */    
;;;531          if ( USBH_Get_StringDesc(pdev, 
;;;532                                   phost,
;;;533                                   phost->device_prop.Dev_Desc.iSerialNumber, 
;;;534                                   Local_Buffer, 
;;;535                                   0xff) == USBH_OK)
;;;536          {
;;;537            /* User callback for Serial number string */
;;;538            phost->usr_cb->SerialNumString(Local_Buffer);
;;;539            phost->EnumState = ENUM_SET_CONFIGURATION;
;;;540          }
;;;541        }
;;;542        else
;;;543        {
;;;544          phost->usr_cb->SerialNumString("N/A");      
000144  4788              BLX      r1
;;;545          phost->EnumState = ENUM_SET_CONFIGURATION;
000146  70a6              STRB     r6,[r4,#2]
                  |L6.328|
000148  e01d              B        |L6.390|
00014a  f8942032          LDRB     r2,[r4,#0x32]         ;529
00014e  2608              MOVS     r6,#8                 ;393
000150  b152              CBZ      r2,|L6.360|
000152  9000              STR      r0,[sp,#0]            ;531
000154  ab02              ADD      r3,sp,#8              ;531
000156  4621              MOV      r1,r4                 ;531
000158  4640              MOV      r0,r8                 ;531
00015a  f7fffffe          BL       USBH_Get_StringDesc
00015e  b990              CBNZ     r0,|L6.390|
000160  f8d40080          LDR      r0,[r4,#0x80]         ;538
000164  6b01              LDR      r1,[r0,#0x30]         ;539
000166  e7e7              B        |L6.312|
                  |L6.360|
000168  f8d40080          LDR      r0,[r4,#0x80]         ;544
00016c  6b01              LDR      r1,[r0,#0x30]
00016e  e7e8              B        |L6.322|
;;;546        }  
;;;547        break;
;;;548          
;;;549      case ENUM_SET_CONFIGURATION:
;;;550        /* set configuration  (default config) */
;;;551        if (USBH_SetCfg(pdev, 
000170  f8942039          LDRB     r2,[r4,#0x39]
000174  4621              MOV      r1,r4
000176  4640              MOV      r0,r8
000178  f7fffffe          BL       USBH_SetCfg
00017c  b918              CBNZ     r0,|L6.390|
;;;552                        phost,
;;;553                        phost->device_prop.Cfg_Desc.bConfigurationValue) == USBH_OK)
;;;554        {
;;;555          phost->EnumState = ENUM_DEV_CONFIGURED;
00017e  2009              MOVS     r0,#9
                  |L6.384|
000180  70a0              STRB     r0,[r4,#2]
000182  e000              B        |L6.390|
;;;556        }
;;;557        break;
;;;558    
;;;559        
;;;560      case ENUM_DEV_CONFIGURED:
;;;561        /* user callback for enumeration done */
;;;562        Status = USBH_OK;
000184  2500              MOVS     r5,#0
                  |L6.390|
;;;563        break;
;;;564        
;;;565      default:
;;;566        break;
;;;567      }  
;;;568      return Status;
;;;569    }
000186  b012              ADD      sp,sp,#0x48
000188  4628              MOV      r0,r5                 ;568
00018a  e8bd81f0          POP      {r4-r8,pc}
;;;570    
                          ENDP

00018e  0000              DCW      0x0000
                  |L6.400|
000190  4e2f4100          DCB      "N/A",0

                          AREA ||i.USBH_Init||, CODE, READONLY, ALIGN=2

                  USBH_Init PROC
;;;141      */
;;;142    void USBH_Init(USB_OTG_CORE_HANDLE *pdev,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;143                   USB_OTG_CORE_ID_TypeDef coreID,
;;;144                   USBH_HOST *phost,               
;;;145                   USBH_Class_cb_TypeDef *class_cb, 
;;;146                   USBH_Usr_cb_TypeDef *usr_cb)
;;;147    {
000004  461e              MOV      r6,r3
000006  4614              MOV      r4,r2
000008  4688              MOV      r8,r1
00000a  4605              MOV      r5,r0
;;;148         
;;;149      /* Hardware Init */
;;;150      USB_OTG_BSP_Init(pdev);  
00000c  9f06              LDR      r7,[sp,#0x18]
00000e  f7fffffe          BL       USB_OTG_BSP_Init
;;;151      
;;;152      /* configure GPIO pin used for switching VBUS power */
;;;153      USB_OTG_BSP_ConfigVBUS(0);  
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       USB_OTG_BSP_ConfigVBUS
;;;154      
;;;155      
;;;156      /* Host de-initializations */
;;;157      USBH_DeInit(pdev, phost);
000018  4621              MOV      r1,r4
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       USBH_DeInit
000020  347c              ADDS     r4,r4,#0x7c
;;;158      
;;;159      /*Register class and user callbacks */
;;;160      phost->class_cb = class_cb;
;;;161      phost->usr_cb = usr_cb;  
;;;162      pdev->host.port_cb = &USBH_DeviceConnStatus_cb;
000022  490b              LDR      r1,|L7.80|
000024  e9c46700          STRD     r6,r7,[r4,#0]
000028  f24040ac          MOV      r0,#0x4ac
;;;163      
;;;164      pdev->host.port_cb->ConnStatus = 0;   
00002c  2200              MOVS     r2,#0
00002e  f8c514ac          STR      r1,[r5,#0x4ac]
000032  720a              STRB     r2,[r1,#8]
;;;165      pdev->host.port_cb->DisconnStatus = 0; 
000034  5940              LDR      r0,[r0,r5]
;;;166      
;;;167        
;;;168      /* Start the USB OTG core */     
;;;169       HCD_Init(pdev , coreID);
000036  4641              MOV      r1,r8
000038  7242              STRB     r2,[r0,#9]            ;165
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       HCD_Init
;;;170       
;;;171      /* Upon Init call usr call back */
;;;172      phost->usr_cb->Init();
000040  6860              LDR      r0,[r4,#4]
000042  6800              LDR      r0,[r0,#0]
000044  4780              BLX      r0
;;;173      
;;;174      /* Enable Interrupts */
;;;175      USB_OTG_BSP_EnableInterrupt(pdev);
000046  4628              MOV      r0,r5
000048  e8bd41f0          POP      {r4-r8,lr}
00004c  f7ffbffe          B.W      USB_OTG_BSP_EnableInterrupt
;;;176    }
;;;177    
                          ENDP

                  |L7.80|
                          DCD      ||.data||+0x4

                          AREA ||i.USBH_Process||, CODE, READONLY, ALIGN=1

                  USBH_Process PROC
;;;209    */
;;;210    void USBH_Process(USB_OTG_CORE_HANDLE *pdev , USBH_HOST *phost)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;211    {
;;;212      volatile USBH_Status status = USBH_FAIL;
000004  2702              MOVS     r7,#2
000006  460c              MOV      r4,r1                 ;211
000008  4605              MOV      r5,r0                 ;211
00000a  f88d7000          STRB     r7,[sp,#0]
;;;213        
;;;214      switch (phost->gState)
00000e  7809              LDRB     r1,[r1,#0]
000010  f04f0800          MOV      r8,#0
000014  f04f0901          MOV      r9,#1
;;;215      {
;;;216      case HOST_ISSUE_CORE_RESET :
;;;217         
;;;218        if ( HCD_ResetPort(pdev) == 0)
;;;219        {
;;;220          phost->gState = HOST_IDLE;
;;;221        }
;;;222        break;
;;;223        
;;;224      case HOST_IDLE :
;;;225        
;;;226        if (HCD_IsDeviceConnected(pdev))  
;;;227        {
;;;228          /* Wait for USB Connect Interrupt void USBH_ISR_Connected(void) */     
;;;229          USBH_DeAllocate_AllChannel(pdev);
;;;230          phost->gState = HOST_DEV_ATTACHED;
;;;231        }
;;;232        break;
;;;233       
;;;234      case HOST_DEV_ATTACHED :
;;;235        
;;;236        phost->usr_cb->DeviceAttached();
;;;237        pdev->host.port_cb->DisconnStatus = 0; 
;;;238        pdev->host.port_cb->ConnHandled = 1;  
;;;239    
;;;240        phost->Control.hc_num_out = USBH_Alloc_Channel(pdev, 0x00);
;;;241        phost->Control.hc_num_in = USBH_Alloc_Channel(pdev, 0x80);  
;;;242      
;;;243        /* Reset USB Device */
;;;244        if ( HCD_ResetPort(pdev) == 0)
;;;245        {
;;;246          phost->usr_cb->ResetDevice();
;;;247          /*  Wait for USB USBH_ISR_PrtEnDisableChange()  
;;;248          Host is Now ready to start the Enumeration 
;;;249          */
;;;250          
;;;251          phost->device_prop.speed = HCD_GetCurrentSpeed(pdev);
;;;252          
;;;253          phost->gState = HOST_ENUMERATION;
;;;254          phost->usr_cb->DeviceSpeedDetected(phost->device_prop.speed);
;;;255            
;;;256          /* Open Control pipes */
;;;257          USBH_Open_Channel (pdev,
;;;258                               phost->Control.hc_num_in,
;;;259                               phost->device_prop.address,
;;;260                               phost->device_prop.speed,
;;;261                               EP_TYPE_CTRL,
;;;262                               phost->Control.ep0size); 
;;;263          
;;;264          /* Open Control pipes */
;;;265          USBH_Open_Channel (pdev,
;;;266                               phost->Control.hc_num_out,
;;;267                               phost->device_prop.address,
;;;268                               phost->device_prop.speed,
;;;269                               EP_TYPE_CTRL,
;;;270                               phost->Control.ep0size);          
;;;271       }
;;;272        break;
;;;273        
;;;274      case HOST_ENUMERATION:     
;;;275        /* Check for enumeration status */  
;;;276        if ( USBH_HandleEnum(pdev , phost) == USBH_OK)
;;;277        { 
;;;278          /* The function shall return USBH_OK when full enumeration is complete */
;;;279          
;;;280          /* user callback for end of device basic enumeration */
;;;281          phost->usr_cb->EnumerationDone();
;;;282          
;;;283          phost->gState  = HOST_USR_INPUT;    
;;;284        }
;;;285        break;
;;;286        
;;;287      case HOST_USR_INPUT:    
;;;288        /*The function should return user response true to move to class state */
;;;289        if ( phost->usr_cb->UserInput() == USBH_USR_RESP_OK)
;;;290        {
;;;291          if((phost->class_cb->Init(pdev, phost))\
;;;292            == USBH_OK)
;;;293          {
;;;294            phost->gState  = HOST_CLASS_REQUEST;     
;;;295          }     
;;;296        }   
;;;297        break;
;;;298        
;;;299      case HOST_CLASS_REQUEST:  
;;;300        /* process class standard contol requests state machine */ 
;;;301        status = phost->class_cb->Requests(pdev, phost);
;;;302        
;;;303         if(status == USBH_OK)
;;;304         {
;;;305           phost->gState  = HOST_CLASS;
;;;306         }  
;;;307         
;;;308         else
;;;309         {
;;;310           USBH_ErrorHandle(phost, status);
;;;311         }
;;;312     
;;;313        
;;;314        break;    
;;;315      case HOST_CLASS:   
;;;316        /* process class state machine */
;;;317        status = phost->class_cb->Machine(pdev, phost);
;;;318        USBH_ErrorHandle(phost, status);
;;;319        break;       
;;;320        
;;;321      case HOST_CTRL_XFER:
;;;322        /* process control transfer state machine */
;;;323        USBH_HandleControl(pdev, phost);    
;;;324        break;
;;;325        
;;;326      case HOST_SUSPENDED:
;;;327        break;
;;;328      
;;;329      case HOST_ERROR_STATE:
;;;330        /* Re-Initilaize Host for new Enumeration */
;;;331        USBH_DeInit(pdev, phost);
;;;332        phost->usr_cb->DeInit();
;;;333        phost->class_cb->DeInit(pdev, &phost->device_prop);
000018  f1040a20          ADD      r10,r4,#0x20
00001c  f20046ac          ADD      r6,r0,#0x4ac          ;237
000020  290d              CMP      r1,#0xd               ;214
000022  d20f              BCS      |L8.68|
000024  e8dff001          TBB      [pc,r1]               ;214
000028  0f07199d          DCB      0x0f,0x07,0x19,0x9d
00002c  9d9d5770          DCB      0x9d,0x9d,0x57,0x70
000030  838b629d          DCB      0x83,0x8b,0x62,0x9d
000034  9000              DCB      0x90,0x00
000036  4628              MOV      r0,r5                 ;218
000038  f7fffffe          BL       HCD_ResetPort
00003c  2800              CMP      r0,#0                 ;218
00003e  d101              BNE      |L8.68|
000040  f8848000          STRB     r8,[r4,#0]            ;220
                  |L8.68|
000044  e08d              B        |L8.354|
000046  4628              MOV      r0,r5                 ;226
000048  f7fffffe          BL       HCD_IsDeviceConnected
00004c  2800              CMP      r0,#0                 ;226
00004e  d003              BEQ      |L8.88|
000050  4628              MOV      r0,r5                 ;229
000052  f7fffffe          BL       USBH_DeAllocate_AllChannel
000056  7027              STRB     r7,[r4,#0]            ;230
                  |L8.88|
000058  e083              B        |L8.354|
00005a  f8d40080          LDR      r0,[r4,#0x80]         ;236
00005e  6880              LDR      r0,[r0,#8]            ;236
000060  4780              BLX      r0                    ;236
000062  f8d504ac          LDR      r0,[r5,#0x4ac]        ;237
000066  4647              MOV      r7,r8                 ;237
000068  f8808009          STRB     r8,[r0,#9]            ;237
00006c  6831              LDR      r1,[r6,#0]            ;238
00006e  4628              MOV      r0,r5                 ;240
000070  f881900a          STRB     r9,[r1,#0xa]          ;238
000074  2100              MOVS     r1,#0                 ;240
000076  f7fffffe          BL       USBH_Alloc_Channel
00007a  7160              STRB     r0,[r4,#5]            ;240
00007c  2180              MOVS     r1,#0x80              ;241
00007e  4628              MOV      r0,r5                 ;241
000080  f7fffffe          BL       USBH_Alloc_Channel
000084  7120              STRB     r0,[r4,#4]            ;241
000086  4628              MOV      r0,r5                 ;244
000088  f7fffffe          BL       HCD_ResetPort
00008c  2800              CMP      r0,#0                 ;244
00008e  d168              BNE      |L8.354|
000090  1d24              ADDS     r4,r4,#4              ;244
000092  6fe0              LDR      r0,[r4,#0x7c]         ;246
000094  68c0              LDR      r0,[r0,#0xc]          ;246
000096  4780              BLX      r0                    ;246
000098  4628              MOV      r0,r5                 ;251
00009a  f7fffffe          BL       HCD_GetCurrentSpeed
00009e  b2c0              UXTB     r0,r0                 ;251
0000a0  7760              STRB     r0,[r4,#0x1d]         ;251
0000a2  2106              MOVS     r1,#6                 ;253
0000a4  f8041c04          STRB     r1,[r4,#-4]           ;253
0000a8  6fe1              LDR      r1,[r4,#0x7c]         ;254
0000aa  6989              LDR      r1,[r1,#0x18]         ;254
0000ac  4788              BLX      r1                    ;254
0000ae  78a0              LDRB     r0,[r4,#2]            ;257
0000b0  e9cd7000          STRD     r7,r0,[sp,#0]         ;257
0000b4  7f63              LDRB     r3,[r4,#0x1d]         ;257
0000b6  7f22              LDRB     r2,[r4,#0x1c]         ;257
0000b8  7821              LDRB     r1,[r4,#0]            ;257
0000ba  4628              MOV      r0,r5                 ;257
0000bc  f7fffffe          BL       USBH_Open_Channel
0000c0  78a0              LDRB     r0,[r4,#2]            ;265
0000c2  e9cd7000          STRD     r7,r0,[sp,#0]         ;265
0000c6  7f63              LDRB     r3,[r4,#0x1d]         ;265
0000c8  7f22              LDRB     r2,[r4,#0x1c]         ;265
0000ca  7861              LDRB     r1,[r4,#1]            ;265
0000cc  1f24              SUBS     r4,r4,#4              ;265
0000ce  4628              MOV      r0,r5                 ;265
0000d0  f7fffffe          BL       USBH_Open_Channel
0000d4  e045              B        |L8.354|
0000d6  4621              MOV      r1,r4                 ;276
0000d8  4628              MOV      r0,r5                 ;276
0000da  f7fffffe          BL       USBH_HandleEnum
0000de  b9f8              CBNZ     r0,|L8.288|
0000e0  f8d40080          LDR      r0,[r4,#0x80]         ;281
0000e4  6b40              LDR      r0,[r0,#0x34]         ;281
0000e6  4780              BLX      r0                    ;281
0000e8  200a              MOVS     r0,#0xa               ;283
0000ea  e018              B        |L8.286|
0000ec  f8d40080          LDR      r0,[r4,#0x80]         ;289
0000f0  6b80              LDR      r0,[r0,#0x38]         ;289
0000f2  4780              BLX      r0                    ;289
0000f4  2801              CMP      r0,#1                 ;289
0000f6  d134              BNE      |L8.354|
0000f8  6fe0              LDR      r0,[r4,#0x7c]         ;291
0000fa  4621              MOV      r1,r4                 ;291
0000fc  6802              LDR      r2,[r0,#0]            ;291
0000fe  4628              MOV      r0,r5                 ;291
000100  4790              BLX      r2                    ;291
000102  b968              CBNZ     r0,|L8.288|
000104  2007              MOVS     r0,#7                 ;294
000106  e00a              B        |L8.286|
000108  6fe0              LDR      r0,[r4,#0x7c]         ;301
00010a  4621              MOV      r1,r4                 ;301
00010c  6882              LDR      r2,[r0,#8]            ;301
00010e  4628              MOV      r0,r5                 ;301
000110  4790              BLX      r2                    ;301
000112  f88d0000          STRB     r0,[sp,#0]            ;301
000116  f89d0000          LDRB     r0,[sp,#0]            ;303
00011a  b910              CBNZ     r0,|L8.290|
00011c  2008              MOVS     r0,#8                 ;305
                  |L8.286|
00011e  7020              STRB     r0,[r4,#0]            ;305
                  |L8.288|
000120  e01f              B        |L8.354|
                  |L8.290|
000122  f89d1000          LDRB     r1,[sp,#0]            ;310
000126  4620              MOV      r0,r4                 ;310
000128  f7fffffe          BL       USBH_ErrorHandle
00012c  e019              B        |L8.354|
00012e  6fe0              LDR      r0,[r4,#0x7c]         ;317
000130  4621              MOV      r1,r4                 ;317
000132  68c2              LDR      r2,[r0,#0xc]          ;317
000134  4628              MOV      r0,r5                 ;317
000136  4790              BLX      r2                    ;317
000138  f88d0000          STRB     r0,[sp,#0]            ;317
00013c  e7f1              B        |L8.290|
00013e  4621              MOV      r1,r4                 ;323
000140  4628              MOV      r0,r5                 ;323
000142  f7fffffe          BL       USBH_HandleControl
000146  e00c              B        |L8.354|
000148  4621              MOV      r1,r4                 ;331
00014a  4628              MOV      r0,r5                 ;331
00014c  f7fffffe          BL       USBH_DeInit
000150  f8d40080          LDR      r0,[r4,#0x80]         ;332
000154  6840              LDR      r0,[r0,#4]            ;332
000156  4780              BLX      r0                    ;332
000158  6fe0              LDR      r0,[r4,#0x7c]
00015a  4651              MOV      r1,r10
00015c  6842              LDR      r2,[r0,#4]
00015e  4628              MOV      r0,r5
000160  4790              BLX      r2
                  |L8.354|
;;;334        break;
;;;335        
;;;336      default :
;;;337        break;
;;;338      }
;;;339      
;;;340      /* check device disconnection event */
;;;341       if (!(HCD_IsDeviceConnected(pdev)) && 
000162  4628              MOV      r0,r5
000164  f7fffffe          BL       HCD_IsDeviceConnected
000168  2800              CMP      r0,#0
00016a  d11c              BNE      |L8.422|
;;;342           (pdev->host.port_cb->DisconnHandled == 0))
00016c  f8d504ac          LDR      r0,[r5,#0x4ac]
000170  7ac0              LDRB     r0,[r0,#0xb]
000172  2800              CMP      r0,#0
000174  d117              BNE      |L8.422|
;;;343      { 
;;;344        /* Manage User disconnect operations*/
;;;345        phost->usr_cb->DeviceDisconnected();
000176  f8d40080          LDR      r0,[r4,#0x80]
00017a  6900              LDR      r0,[r0,#0x10]
00017c  4780              BLX      r0
;;;346        
;;;347        pdev->host.port_cb->DisconnHandled = 1; /* Handle to avoid the Re-entry*/
00017e  f8d514ac          LDR      r1,[r5,#0x4ac]
;;;348        
;;;349        /* Re-Initilaize Host for new Enumeration */
;;;350        USBH_DeInit(pdev, phost);
000182  4628              MOV      r0,r5
000184  f881900b          STRB     r9,[r1,#0xb]          ;347
000188  4621              MOV      r1,r4
00018a  f7fffffe          BL       USBH_DeInit
;;;351        phost->usr_cb->DeInit();
00018e  f8d40080          LDR      r0,[r4,#0x80]
000192  6840              LDR      r0,[r0,#4]
000194  4780              BLX      r0
;;;352        phost->class_cb->DeInit(pdev, &phost->device_prop);
000196  6fe0              LDR      r0,[r4,#0x7c]
000198  4651              MOV      r1,r10
00019a  6842              LDR      r2,[r0,#4]
00019c  b002              ADD      sp,sp,#8
00019e  4628              MOV      r0,r5
0001a0  e8bd47f0          POP      {r4-r10,lr}
0001a4  4710              BX       r2
                  |L8.422|
;;;353      }   
;;;354    }
0001a6  e8bd87fc          POP      {r2-r10,pc}
;;;355    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  timeout
000000  0000              DCW      0x0000
000002  0000              DCB      0x00,0x00
                  USBH_DeviceConnStatus_cb
                          DCD      USBH_Disconnect
                          DCD      USBH_Connect
00000c  00000000          DCB      0x00,0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "Libraries\\STM32_USB_HOST_Library\\usbh_core.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_usbh_core_c_acfce72c____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___11_usbh_core_c_acfce72c____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___11_usbh_core_c_acfce72c____REVSH|
#line 128
|__asm___11_usbh_core_c_acfce72c____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
