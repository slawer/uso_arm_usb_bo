; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\MEDIA_USB_KEY\stm32f4xx_it.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\MEDIA_USB_KEY\stm32f4xx_it.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\MEDIA_USB_KEY\stm32f4xx_it.crf src\stm32f4xx_it.c]
                          THUMB

                          AREA ||i.BusFault_Handler||, CODE, READONLY, ALIGN=1

                  BusFault_Handler PROC
                  |L1.0|
;;;128      */
;;;129    void BusFault_Handler(void)
000000  e7fe              B        |L1.0|
;;;130    {
;;;131      /* Go to infinite loop when Bus Fault exception occurs */
;;;132      while (1)
;;;133      {
;;;134      }
;;;135    }
;;;136    
                          ENDP


                          AREA ||i.DebugMon_Handler||, CODE, READONLY, ALIGN=1

                  DebugMon_Handler PROC
;;;163      */
;;;164    void DebugMon_Handler(void)
000000  4770              BX       lr
;;;165    {
;;;166    }
;;;167    
                          ENDP


                          AREA ||i.EXTI0_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI0_IRQHandler PROC
;;;436      */
;;;437    void EXTI0_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;438    {
;;;439      /* Checks whether the User Button EXTI line is asserted*/
;;;440      if (EXTI_GetITStatus(EXTI_Line0) != RESET) 
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       EXTI_GetITStatus
000008  b158              CBZ      r0,|L3.34|
;;;441      { 
;;;442        if (Command_index == 1)
00000a  4808              LDR      r0,|L3.44|
00000c  7803              LDRB     r3,[r0,#0]  ; Command_index
00000e  2100              MOVS     r1,#0
;;;443        {
;;;444          RepeatState = 0;
000010  4a07              LDR      r2,|L3.48|
000012  2b01              CMP      r3,#1                 ;442
000014  d001              BEQ      |L3.26|
;;;445          /* Switch to play command */
;;;446          Command_index = 0;
;;;447        }
;;;448        else if (Command_index == 0)
000016  7803              LDRB     r3,[r0,#0]  ; Command_index
000018  b10b              CBZ      r3,|L3.30|
                  |L3.26|
00001a  7011              STRB     r1,[r2,#0]            ;444
00001c  e000              B        |L3.32|
                  |L3.30|
;;;449        {
;;;450          /* Switch to record command */
;;;451          Command_index = 1;
00001e  2101              MOVS     r1,#1
                  |L3.32|
000020  7001              STRB     r1,[r0,#0]
                  |L3.34|
;;;452      //    XferCplt = 1;
;;;453      //    EVAL_AUDIO_Stop(CODEC_PDWN_SW);
;;;454        }
;;;455        else
;;;456        {
;;;457          RepeatState = 0;
;;;458          /* Switch to play command */
;;;459          Command_index = 0; 
;;;460        }
;;;461      } 
;;;462      /* Clears the EXTI's line pending bit.*/ 
;;;463      EXTI_ClearITPendingBit(EXTI_Line0);
000022  e8bd4010          POP      {r4,lr}
000026  2001              MOVS     r0,#1
000028  f7ffbffe          B.W      EXTI_ClearITPendingBit
;;;464    }
;;;465    
                          ENDP

                  |L3.44|
                          DCD      Command_index
                  |L3.48|
                          DCD      RepeatState

                          AREA ||i.EXTI1_IRQHandler||, CODE, READONLY, ALIGN=2

                  EXTI1_IRQHandler PROC
;;;352      */
;;;353    void EXTI1_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;354    {
;;;355      /* Check the clic on the accelerometer to Pause/Resume Playing */
;;;356      if(EXTI_GetITStatus(EXTI_Line1) != RESET)
000002  2002              MOVS     r0,#2
000004  f7fffffe          BL       EXTI_GetITStatus
000008  2800              CMP      r0,#0
00000a  d00f              BEQ      |L4.44|
;;;357      {
;;;358        if( Count==1)
00000c  4808              LDR      r0,|L4.48|
00000e  7843              LDRB     r3,[r0,#1]  ; Count
000010  2200              MOVS     r2,#0
;;;359        {
;;;360          PauseResumeStatus = 1;
000012  2101              MOVS     r1,#1
000014  2b01              CMP      r3,#1                 ;358
000016  d006              BEQ      |L4.38|
;;;361          Count = 0;
;;;362        }
;;;363        else
;;;364        {
;;;365          PauseResumeStatus = 0;
000018  7002              STRB     r2,[r0,#0]
;;;366          Count = 1;
00001a  7041              STRB     r1,[r0,#1]
                  |L4.28|
;;;367        }
;;;368        /* Clear the EXTI line 1 pending bit */
;;;369        EXTI_ClearITPendingBit(EXTI_Line1);
00001c  e8bd4010          POP      {r4,lr}
000020  2002              MOVS     r0,#2
000022  f7ffbffe          B.W      EXTI_ClearITPendingBit
                  |L4.38|
000026  7001              STRB     r1,[r0,#0]            ;360
000028  7042              STRB     r2,[r0,#1]            ;361
00002a  e7f7              B        |L4.28|
                  |L4.44|
;;;370      }
;;;371    }
00002c  bd10              POP      {r4,pc}
;;;372    
                          ENDP

00002e  0000              DCW      0x0000
                  |L4.48|
                          DCD      ||.data||

                          AREA ||i.HardFault_Handler||, CODE, READONLY, ALIGN=1

                  HardFault_Handler PROC
                  |L5.0|
;;;102      */
;;;103    void HardFault_Handler(void)
000000  e7fe              B        |L5.0|
;;;104    {
;;;105      /* Go to infinite loop when Hard Fault exception occurs */
;;;106      while (1)
;;;107      {
;;;108      }
;;;109    }
;;;110    
                          ENDP


                          AREA ||i.MemManage_Handler||, CODE, READONLY, ALIGN=1

                  MemManage_Handler PROC
                  |L6.0|
;;;115      */
;;;116    void MemManage_Handler(void)
000000  e7fe              B        |L6.0|
;;;117    {
;;;118      /* Go to infinite loop when Memory Manage exception occurs */
;;;119      while (1)
;;;120      {
;;;121      }
;;;122    }
;;;123    
                          ENDP


                          AREA ||i.NMI_Handler||, CODE, READONLY, ALIGN=1

                  NMI_Handler PROC
;;;72       */
;;;73     void NMI_Handler(void)
000000  b510              PUSH     {r4,lr}
;;;74     {
;;;75       /* This interrupt is generated when HSE clock fails */
;;;76     
;;;77       if (RCC_GetITStatus(RCC_IT_CSS) != RESET)
000002  2080              MOVS     r0,#0x80
000004  f7fffffe          BL       RCC_GetITStatus
000008  2800              CMP      r0,#0
00000a  d00b              BEQ      |L7.36|
;;;78       {
;;;79         /* At this stage: HSE, PLL are disabled (but no change on PLL config) and HSI
;;;80            is selected as system clock source */
;;;81     
;;;82         /* Enable HSE */
;;;83         RCC_HSEConfig(RCC_HSE_ON);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       RCC_HSEConfig
;;;84     
;;;85         /* Enable HSE Ready and PLL Ready interrupts */
;;;86         RCC_ITConfig(RCC_IT_HSERDY | RCC_IT_PLLRDY, ENABLE);
000012  2101              MOVS     r1,#1
000014  2018              MOVS     r0,#0x18
000016  f7fffffe          BL       RCC_ITConfig
;;;87     
;;;88         /* Clear Clock Security System interrupt pending bit */
;;;89         RCC_ClearITPendingBit(RCC_IT_CSS);
00001a  e8bd4010          POP      {r4,lr}
00001e  2080              MOVS     r0,#0x80
000020  f7ffbffe          B.W      RCC_ClearITPendingBit
                  |L7.36|
;;;90     
;;;91         /* Once HSE clock recover, the HSERDY interrupt is generated and in the RCC ISR
;;;92            routine the system clock will be reconfigured to its previous state (before
;;;93            HSE clock failure) */
;;;94       }
;;;95     }
000024  bd10              POP      {r4,pc}
;;;96     
                          ENDP


                          AREA ||i.OTG_FS_IRQHandler||, CODE, READONLY, ALIGN=2

                  OTG_FS_IRQHandler PROC
;;;482      */
;;;483    void OTG_FS_IRQHandler(void)
000000  4801              LDR      r0,|L8.8|
;;;484    {
;;;485      USBH_OTG_ISR_Handler(&USB_OTG_Core);
000002  f7ffbffe          B.W      USBH_OTG_ISR_Handler
;;;486    }
;;;487    #endif /* MEDIA_USB_KEY */
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      USB_OTG_Core

                          AREA ||i.PendSV_Handler||, CODE, READONLY, ALIGN=1

                  PendSV_Handler PROC
;;;172      */
;;;173    void PendSV_Handler(void)
000000  4770              BX       lr
;;;174    {
;;;175    }
;;;176    
                          ENDP


                          AREA ||i.RCC_IRQHandler||, CODE, READONLY, ALIGN=1

                  RCC_IRQHandler PROC
;;;503      */
;;;504    void RCC_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;505    {
;;;506      if(RCC_GetITStatus(RCC_IT_HSERDY) != RESET)
000002  2008              MOVS     r0,#8
000004  f7fffffe          BL       RCC_GetITStatus
000008  b148              CBZ      r0,|L10.30|
;;;507      { 
;;;508        /* Clear HSERDY interrupt pending bit */
;;;509        RCC_ClearITPendingBit(RCC_IT_HSERDY);
00000a  2008              MOVS     r0,#8
00000c  f7fffffe          BL       RCC_ClearITPendingBit
;;;510    
;;;511        /* Check if the HSE clock is still available */
;;;512        if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
000010  2031              MOVS     r0,#0x31
000012  f7fffffe          BL       RCC_GetFlagStatus
000016  b110              CBZ      r0,|L10.30|
;;;513        { 
;;;514          /* Enable PLL: once the PLL is ready the PLLRDY interrupt is generated */ 
;;;515          RCC_PLLCmd(ENABLE);     
000018  2001              MOVS     r0,#1
00001a  f7fffffe          BL       RCC_PLLCmd
                  |L10.30|
;;;516        }
;;;517      }
;;;518    
;;;519      if(RCC_GetITStatus(RCC_IT_PLLRDY) != RESET)
00001e  2010              MOVS     r0,#0x10
000020  f7fffffe          BL       RCC_GetITStatus
000024  2800              CMP      r0,#0
000026  d00c              BEQ      |L10.66|
;;;520      { 
;;;521        /* Clear PLLRDY interrupt pending bit */
;;;522        RCC_ClearITPendingBit(RCC_IT_PLLRDY);
000028  2010              MOVS     r0,#0x10
00002a  f7fffffe          BL       RCC_ClearITPendingBit
;;;523    
;;;524        /* Check if the PLL is still locked */
;;;525        if (RCC_GetFlagStatus(RCC_FLAG_PLLRDY) != RESET)
00002e  2039              MOVS     r0,#0x39
000030  f7fffffe          BL       RCC_GetFlagStatus
000034  2800              CMP      r0,#0
000036  d004              BEQ      |L10.66|
;;;526        { 
;;;527          /* Select PLL as system clock source */
;;;528          RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);
000038  e8bd4010          POP      {r4,lr}
00003c  2002              MOVS     r0,#2
00003e  f7ffbffe          B.W      RCC_SYSCLKConfig
                  |L10.66|
;;;529        }
;;;530      }
;;;531    }
000042  bd10              POP      {r4,pc}
;;;532    
                          ENDP


                          AREA ||i.SVC_Handler||, CODE, READONLY, ALIGN=1

                  SVC_Handler PROC
;;;154      */
;;;155    void SVC_Handler(void)
000000  4770              BX       lr
;;;156    {
;;;157    }
;;;158    
                          ENDP


                          AREA ||i.SysTick_Handler||, CODE, READONLY, ALIGN=2

                  SysTick_Handler PROC
;;;200      */
;;;201    void SysTick_Handler(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;202    {
;;;203    	extern __IO uint16_t ADC3ConvertedValue;
;;;204    	extern u32 tick;
;;;205    	
;;;206    	
;;;207    	
;;;208    	// раз в 10 мс
;;;209    	// находим среднее значение
;;;210    		summa[0]+=ADC3ConvertedValue;
000004  4a78              LDR      r2,|L12.488|
000006  4979              LDR      r1,|L12.492|
000008  8810              LDRH     r0,[r2,#0]  ; summa
00000a  8809              LDRH     r1,[r1,#0]  ; ADC3ConvertedValue
;;;211    
;;;212    	 
;;;213    //		summa[0]+=100;
;;;214    		kol_average++;
00000c  4b78              LDR      r3,|L12.496|
00000e  4408              ADD      r0,r0,r1              ;210
000010  b281              UXTH     r1,r0                 ;210
000012  8011              STRH     r1,[r2,#0]            ;210
000014  7818              LDRB     r0,[r3,#0]  ; kol_average
;;;215    	
;;;216    	if (kol_average==10)
;;;217    	{
;;;218    	
;;;219    		average[0]=summa[0]/kol_average;
;;;220    		kol_average=0;
;;;221    		summa[0]=0;
;;;222    		
;;;223    		
;;;224    
;;;225    		
;;;226    		// раз в 100 мс
;;;227    		// вычисляем физическую виличину 
;;;228    	
;;;229    		fz[0]=fiz_vel(average[0],0);
;;;230    	
;;;231    		// проверяем реле на срабатывание
;;;232    		test_rele(fz[0], 0);	
;;;233    	
;;;234    	// находим среднее значение по скользящей средней
;;;235    		fz_average[0]=moving_average(fz[0],0);
;;;236    		
;;;237    		if (fz_average[0]<max[0])
;;;238    			max[0]=fz_average[0];
;;;239    		
;;;240    		if (number_buff)
;;;241    			Buf_adc_zap2[por++]=por; //fz_average[0];			
;;;242    		else
;;;243    			Buf_adc_zap1[por++]=por; //fz_average[0];
;;;244    		
;;;245    		if (por==999)
;;;246    			por=999;
;;;247    	
;;;248    	del++;
;;;249    	if (del==10)
;;;250    	{
;;;251    		u16 tmp=0;
;;;252    		del=0;
;;;253    		tick++;
;;;254    		time_label=tick;
;;;255    
;;;256    		
;;;257    		rtc_Get(&DT1);
;;;258    		
;;;259    		USART_ITConfig(USART2, USART_IT_RXNE, DISABLE);		
;;;260    		tmp=por;
;;;261    		TxBuffer[0]=(uint8_t)(tmp/1000)+(uint8_t)0x30;
;;;262    		tmp%=1000;
;;;263    		TxBuffer[1]=(uint8_t)(tmp/100)+(uint8_t)0x30;
;;;264    		tmp%=100;		
;;;265    		TxBuffer[2]=(uint8_t)(tmp/10)+(uint8_t)0x30;
;;;266    		tmp%=10;	
;;;267    		TxBuffer[3]=(uint8_t)(tmp)+(uint8_t)0x30;		
;;;268    			
;;;269    		TxBuffer[4]=0x20;	
;;;270    		
;;;271    	
;;;272    		TxBuffer[5]=(uint8_t)(DT1.Minutes/10)+(uint8_t)0x30;	
;;;273    		TxBuffer[6]=(uint8_t)(DT1.Minutes%10)+(uint8_t)0x30;	
;;;274    		TxBuffer[7]=(uint8_t)(DT1.Seconds/10)+(uint8_t)0x30;	
;;;275    		TxBuffer[8]=(uint8_t)(DT1.Seconds%10)+(uint8_t)0x30;	
;;;276    		
;;;277    		
;;;278    		tmp=fz_average[0];
;;;279    		TxBuffer[9]=(uint8_t)(tmp/1000)+(uint8_t)0x30;
;;;280    		tmp%=1000;
;;;281    		TxBuffer[10]=(uint8_t)(tmp/100)+(uint8_t)0x30;
;;;282    		tmp%=100;		
;;;283    		TxBuffer[11]=(uint8_t)(tmp/10)+(uint8_t)0x30;
;;;284    		tmp%=10;	
;;;285    		TxBuffer[12]=(uint8_t)(tmp)+(uint8_t)0x30;		
;;;286    	//	GPIO_WriteBit(GPIOD, tx_pin_en, Bit_SET);      //   GPIOB.2
;;;287    	//	GPIO_WriteBit(GPIOD, rx_pin_en, Bit_RESET);    //   GPIOB.2
;;;288    		txsize=13;
;;;289    		tekper=0;
;;;290    		GPIO_WriteBit(GPIOD, rx_pin_en, Bit_SET); 
;;;291    		USART_SendData(USART2, 0x3A);
;;;292    		
;;;293    		if (DT1.Seconds==0)
;;;294    		{
;;;295    			number_buff^=1;
;;;296    			DT_zap=DT1;
000016  f8df91dc          LDR      r9,|L12.500|
00001a  1c40              ADDS     r0,r0,#1              ;214
00001c  b2c0              UXTB     r0,r0                 ;214
00001e  7018              STRB     r0,[r3,#0]            ;214
000020  280a              CMP      r0,#0xa               ;216
000022  d17c              BNE      |L12.286|
000024  fbb1f0f0          UDIV     r0,r1,r0              ;219
000028  4973              LDR      r1,|L12.504|
00002a  2400              MOVS     r4,#0                 ;220
00002c  f8dfb1d0          LDR      r11,|L12.512|
000030  8008              STRH     r0,[r1,#0]            ;219
000032  4972              LDR      r1,|L12.508|
000034  701c              STRB     r4,[r3,#0]            ;220
000036  8014              STRH     r4,[r2,#0]            ;221
000038  8008              STRH     r0,[r1,#0]            ;229
00003a  4972              LDR      r1,|L12.516|
00003c  f8ab0000          STRH     r0,[r11,#0]           ;235
000040  880a              LDRH     r2,[r1,#0]            ;237  ; max
000042  4290              CMP      r0,r2                 ;237
000044  d200              BCS      |L12.72|
000046  8008              STRH     r0,[r1,#0]            ;238
                  |L12.72|
000048  4d70              LDR      r5,|L12.524|
00004a  f8dfa1bc          LDR      r10,|L12.520|
00004e  8828              LDRH     r0,[r5,#0]            ;241
000050  f89a2000          LDRB     r2,[r10,#0]           ;240  ; number_buff
000054  1c41              ADDS     r1,r0,#1              ;241
000056  b289              UXTH     r1,r1                 ;241
000058  b10a              CBZ      r2,|L12.94|
00005a  4a6d              LDR      r2,|L12.528|
00005c  e000              B        |L12.96|
                  |L12.94|
00005e  4a6d              LDR      r2,|L12.532|
                  |L12.96|
000060  f8220010          STRH     r0,[r2,r0,LSL #1]     ;243
000064  8029              STRH     r1,[r5,#0]            ;243
000066  b289              UXTH     r1,r1                 ;245
000068  f24030e7          MOV      r0,#0x3e7             ;245
00006c  4281              CMP      r1,r0                 ;245
00006e  d100              BNE      |L12.114|
000070  8028              STRH     r0,[r5,#0]            ;246
                  |L12.114|
000072  4969              LDR      r1,|L12.536|
000074  8808              LDRH     r0,[r1,#0]            ;248  ; del
000076  1c40              ADDS     r0,r0,#1              ;248
000078  b280              UXTH     r0,r0                 ;248
00007a  8008              STRH     r0,[r1,#0]            ;248
00007c  280a              CMP      r0,#0xa               ;249
00007e  d17d              BNE      |L12.380|
000080  4e66              LDR      r6,|L12.540|
000082  800c              STRH     r4,[r1,#0]            ;252
000084  4966              LDR      r1,|L12.544|
000086  6830              LDR      r0,[r6,#0]            ;253  ; tick
000088  1c40              ADDS     r0,r0,#1              ;253
00008a  6030              STR      r0,[r6,#0]            ;254  ; tick
00008c  8008              STRH     r0,[r1,#0]            ;254
00008e  4859              LDR      r0,|L12.500|
000090  1d80              ADDS     r0,r0,#6              ;257
000092  f7fffffe          BL       rtc_Get
000096  2200              MOVS     r2,#0                 ;259
000098  f2405125          MOV      r1,#0x525             ;259
00009c  4861              LDR      r0,|L12.548|
00009e  f7fffffe          BL       USART_ITConfig
0000a2  485a              LDR      r0,|L12.524|
0000a4  f44f737a          MOV      r3,#0x3e8             ;261
0000a8  2764              MOVS     r7,#0x64              ;263
0000aa  8801              LDRH     r1,[r0,#0]            ;260  ; por
0000ac  485e              LDR      r0,|L12.552|
0000ae  fbb1f2f3          UDIV     r2,r1,r3              ;261
0000b2  f1020530          ADD      r5,r2,#0x30           ;261
0000b6  fb031112          MLS      r1,r3,r2,r1           ;262
0000ba  fbb1f2f7          UDIV     r2,r1,r7              ;263
0000be  7005              STRB     r5,[r0,#0]            ;261
0000c0  f1020530          ADD      r5,r2,#0x30           ;263
0000c4  fb071212          MLS      r2,r7,r2,r1           ;264
0000c8  7045              STRB     r5,[r0,#1]            ;263
0000ca  210a              MOVS     r1,#0xa               ;265
0000cc  fbb2f5f1          UDIV     r5,r2,r1              ;265
0000d0  fb012215          MLS      r2,r1,r5,r2           ;266
0000d4  f1050c30          ADD      r12,r5,#0x30          ;265
0000d8  f880c002          STRB     r12,[r0,#2]           ;265
0000dc  3230              ADDS     r2,r2,#0x30           ;267
0000de  4d45              LDR      r5,|L12.500|
0000e0  70c2              STRB     r2,[r0,#3]            ;267
0000e2  2220              MOVS     r2,#0x20              ;269
0000e4  1dad              ADDS     r5,r5,#6              ;272
0000e6  7102              STRB     r2,[r0,#4]            ;269
0000e8  f895c005          LDRB     r12,[r5,#5]           ;272  ; DT1
0000ec  fbbcf2f1          UDIV     r2,r12,r1             ;272
0000f0  f1020830          ADD      r8,r2,#0x30           ;272
0000f4  fb01c212          MLS      r2,r1,r2,r12          ;273
0000f8  f8808005          STRB     r8,[r0,#5]            ;272
0000fc  3230              ADDS     r2,r2,#0x30           ;273
0000fe  7182              STRB     r2,[r0,#6]            ;273
000100  f895c006          LDRB     r12,[r5,#6]           ;274  ; DT1
000104  fbbcf2f1          UDIV     r2,r12,r1             ;274
000108  f1020830          ADD      r8,r2,#0x30           ;274
00010c  fb01c212          MLS      r2,r1,r2,r12          ;275
000110  f8808007          STRB     r8,[r0,#7]            ;274
000114  3230              ADDS     r2,r2,#0x30           ;275
000116  7202              STRB     r2,[r0,#8]            ;275
000118  f8bb2000          LDRH     r2,[r11,#0]           ;278  ; fz_average
00011c  e000              B        |L12.288|
                  |L12.286|
00011e  e057              B        |L12.464|
                  |L12.288|
000120  fbb2fcf3          UDIV     r12,r2,r3             ;279
000124  fb03221c          MLS      r2,r3,r12,r2          ;280
000128  fbb2f3f7          UDIV     r3,r2,r7              ;281
00012c  f10c0830          ADD      r8,r12,#0x30          ;279
000130  f1030c30          ADD      r12,r3,#0x30          ;281
000134  fb072213          MLS      r2,r7,r3,r2           ;282
000138  fbb2f3f1          UDIV     r3,r2,r1              ;283
00013c  f8808009          STRB     r8,[r0,#9]            ;279
000140  fb012113          MLS      r1,r1,r3,r2           ;284
000144  f880c00a          STRB     r12,[r0,#0xa]         ;281
000148  f1030730          ADD      r7,r3,#0x30           ;283
00014c  72c7              STRB     r7,[r0,#0xb]          ;283
00014e  3130              ADDS     r1,r1,#0x30           ;285
000150  7301              STRB     r1,[r0,#0xc]          ;285
000152  4936              LDR      r1,|L12.556|
000154  200d              MOVS     r0,#0xd               ;288
000156  2201              MOVS     r2,#1                 ;290
000158  7008              STRB     r0,[r1,#0]            ;288
00015a  4835              LDR      r0,|L12.560|
00015c  2108              MOVS     r1,#8                 ;290
00015e  7004              STRB     r4,[r0,#0]            ;289
000160  4834              LDR      r0,|L12.564|
000162  f7fffffe          BL       GPIO_WriteBit
000166  213a              MOVS     r1,#0x3a              ;291
000168  482e              LDR      r0,|L12.548|
00016a  f7fffffe          BL       USART_SendData
00016e  79a9              LDRB     r1,[r5,#6]            ;293  ; DT1
000170  b9a1              CBNZ     r1,|L12.412|
000172  f89a2000          LDRB     r2,[r10,#0]           ;295  ; number_buff
000176  f0820201          EOR      r2,r2,#1              ;295
00017a  e000              B        |L12.382|
                  |L12.380|
00017c  e024              B        |L12.456|
                  |L12.382|
00017e  482e              LDR      r0,|L12.568|
000180  f88a2000          STRB     r2,[r10,#0]           ;295
000184  f8d93006          LDR      r3,[r9,#6]  ; DT1
000188  6003              STR      r3,[r0,#0]  ; DT_zap
00018a  f8b9200a          LDRH     r2,[r9,#0xa]  ; DT1
00018e  8082              STRH     r2,[r0,#4]
000190  7181              STRB     r1,[r0,#6]
;;;297    			
;;;298    			buffering=1;
000192  492a              LDR      r1,|L12.572|
000194  2001              MOVS     r0,#1
000196  7008              STRB     r0,[r1,#0]
;;;299    			por=0;
000198  481c              LDR      r0,|L12.524|
00019a  8004              STRH     r4,[r0,#0]
                  |L12.412|
;;;300    		}
;;;301    			
;;;302    	 if (tick%2==0)
00019c  7830              LDRB     r0,[r6,#0]  ; tick
00019e  07c0              LSLS     r0,r0,#31
;;;303    	 {
;;;304    		 STM_EVAL_LEDOn(LED3);
;;;305    	 }
;;;306    	 else
;;;307    		 STM_EVAL_LEDOff(LED3);		
0001a0  f04f0001          MOV      r0,#1
0001a4  d009              BEQ      |L12.442|
0001a6  f7fffffe          BL       STM_EVAL_LEDOff
                  |L12.426|
;;;308    		
;;;309    	if ((tick%60)==0)
0001aa  6830              LDR      r0,[r6,#0]  ; tick
0001ac  213c              MOVS     r1,#0x3c
0001ae  fbb0f2f1          UDIV     r2,r0,r1
0001b2  fb010012          MLS      r0,r1,r2,r0
0001b6  b118              CBZ      r0,|L12.448|
0001b8  e006              B        |L12.456|
                  |L12.442|
0001ba  f7fffffe          BL       STM_EVAL_LEDOn
0001be  e7f4              B        |L12.426|
                  |L12.448|
;;;310    	{
;;;311    		minute++;
0001c0  491f              LDR      r1,|L12.576|
0001c2  8808              LDRH     r0,[r1,#0]  ; minute
0001c4  1c40              ADDS     r0,r0,#1
0001c6  8008              STRH     r0,[r1,#0]
                  |L12.456|
;;;312    	}
;;;313    	}
;;;314    	
;;;315    	
;;;316    	if (new_komand)
0001c8  481e              LDR      r0,|L12.580|
0001ca  7801              LDRB     r1,[r0,#0]  ; new_komand
0001cc  b101              CBZ      r1,|L12.464|
;;;317    	{
;;;318    	//	RxBuffer[tekpr];
;;;319    		
;;;320    		
;;;321    		new_komand=0;
0001ce  7004              STRB     r4,[r0,#0]
                  |L12.464|
;;;322    	}
;;;323    				
;;;324    	}
;;;325    
;;;326    	
;;;327    
;;;328    
;;;329    	
;;;330    
;;;331    	
;;;332     // TimingDelay_Decrement();
;;;333    #if defined MEDIA_USB_KEY
;;;334      if ( Command_index == 1)
0001d0  481d              LDR      r0,|L12.584|
0001d2  7800              LDRB     r0,[r0,#0]  ; Command_index
0001d4  2801              CMP      r0,#1
0001d6  d104              BNE      |L12.482|
;;;335      {
;;;336        Time_Rec_Base ++;
0001d8  f8b90004          LDRH     r0,[r9,#4]  ; Time_Rec_Base
0001dc  1c40              ADDS     r0,r0,#1
0001de  f8a90004          STRH     r0,[r9,#4]
                  |L12.482|
;;;337      }
;;;338    #endif
;;;339    }
0001e2  e8bd9ff0          POP      {r4-r12,pc}
;;;340    
                          ENDP

0001e6  0000              DCW      0x0000
                  |L12.488|
                          DCD      summa
                  |L12.492|
                          DCD      ADC3ConvertedValue
                  |L12.496|
                          DCD      kol_average
                  |L12.500|
                          DCD      ||.data||
                  |L12.504|
                          DCD      average
                  |L12.508|
                          DCD      ||fz||
                  |L12.512|
                          DCD      fz_average
                  |L12.516|
                          DCD      max
                  |L12.520|
                          DCD      number_buff
                  |L12.524|
                          DCD      por
                  |L12.528|
                          DCD      Buf_adc_zap2
                  |L12.532|
                          DCD      Buf_adc_zap1
                  |L12.536|
                          DCD      ||del||
                  |L12.540|
                          DCD      tick
                  |L12.544|
                          DCD      time_label
                  |L12.548|
                          DCD      0x40004400
                  |L12.552|
                          DCD      TxBuffer
                  |L12.556|
                          DCD      txsize
                  |L12.560|
                          DCD      tekper
                  |L12.564|
                          DCD      0x40020c00
                  |L12.568|
                          DCD      DT_zap
                  |L12.572|
                          DCD      buffering
                  |L12.576|
                          DCD      minute
                  |L12.580|
                          DCD      new_komand
                  |L12.584|
                          DCD      Command_index

                          AREA ||i.TIM2_IRQHandler||, CODE, READONLY, ALIGN=1

                  TIM2_IRQHandler PROC
;;;471      */
;;;472    void TIM2_IRQHandler(void)
000000  f7ffbffe          B.W      USB_OTG_BSP_TimerIRQ
;;;473    {
;;;474      USB_OTG_BSP_TimerIRQ();
;;;475    }
;;;476    
                          ENDP


                          AREA ||i.TIM4_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM4_IRQHandler PROC
;;;377      */
;;;378    void TIM4_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;379    {
;;;380       uint8_t clickreg = 0;
;;;381    
;;;382    	
;;;383      /* Checks whether the TIM interrupt has occurred */
;;;384      if (TIM_GetITStatus(TIM4, TIM_IT_CC1) != RESET)
000002  4c0d              LDR      r4,|L14.56|
000004  2102              MOVS     r1,#2
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       TIM_GetITStatus
00000c  2800              CMP      r0,#0
00000e  d011              BEQ      |L14.52|
;;;385      {
;;;386        TIM_ClearITPendingBit(TIM4, TIM_IT_CC1);
000010  2102              MOVS     r1,#2
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       TIM_ClearITPendingBit
;;;387    		/*
;;;388        if( LED_Toggle == 3)
;;;389        {
;;;390          // LED3 Orange toggling 
;;;391          STM_EVAL_LEDToggle(LED3);
;;;392          STM_EVAL_LEDOff(LED6);
;;;393          STM_EVAL_LEDOff(LED4);
;;;394        }
;;;395        else if( LED_Toggle == 4)
;;;396        {
;;;397          // LED4 Green toggling 
;;;398          STM_EVAL_LEDToggle(LED4);
;;;399          STM_EVAL_LEDOff(LED6);
;;;400          STM_EVAL_LEDOff(LED3);
;;;401        }
;;;402        else if( LED_Toggle == 6)
;;;403        {
;;;404          // LED6 Blue toggling 
;;;405          STM_EVAL_LEDOff(LED3);
;;;406          STM_EVAL_LEDOff(LED4);
;;;407          STM_EVAL_LEDToggle(LED6);
;;;408        }
;;;409        else if (LED_Toggle ==0)
;;;410        {
;;;411          // LED6 Blue On to signal Pause 
;;;412          STM_EVAL_LEDOn(LED6);
;;;413        }
;;;414        else if (LED_Toggle == 7)
;;;415        {
;;;416          // LED4 toggling with frequency = 439.4 Hz 
;;;417          STM_EVAL_LEDOff(LED3);
;;;418          STM_EVAL_LEDOff(LED4);
;;;419          STM_EVAL_LEDOff(LED5);
;;;420          STM_EVAL_LEDOff(LED6);
;;;421        }
;;;422    		*/
;;;423    	
;;;424    
;;;425        capture = TIM_GetCapture1(TIM4);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       TIM_GetCapture1
00001e  b281              UXTH     r1,r0
000020  4806              LDR      r0,|L14.60|
000022  8041              STRH     r1,[r0,#2]
;;;426        TIM_SetCompare1(TIM4, capture + CCR_Val);
000024  4806              LDR      r0,|L14.64|
000026  8800              LDRH     r0,[r0,#0]  ; CCR_Val
000028  4401              ADD      r1,r1,r0
00002a  4620              MOV      r0,r4
00002c  e8bd4010          POP      {r4,lr}
000030  f7ffbffe          B.W      TIM_SetCompare1
                  |L14.52|
;;;427      }
;;;428    }
000034  bd10              POP      {r4,pc}
;;;429    
                          ENDP

000036  0000              DCW      0x0000
                  |L14.56|
                          DCD      0x40000800
                  |L14.60|
                          DCD      ||.data||
                  |L14.64|
                          DCD      CCR_Val

                          AREA ||i.UsageFault_Handler||, CODE, READONLY, ALIGN=1

                  UsageFault_Handler PROC
                  |L15.0|
;;;141      */
;;;142    void UsageFault_Handler(void)
000000  e7fe              B        |L15.0|
;;;143    {
;;;144      /* Go to infinite loop when Usage Fault exception occurs */
;;;145      while (1)
;;;146      {
;;;147      }
;;;148    }
;;;149    
                          ENDP


                          AREA ||i.fiz_vel||, CODE, READONLY, ALIGN=1

                  fiz_vel PROC
;;;176    
;;;177    u16 fiz_vel(u16 kod, u8 numb)
000000  4770              BX       lr
;;;178    {
;;;179    	
;;;180    //	tab_kal
;;;181    	
;;;182    return kod;
;;;183    }
;;;184    
                          ENDP


                          AREA ||i.moving_average||, CODE, READONLY, ALIGN=1

                  moving_average PROC
;;;185    
;;;186    u16 moving_average(u16 kod, u8 numb)
000000  4770              BX       lr
;;;187    {
;;;188    return kod;
;;;189    }
;;;190    
                          ENDP


                          AREA ||i.test_rele||, CODE, READONLY, ALIGN=1

                  test_rele PROC
;;;190    
;;;191    u8 test_rele(u16 kod, u8 numb)
000000  2000              MOVS     r0,#0
;;;192    {
;;;193    return 0;
;;;194    }
000002  4770              BX       lr
;;;195    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=1

                  PauseResumeStatus
000000  02                DCB      0x02
                  Count
000001  00                DCB      0x00
                  capture
000002  0000              DCW      0x0000
                  Time_Rec_Base
000004  0000              DCW      0x0000
                  ||DT1||
000006  0000              DCB      0x00,0x00
                          DCDU     0x00000000
00000c  00                DCB      0x00

                          AREA ||area_number.22||, DATA, ALIGN=0

                          EXPORTAS ||area_number.22||, ||.data||
                  LED_Toggle
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "src\\stm32f4xx_it.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___14_stm32f4xx_it_c_ad5fdb9f____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___14_stm32f4xx_it_c_ad5fdb9f____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___14_stm32f4xx_it_c_ad5fdb9f____REVSH|
#line 128
|__asm___14_stm32f4xx_it_c_ad5fdb9f____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
