; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\MEDIA_USB_KEY\usb_core.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\MEDIA_USB_KEY\usb_core.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\MEDIA_USB_KEY\usb_core.crf Libraries\STM32_USB_OTG_Driver\usb_core.c]
                          THUMB

                          AREA ||i.USB_OTG_CoreInit||, CODE, READONLY, ALIGN=1

                  USB_OTG_CoreInit PROC
;;;320    */
;;;321    USB_OTG_STS USB_OTG_CoreInit(USB_OTG_CORE_HANDLE *pdev)
000000  b570              PUSH     {r4-r6,lr}
;;;322    {
000002  4604              MOV      r4,r0
;;;323      USB_OTG_STS status = USB_OTG_OK;
;;;324      USB_OTG_GUSBCFG_TypeDef  usbcfg;
;;;325      USB_OTG_GCCFG_TypeDef    gccfg;
;;;326      USB_OTG_GI2CCTL_TypeDef  i2cctl;
;;;327      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;328      
;;;329      usbcfg.d32 = 0;
;;;330      gccfg.d32 = 0;
;;;331      ahbcfg.d32 = 0;
;;;332      
;;;333    
;;;334      
;;;335      if (pdev->cfg.phy_itface == USB_OTG_ULPI_PHY)
000004  7a01              LDRB     r1,[r0,#8]
000006  2500              MOVS     r5,#0                 ;323
;;;336      {
;;;337        gccfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GCCFG);
000008  68c0              LDR      r0,[r0,#0xc]
00000a  2901              CMP      r1,#1                 ;335
00000c  d00c              BEQ      |L1.40|
;;;338        gccfg.b.pwdn = 0;
;;;339        
;;;340        if (pdev->cfg.Sof_output)
;;;341        {
;;;342          gccfg.b.sofouten = 1;   
;;;343        }
;;;344        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
;;;345        
;;;346        /* Init The ULPI Interface */
;;;347        usbcfg.d32 = 0;
;;;348        usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
;;;349        
;;;350        usbcfg.b.physel            = 0; /* HS Interface */
;;;351    #ifdef USB_OTG_INTERNAL_VBUS_ENABLED
;;;352        usbcfg.b.ulpi_ext_vbus_drv = 0; /* Use internal VBUS */
;;;353    #else
;;;354     #ifdef USB_OTG_EXTERNAL_VBUS_ENABLED    
;;;355        usbcfg.b.ulpi_ext_vbus_drv = 1; /* Use external VBUS */
;;;356     #endif
;;;357    #endif 
;;;358        usbcfg.b.term_sel_dl_pulse = 0; /* Data line pulsing using utmi_txvalid */    
;;;359        usbcfg.b.ulpi_utmi_sel     = 1; /* ULPI seleInterfacect */
;;;360        
;;;361        usbcfg.b.phyif             = 0; /* 8 bits */
;;;362        usbcfg.b.ddrsel            = 0; /* single data rate */
;;;363        
;;;364        usbcfg.b.ulpi_fsls = 0;
;;;365        usbcfg.b.ulpi_clk_sus_m = 0;
;;;366        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
;;;367        
;;;368        /* Reset after a PHY select  */
;;;369        USB_OTG_CoreReset(pdev);
;;;370        
;;;371        if(pdev->cfg.dma_enable == 1)
;;;372        {
;;;373          
;;;374          ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
;;;375          ahbcfg.b.dmaenable = 1;
;;;376          USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
;;;377          
;;;378        }    
;;;379      }
;;;380      else /* FS interface (embedded Phy or I2C Phy) */
;;;381      {
;;;382        
;;;383        usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);;
00000e  68c1              LDR      r1,[r0,#0xc]
;;;384        usbcfg.b.physel  = 1; /* FS Interface */
000010  f0410140          ORR      r1,r1,#0x40
;;;385        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
000014  60c1              STR      r1,[r0,#0xc]
;;;386        /* Reset after a PHY select and set Host mode */
;;;387        USB_OTG_CoreReset(pdev);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       USB_OTG_CoreReset
;;;388        /* Enable the I2C interface and deactivate the power down*/
;;;389        gccfg.d32 = 0;
;;;390        gccfg.b.pwdn = 1;
;;;391        
;;;392        if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
00001c  7a21              LDRB     r1,[r4,#8]
00001e  f44f3080          MOV      r0,#0x10000           ;390
000022  2903              CMP      r1,#3
000024  d01d              BEQ      |L1.98|
000026  e01e              B        |L1.102|
                  |L1.40|
000028  6b81              LDR      r1,[r0,#0x38]         ;337
00002a  7a62              LDRB     r2,[r4,#9]            ;340
00002c  f4213180          BIC      r1,r1,#0x10000        ;338
000030  b10a              CBZ      r2,|L1.54|
000032  f4411180          ORR      r1,r1,#0x100000       ;342
                  |L1.54|
000036  6381              STR      r1,[r0,#0x38]         ;344
000038  68e0              LDR      r0,[r4,#0xc]          ;348
00003a  68c1              LDR      r1,[r0,#0xc]          ;348
00003c  f0211140          BIC      r1,r1,#0x400040       ;358
000040  f0210188          BIC      r1,r1,#0x88           ;361
000044  f4212120          BIC      r1,r1,#0xa0000        ;364
000048  f0410110          ORR      r1,r1,#0x10           ;365
00004c  60c1              STR      r1,[r0,#0xc]          ;366
00004e  4620              MOV      r0,r4                 ;369
000050  f7fffffe          BL       USB_OTG_CoreReset
000054  78e0              LDRB     r0,[r4,#3]            ;371
000056  2801              CMP      r0,#1                 ;371
000058  d13d              BNE      |L1.214|
00005a  68e1              LDR      r1,[r4,#0xc]          ;376
00005c  202a              MOVS     r0,#0x2a              ;375
00005e  6088              STR      r0,[r1,#8]            ;376
000060  e02e              B        |L1.192|
                  |L1.98|
;;;393        {
;;;394          gccfg.b.i2cifen = 1;
000062  f44f3040          MOV      r0,#0x30000
                  |L1.102|
;;;395        }   
;;;396        gccfg.b.vbussensingA = 1 ;
;;;397        gccfg.b.vbussensingB = 1 ;     
;;;398    #ifndef VBUS_SENSING_ENABLED
;;;399        gccfg.b.disablevbussensing = 1; 
;;;400    #endif    
;;;401        
;;;402        if(pdev->cfg.Sof_output)
000066  7a61              LDRB     r1,[r4,#9]
000068  f4401030          ORR      r0,r0,#0x2c0000       ;396
00006c  b109              CBZ      r1,|L1.114|
;;;403        {
;;;404          gccfg.b.sofouten = 1;  
00006e  f4401080          ORR      r0,r0,#0x100000
                  |L1.114|
;;;405        }
;;;406        
;;;407        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GCCFG, gccfg.d32);
000072  68e1              LDR      r1,[r4,#0xc]
000074  6388              STR      r0,[r1,#0x38]
;;;408        USB_OTG_BSP_mDelay(20);
000076  2014              MOVS     r0,#0x14
000078  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;409        /* Program GUSBCFG.OtgUtmifsSel to I2C*/
;;;410        usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
00007c  68e1              LDR      r1,[r4,#0xc]
00007e  68c8              LDR      r0,[r1,#0xc]
;;;411        
;;;412        if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
000080  7a22              LDRB     r2,[r4,#8]
000082  2a03              CMP      r2,#3
000084  d101              BNE      |L1.138|
;;;413        {
;;;414          usbcfg.b.otgutmifssel = 1;
000086  f4403080          ORR      r0,r0,#0x10000
                  |L1.138|
;;;415        }
;;;416        
;;;417        USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
00008a  60c8              STR      r0,[r1,#0xc]
;;;418        
;;;419        if(pdev->cfg.phy_itface == USB_OTG_I2C_PHY)
00008c  7a20              LDRB     r0,[r4,#8]
00008e  2803              CMP      r0,#3
000090  d116              BNE      |L1.192|
;;;420        {
;;;421          /*Program GI2CCTL.I2CEn*/
;;;422          i2cctl.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GI2CCTL);
000092  68e0              LDR      r0,[r4,#0xc]
000094  6b01              LDR      r1,[r0,#0x30]
;;;423          i2cctl.b.i2cdevaddr = 1;
000096  f0216140          BIC      r1,r1,#0xc000000
00009a  f1016180          ADD      r1,r1,#0x4000000
;;;424          i2cctl.b.i2cen = 0;
;;;425          i2cctl.b.dat_se0 = 1;
00009e  f421017f          BIC      r1,r1,#0xff0000
;;;426          i2cctl.b.addr = 0x2D;
0000a2  f0415680          ORR      r6,r1,#0x10000000
0000a6  f5061634          ADD      r6,r6,#0x2d0000
;;;427          USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
0000aa  6306              STR      r6,[r0,#0x30]
;;;428          
;;;429          USB_OTG_BSP_mDelay(200);
0000ac  20c8              MOVS     r0,#0xc8
0000ae  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;430          
;;;431          i2cctl.b.i2cen = 1;
;;;432          USB_OTG_WRITE_REG32 (&pdev->regs.GREGS->GI2CCTL, i2cctl.d32);
0000b2  68e1              LDR      r1,[r4,#0xc]
0000b4  f4460000          ORR      r0,r6,#0x800000       ;431
0000b8  6308              STR      r0,[r1,#0x30]
;;;433          USB_OTG_BSP_mDelay(200);
0000ba  20c8              MOVS     r0,#0xc8
0000bc  f7fffffe          BL       USB_OTG_BSP_mDelay
                  |L1.192|
;;;434        }
;;;435      }
;;;436      /* case the HS core is working in FS mode */
;;;437      if(pdev->cfg.dma_enable == 1)
0000c0  78e0              LDRB     r0,[r4,#3]
0000c2  2801              CMP      r0,#1
0000c4  d107              BNE      |L1.214|
;;;438      {
;;;439        
;;;440        ahbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GAHBCFG);
0000c6  68e0              LDR      r0,[r4,#0xc]
0000c8  6881              LDR      r1,[r0,#8]
;;;441        ahbcfg.b.hburstlen = 5; /* 64 x 32-bits*/
0000ca  f021011e          BIC      r1,r1,#0x1e
0000ce  310a              ADDS     r1,r1,#0xa
;;;442        ahbcfg.b.dmaenable = 1;
0000d0  f0410120          ORR      r1,r1,#0x20
;;;443        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32);
0000d4  6081              STR      r1,[r0,#8]
                  |L1.214|
;;;444        
;;;445      }
;;;446      /* initialize OTG features */
;;;447    #ifdef  USE_OTG_MODE
;;;448      usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
;;;449      usbcfg.b.hnpcap = 1;
;;;450      usbcfg.b.srpcap = 1;
;;;451      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
;;;452      USB_OTG_EnableCommonInt(pdev);
;;;453    #endif
;;;454      return status;
0000d6  4628              MOV      r0,r5
;;;455    }
0000d8  bd70              POP      {r4-r6,pc}
;;;456    /**
                          ENDP


                          AREA ||i.USB_OTG_CoreInitHost||, CODE, READONLY, ALIGN=1

                  USB_OTG_CoreInitHost PROC
;;;644    */
;;;645    USB_OTG_STS USB_OTG_CoreInitHost(USB_OTG_CORE_HANDLE *pdev)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;646    {
;;;647      USB_OTG_STS                     status = USB_OTG_OK;
000004  2700              MOVS     r7,#0
000006  4604              MOV      r4,r0                 ;646
;;;648      USB_OTG_FSIZ_TypeDef            nptxfifosize;
;;;649      USB_OTG_FSIZ_TypeDef            ptxfifosize;  
;;;650      USB_OTG_HCFG_TypeDef            hcfg;
;;;651      
;;;652    #ifdef USE_OTG_MODE
;;;653      USB_OTG_OTGCTL_TypeDef          gotgctl;
;;;654    #endif
;;;655      
;;;656      uint32_t                        i = 0;
000008  463d              MOV      r5,r7
;;;657      
;;;658      nptxfifosize.d32 = 0;  
00000a  463e              MOV      r6,r7
;;;659      ptxfifosize.d32 = 0;
;;;660    #ifdef USE_OTG_MODE
;;;661      gotgctl.d32 = 0;
;;;662    #endif
;;;663      hcfg.d32 = 0;
;;;664      
;;;665      
;;;666      /* configure charge pump IO */
;;;667      USB_OTG_BSP_ConfigVBUS(pdev);
00000c  f7fffffe          BL       USB_OTG_BSP_ConfigVBUS
;;;668      
;;;669      /* Restart the Phy Clock */
;;;670      USB_OTG_WRITE_REG32(pdev->regs.PCGCCTL, 0);
000010  f8d4010c          LDR      r0,[r4,#0x10c]
000014  6006              STR      r6,[r0,#0]
;;;671      
;;;672      /* Initialize Host Configuration Register */
;;;673      USB_OTG_InitFSLSPClkSel(pdev , HCFG_48_MHZ); /* in init phase */
000016  2101              MOVS     r1,#1
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       USB_OTG_InitFSLSPClkSel
;;;674      
;;;675      hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
00001e  6960              LDR      r0,[r4,#0x14]
000020  6801              LDR      r1,[r0,#0]
;;;676      hcfg.b.fslssupp = 0;
000022  f0210104          BIC      r1,r1,#4
;;;677      USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
000026  6001              STR      r1,[r0,#0]
;;;678      
;;;679      /* Configure data FIFO sizes */
;;;680      /* Rx FIFO */
;;;681    #ifdef USB_OTG_FS_CORE
;;;682      if(pdev->cfg.coreID == USB_OTG_FS_CORE_ID)
000028  7ae0              LDRB     r0,[r4,#0xb]
00002a  2801              CMP      r0,#1
00002c  d113              BNE      |L2.86|
;;;683      {
;;;684        /* set Rx FIFO size */
;;;685        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_FS_SIZE);
00002e  68e0              LDR      r0,[r4,#0xc]
000030  2180              MOVS     r1,#0x80
000032  6241              STR      r1,[r0,#0x24]
;;;686        nptxfifosize.b.startaddr = RX_FIFO_FS_SIZE;   
000034  4630              MOV      r0,r6
000036  f361000f          BFI      r0,r1,#0,#16
;;;687        nptxfifosize.b.depth = TXH_NP_FS_FIFOSIZ;  
;;;688        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
00003a  68e2              LDR      r2,[r4,#0xc]
00003c  2160              MOVS     r1,#0x60              ;687
00003e  f361401f          BFI      r0,r1,#16,#16         ;687
000042  6290              STR      r0,[r2,#0x28]
;;;689        
;;;690        ptxfifosize.b.startaddr = RX_FIFO_FS_SIZE + TXH_NP_FS_FIFOSIZ;
000044  22e0              MOVS     r2,#0xe0
000046  4630              MOV      r0,r6
000048  f362000f          BFI      r0,r2,#0,#16
00004c  f361401f          BFI      r0,r1,#16,#16
;;;691        ptxfifosize.b.depth     = TXH_P_FS_FIFOSIZ;
;;;692        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
000050  68e1              LDR      r1,[r4,#0xc]
000052  f8c10100          STR      r0,[r1,#0x100]
                  |L2.86|
;;;693      }
;;;694    #endif
;;;695    #ifdef USB_OTG_HS_CORE  
;;;696       if (pdev->cfg.coreID == USB_OTG_HS_CORE_ID)
;;;697      {
;;;698       /* set Rx FIFO size */
;;;699        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRXFSIZ, RX_FIFO_HS_SIZE);
;;;700        nptxfifosize.b.startaddr = RX_FIFO_HS_SIZE;   
;;;701        nptxfifosize.b.depth = TXH_NP_HS_FIFOSIZ;  
;;;702        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->DIEPTXF0_HNPTXFSIZ, nptxfifosize.d32);
;;;703        
;;;704        ptxfifosize.b.startaddr = RX_FIFO_HS_SIZE + TXH_NP_HS_FIFOSIZ;
;;;705        ptxfifosize.b.depth     = TXH_P_HS_FIFOSIZ;
;;;706        USB_OTG_WRITE_REG32(&pdev->regs.GREGS->HPTXFSIZ, ptxfifosize.d32);      
;;;707      }
;;;708    #endif  
;;;709      
;;;710    #ifdef USE_OTG_MODE
;;;711      /* Clear Host Set HNP Enable in the USB_OTG Control Register */
;;;712      gotgctl.b.hstsethnpen = 1;
;;;713      USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GOTGCTL, gotgctl.d32, 0);
;;;714    #endif
;;;715      
;;;716      /* Make sure the FIFOs are flushed. */
;;;717      USB_OTG_FlushTxFifo(pdev, 0x10 );         /* all Tx FIFOs */
000056  2110              MOVS     r1,#0x10
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       USB_OTG_FlushTxFifo
;;;718      USB_OTG_FlushRxFifo(pdev);
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       USB_OTG_FlushRxFifo
;;;719      
;;;720      
;;;721      /* Clear all pending HC Interrupts */
;;;722      for (i = 0; i < pdev->cfg.host_channels; i++)
;;;723      {
;;;724        USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCINT, 0xFFFFFFFF );
000064  f04f31ff          MOV      r1,#0xffffffff
000068  e007              B        |L2.122|
                  |L2.106|
00006a  eb040085          ADD      r0,r4,r5,LSL #2
00006e  f8502f90          LDR      r2,[r0,#0x90]!
000072  6091              STR      r1,[r2,#8]
;;;725        USB_OTG_WRITE_REG32( &pdev->regs.HC_REGS[i]->HCGINTMSK, 0 );
000074  6800              LDR      r0,[r0,#0]
000076  60c6              STR      r6,[r0,#0xc]
000078  1c6d              ADDS     r5,r5,#1              ;722
                  |L2.122|
00007a  7820              LDRB     r0,[r4,#0]            ;722
00007c  42a8              CMP      r0,r5                 ;722
00007e  d8f4              BHI      |L2.106|
;;;726      }
;;;727    #ifndef USE_OTG_MODE
;;;728      USB_OTG_DriveVbus(pdev, 1);
000080  2101              MOVS     r1,#1
000082  4620              MOV      r0,r4
000084  f7fffffe          BL       USB_OTG_DriveVbus
;;;729    #endif
;;;730      
;;;731      USB_OTG_EnableHostInt(pdev);
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       USB_OTG_EnableHostInt
;;;732      return status;
00008e  4638              MOV      r0,r7
;;;733    }
000090  e8bd81f0          POP      {r4-r8,pc}
;;;734    
                          ENDP


                          AREA ||i.USB_OTG_CoreReset||, CODE, READONLY, ALIGN=2

                  USB_OTG_CoreReset PROC
;;;116    */
;;;117    static USB_OTG_STS USB_OTG_CoreReset(USB_OTG_CORE_HANDLE *pdev)
000000  b5f8              PUSH     {r3-r7,lr}
;;;118    {
;;;119      USB_OTG_STS status = USB_OTG_OK;
000002  2600              MOVS     r6,#0
000004  4604              MOV      r4,r0                 ;118
;;;120      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;121      uint32_t count = 0;
000006  4637              MOV      r7,r6
;;;122      
;;;123      greset.d32 = 0;
000008  9600              STR      r6,[sp,#0]
;;;124      /* Wait for AHB master IDLE state. */
;;;125      do
;;;126      {
;;;127        USB_OTG_BSP_uDelay(3);
;;;128        greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
;;;129        if (++count > 200000)
00000a  4d12              LDR      r5,|L3.84|
                  |L3.12|
00000c  2003              MOVS     r0,#3                 ;127
00000e  f7fffffe          BL       USB_OTG_BSP_uDelay
000012  68e0              LDR      r0,[r4,#0xc]          ;128
000014  6900              LDR      r0,[r0,#0x10]         ;128
000016  9000              STR      r0,[sp,#0]            ;128
000018  1c7f              ADDS     r7,r7,#1
00001a  42af              CMP      r7,r5
00001c  d901              BLS      |L3.34|
;;;130        {
;;;131          return USB_OTG_OK;
00001e  2000              MOVS     r0,#0
;;;132        }
;;;133      }
;;;134      while (greset.b.ahbidle == 0);
;;;135      /* Core Soft Reset */
;;;136      count = 0;
;;;137      greset.b.csftrst = 1;
;;;138      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GRSTCTL, greset.d32 );
;;;139      do
;;;140      {
;;;141        greset.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GRSTCTL);
;;;142        if (++count > 200000)
;;;143        {
;;;144          break;
;;;145        }
;;;146      }
;;;147      while (greset.b.csftrst == 1);
;;;148      /* Wait for 3 PHY Clocks*/
;;;149      USB_OTG_BSP_uDelay(3);
;;;150      return status;
;;;151    }
000020  bdf8              POP      {r3-r7,pc}
                  |L3.34|
000022  9800              LDR      r0,[sp,#0]            ;134
000024  2800              CMP      r0,#0                 ;134
000026  daf1              BGE      |L3.12|
000028  9800              LDR      r0,[sp,#0]            ;137
00002a  2100              MOVS     r1,#0                 ;136
00002c  f0400001          ORR      r0,r0,#1              ;137
000030  9000              STR      r0,[sp,#0]            ;137
000032  9800              LDR      r0,[sp,#0]            ;138
000034  68e2              LDR      r2,[r4,#0xc]          ;138
000036  6110              STR      r0,[r2,#0x10]         ;138
000038  68e0              LDR      r0,[r4,#0xc]          ;128
                  |L3.58|
00003a  6902              LDR      r2,[r0,#0x10]         ;141
00003c  9200              STR      r2,[sp,#0]            ;141
00003e  1c49              ADDS     r1,r1,#1              ;142
000040  42a9              CMP      r1,r5                 ;142
000042  d802              BHI      |L3.74|
000044  9a00              LDR      r2,[sp,#0]            ;147
000046  07d2              LSLS     r2,r2,#31             ;147
000048  d1f7              BNE      |L3.58|
                  |L3.74|
00004a  2003              MOVS     r0,#3                 ;149
00004c  f7fffffe          BL       USB_OTG_BSP_uDelay
000050  4630              MOV      r0,r6                 ;150
000052  bdf8              POP      {r3-r7,pc}
;;;152    
                          ENDP

                  |L3.84|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_DisableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_DisableGlobalInt PROC
;;;479    */
;;;480    USB_OTG_STS USB_OTG_DisableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;481    {
;;;482      USB_OTG_STS status = USB_OTG_OK;
;;;483      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;484      ahbcfg.d32 = 0;
000002  2200              MOVS     r2,#0
;;;485      ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
;;;486      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, ahbcfg.d32, 0);
000004  6881              LDR      r1,[r0,#8]
000006  f0210101          BIC      r1,r1,#1
00000a  6081              STR      r1,[r0,#8]
;;;487      return status;
00000c  4610              MOV      r0,r2
;;;488    }
00000e  4770              BX       lr
;;;489    
                          ENDP


                          AREA ||i.USB_OTG_DriveVbus||, CODE, READONLY, ALIGN=1

                  USB_OTG_DriveVbus PROC
;;;751    */
;;;752    void USB_OTG_DriveVbus (USB_OTG_CORE_HANDLE *pdev, uint8_t state)
000000  b570              PUSH     {r4-r6,lr}
;;;753    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;754      USB_OTG_HPRT0_TypeDef     hprt0;
;;;755      
;;;756      hprt0.d32 = 0;
;;;757      
;;;758      /* enable disable the external charge pump */
;;;759      USB_OTG_BSP_DriveVBUS(pdev, state);
000006  f7fffffe          BL       USB_OTG_BSP_DriveVBUS
;;;760      
;;;761      /* Turn on the Host port power. */
;;;762      hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       USB_OTG_ReadHPRT0
;;;763      if ((hprt0.b.prtpwr == 0 ) && (state == 1 ))
000010  04c1              LSLS     r1,r0,#19
000012  d408              BMI      |L5.38|
000014  2c01              CMP      r4,#1
000016  d10c              BNE      |L5.50|
;;;764      {
;;;765        hprt0.b.prtpwr = 1;
;;;766        USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
000018  f8d510cc          LDR      r1,[r5,#0xcc]
00001c  f4405080          ORR      r0,r0,#0x1000         ;765
000020  6008              STR      r0,[r1,#0]
;;;767      }
;;;768      if ((hprt0.b.prtpwr == 1 ) && (state == 0 ))
000022  04c1              LSLS     r1,r0,#19
000024  d505              BPL      |L5.50|
                  |L5.38|
000026  b924              CBNZ     r4,|L5.50|
;;;769      {
;;;770        hprt0.b.prtpwr = 0;
;;;771        USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
000028  f8d510cc          LDR      r1,[r5,#0xcc]
00002c  f4205080          BIC      r0,r0,#0x1000         ;770
000030  6008              STR      r0,[r1,#0]
                  |L5.50|
;;;772      }
;;;773      
;;;774      USB_OTG_BSP_mDelay(200);
000032  e8bd4070          POP      {r4-r6,lr}
000036  20c8              MOVS     r0,#0xc8
000038  f7ffbffe          B.W      USB_OTG_BSP_mDelay
;;;775    }
;;;776    /**
                          ENDP


                          AREA ||i.USB_OTG_EnableGlobalInt||, CODE, READONLY, ALIGN=1

                  USB_OTG_EnableGlobalInt PROC
;;;461    */
;;;462    USB_OTG_STS USB_OTG_EnableGlobalInt(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;463    {
;;;464      USB_OTG_STS status = USB_OTG_OK;
;;;465      USB_OTG_GAHBCFG_TypeDef  ahbcfg;
;;;466      
;;;467      ahbcfg.d32 = 0;
000002  2200              MOVS     r2,#0
;;;468      ahbcfg.b.glblintrmsk = 1; /* Enable interrupts */
;;;469      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GAHBCFG, 0, ahbcfg.d32);
000004  6881              LDR      r1,[r0,#8]
000006  f0410101          ORR      r1,r1,#1
00000a  6081              STR      r1,[r0,#8]
;;;470      return status;
00000c  4610              MOV      r0,r2
;;;471    }
00000e  4770              BX       lr
;;;472    
                          ENDP


                          AREA ||i.USB_OTG_EnableHostInt||, CODE, READONLY, ALIGN=2

                  USB_OTG_EnableHostInt PROC
;;;780    */
;;;781    USB_OTG_STS USB_OTG_EnableHostInt(USB_OTG_CORE_HANDLE *pdev)
000000  b510              PUSH     {r4,lr}
;;;782    {
;;;783      USB_OTG_STS       status = USB_OTG_OK;
;;;784      USB_OTG_GINTMSK_TypeDef  intmsk;
;;;785      intmsk.d32 = 0;
;;;786      /* Disable all interrupts. */
;;;787      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTMSK, 0);
000002  68c2              LDR      r2,[r0,#0xc]
000004  2300              MOVS     r3,#0                 ;783
000006  4619              MOV      r1,r3                 ;785
000008  6193              STR      r3,[r2,#0x18]
;;;788      
;;;789      /* Clear any pending interrupts. */
;;;790      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GINTSTS, 0xFFFFFFFF);
00000a  68c4              LDR      r4,[r0,#0xc]
00000c  1e5a              SUBS     r2,r3,#1
00000e  6162              STR      r2,[r4,#0x14]
000010  68c4              LDR      r4,[r0,#0xc]
000012  6062              STR      r2,[r4,#4]
000014  68c4              LDR      r4,[r0,#0xc]
000016  6162              STR      r2,[r4,#0x14]
000018  68c4              LDR      r4,[r0,#0xc]
00001a  4a09              LDR      r2,|L7.64|
00001c  61a2              STR      r2,[r4,#0x18]
;;;791      
;;;792      /* Enable the common interrupts */
;;;793      USB_OTG_EnableCommonInt(pdev);
;;;794      
;;;795      if (pdev->cfg.dma_enable == 0)
00001e  78c2              LDRB     r2,[r0,#3]
000020  b902              CBNZ     r2,|L7.36|
;;;796      {  
;;;797        intmsk.b.rxstsqlvl  = 1;
000022  2110              MOVS     r1,#0x10
                  |L7.36|
;;;798      }  
;;;799      intmsk.b.portintr   = 1;
;;;800      intmsk.b.hcintr     = 1;
;;;801      intmsk.b.disconnect = 1;  
;;;802      intmsk.b.sofintr    = 1;  
;;;803      intmsk.b.incomplisoout  = 1; 
;;;804      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, intmsk.d32, intmsk.d32);
000024  68c0              LDR      r0,[r0,#0xc]
000026  f041510c          ORR      r1,r1,#0x23000000     ;799
00002a  f0410108          ORR      r1,r1,#8              ;802
00002e  6982              LDR      r2,[r0,#0x18]
000030  f4411100          ORR      r1,r1,#0x200000       ;803
000034  438a              BICS     r2,r2,r1
000036  430a              ORRS     r2,r2,r1
000038  6182              STR      r2,[r0,#0x18]
;;;805      return status;
00003a  4618              MOV      r0,r3
;;;806    }
00003c  bd10              POP      {r4,pc}
;;;807    
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      0x80000800

                          AREA ||i.USB_OTG_FlushRxFifo||, CODE, READONLY, ALIGN=2

                  USB_OTG_FlushRxFifo PROC
;;;526    */
;;;527    USB_OTG_STS USB_OTG_FlushRxFifo( USB_OTG_CORE_HANDLE *pdev )
000000  b538              PUSH     {r3-r5,lr}
;;;528    {
;;;529      USB_OTG_STS status = USB_OTG_OK;
000002  2400              MOVS     r4,#0
000004  4602              MOV      r2,r0                 ;528
;;;530      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;531      uint32_t count = 0;
000006  4621              MOV      r1,r4
;;;532      
;;;533      greset.d32 = 0;
000008  9400              STR      r4,[sp,#0]
;;;534      greset.b.rxfflsh = 1;
00000a  9800              LDR      r0,[sp,#0]
00000c  f0400010          ORR      r0,r0,#0x10
000010  9000              STR      r0,[sp,#0]
;;;535      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
000012  9800              LDR      r0,[sp,#0]
000014  68d3              LDR      r3,[r2,#0xc]
000016  6118              STR      r0,[r3,#0x10]
;;;536      do
;;;537      {
;;;538        greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
;;;539        if (++count > 200000)
000018  4807              LDR      r0,|L8.56|
00001a  68d2              LDR      r2,[r2,#0xc]          ;535
                  |L8.28|
00001c  6913              LDR      r3,[r2,#0x10]         ;538
00001e  9300              STR      r3,[sp,#0]            ;538
000020  1c49              ADDS     r1,r1,#1
000022  4281              CMP      r1,r0
000024  d802              BHI      |L8.44|
;;;540        {
;;;541          break;
;;;542        }
;;;543      }
;;;544      while (greset.b.rxfflsh == 1);
000026  9b00              LDR      r3,[sp,#0]
000028  06db              LSLS     r3,r3,#27
00002a  d4f7              BMI      |L8.28|
                  |L8.44|
;;;545      /* Wait for 3 PHY Clocks*/
;;;546      USB_OTG_BSP_uDelay(3);
00002c  2003              MOVS     r0,#3
00002e  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;547      return status;
000032  4620              MOV      r0,r4
;;;548    }
000034  bd38              POP      {r3-r5,pc}
;;;549    
                          ENDP

000036  0000              DCW      0x0000
                  |L8.56|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_FlushTxFifo||, CODE, READONLY, ALIGN=2

                  USB_OTG_FlushTxFifo PROC
;;;496    */
;;;497    USB_OTG_STS USB_OTG_FlushTxFifo (USB_OTG_CORE_HANDLE *pdev , uint32_t num )
000000  b538              PUSH     {r3-r5,lr}
;;;498    {
;;;499      USB_OTG_STS status = USB_OTG_OK;
000002  2400              MOVS     r4,#0
000004  4603              MOV      r3,r0                 ;498
;;;500      __IO USB_OTG_GRSTCTL_TypeDef  greset;
;;;501      
;;;502      uint32_t count = 0;
000006  4622              MOV      r2,r4
;;;503      greset.d32 = 0;
000008  9400              STR      r4,[sp,#0]
;;;504      greset.b.txfflsh = 1;
00000a  9800              LDR      r0,[sp,#0]
00000c  f0400020          ORR      r0,r0,#0x20
000010  9000              STR      r0,[sp,#0]
;;;505      greset.b.txfnum  = num;
000012  9800              LDR      r0,[sp,#0]
000014  f361108a          BFI      r0,r1,#6,#5
000018  9000              STR      r0,[sp,#0]
;;;506      USB_OTG_WRITE_REG32( &pdev->regs.GREGS->GRSTCTL, greset.d32 );
00001a  9800              LDR      r0,[sp,#0]
00001c  68d9              LDR      r1,[r3,#0xc]
00001e  6108              STR      r0,[r1,#0x10]
;;;507      do
;;;508      {
;;;509        greset.d32 = USB_OTG_READ_REG32( &pdev->regs.GREGS->GRSTCTL);
;;;510        if (++count > 200000)
000020  4807              LDR      r0,|L9.64|
000022  68d9              LDR      r1,[r3,#0xc]          ;506
                  |L9.36|
000024  690b              LDR      r3,[r1,#0x10]         ;509
000026  9300              STR      r3,[sp,#0]            ;509
000028  1c52              ADDS     r2,r2,#1
00002a  4282              CMP      r2,r0
00002c  d802              BHI      |L9.52|
;;;511        {
;;;512          break;
;;;513        }
;;;514      }
;;;515      while (greset.b.txfflsh == 1);
00002e  9b00              LDR      r3,[sp,#0]
000030  069b              LSLS     r3,r3,#26
000032  d4f7              BMI      |L9.36|
                  |L9.52|
;;;516      /* Wait for 3 PHY Clocks*/
;;;517      USB_OTG_BSP_uDelay(3);
000034  2003              MOVS     r0,#3
000036  f7fffffe          BL       USB_OTG_BSP_uDelay
;;;518      return status;
00003a  4620              MOV      r0,r4
;;;519    }
00003c  bd38              POP      {r3-r5,pc}
;;;520    
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      0x00030d40

                          AREA ||i.USB_OTG_GetMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_GetMode PROC
;;;586    */
;;;587    uint32_t USB_OTG_GetMode(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;588    {
;;;589      return (USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS ) & 0x1);
000002  6940              LDR      r0,[r0,#0x14]
000004  f0000001          AND      r0,r0,#1
;;;590    }
000008  4770              BX       lr
;;;591    
                          ENDP


                          AREA ||i.USB_OTG_HC_DoPing||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_DoPing PROC
;;;1147   */
;;;1148   USB_OTG_STS USB_OTG_HC_DoPing(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b510              PUSH     {r4,lr}
;;;1149   {
;;;1150     USB_OTG_STS               status = USB_OTG_OK;
;;;1151     USB_OTG_HCCHAR_TypeDef    hcchar;
;;;1152     USB_OTG_HCTSIZn_TypeDef   hctsiz;  
;;;1153    
;;;1154     hctsiz.d32 = 0;
;;;1155     hctsiz.b.dopng = 1;
;;;1156     hctsiz.b.pktcnt = 1;
;;;1157     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
000002  eb000081          ADD      r0,r0,r1,LSL #2
000006  2300              MOVS     r3,#0                 ;1154
000008  f8501f90          LDR      r1,[r0,#0x90]!
00000c  f04f4200          MOV      r2,#0x80000000        ;1155
000010  2401              MOVS     r4,#1                 ;1156
000012  f36442dc          BFI      r2,r4,#19,#10         ;1156
000016  610a              STR      r2,[r1,#0x10]
;;;1158     
;;;1159     hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
000018  6800              LDR      r0,[r0,#0]
00001a  6801              LDR      r1,[r0,#0]
;;;1160     hcchar.b.chen = 1;
00001c  f0214180          BIC      r1,r1,#0x40000000
;;;1161     hcchar.b.chdis = 0;
000020  f0414100          ORR      r1,r1,#0x80000000
;;;1162     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000024  6001              STR      r1,[r0,#0]
;;;1163     return status;  
000026  4618              MOV      r0,r3
;;;1164   }
000028  bd10              POP      {r4,pc}
;;;1165   
                          ENDP


                          AREA ||i.USB_OTG_HC_Halt||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_Halt PROC
;;;1108   */
;;;1109   USB_OTG_STS USB_OTG_HC_Halt(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b510              PUSH     {r4,lr}
;;;1110   {
;;;1111     USB_OTG_STS status = USB_OTG_OK;
;;;1112     USB_OTG_HNPTXSTS_TypeDef            nptxsts;
;;;1113     USB_OTG_HPTXSTS_TypeDef             hptxsts;
;;;1114     USB_OTG_HCCHAR_TypeDef              hcchar;
;;;1115     
;;;1116     nptxsts.d32 = 0;
;;;1117     hptxsts.d32 = 0;
;;;1118     hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
000002  eb000181          ADD      r1,r0,r1,LSL #2
000006  2300              MOVS     r3,#0                 ;1111
000008  f8d12090          LDR      r2,[r1,#0x90]
00000c  6811              LDR      r1,[r2,#0]
;;;1119     hcchar.b.chen = 1;
;;;1120     hcchar.b.chdis = 1;
00000e  f0414140          ORR      r1,r1,#0xc0000000
;;;1121     
;;;1122     /* Check for space in the request queue to issue the halt. */
;;;1123     if (hcchar.b.eptype == HCCHAR_CTRL || hcchar.b.eptype == HCCHAR_BULK)
000012  f4112f40          TST      r1,#0xc0000
000016  d009              BEQ      |L12.44|
000018  f3c14481          UBFX     r4,r1,#18,#2
00001c  2c02              CMP      r4,#2
00001e  d005              BEQ      |L12.44|
;;;1124     {
;;;1125       nptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
;;;1126       if (nptxsts.b.nptxqspcavail == 0)
;;;1127       {
;;;1128         hcchar.b.chen = 0;
;;;1129       }
;;;1130     }
;;;1131     else
;;;1132     {
;;;1133       hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
000020  6940              LDR      r0,[r0,#0x14]
000022  6900              LDR      r0,[r0,#0x10]
                  |L12.36|
;;;1134       if (hptxsts.b.ptxqspcavail == 0)
000024  f4100f7f          TST      r0,#0xff0000
000028  d003              BEQ      |L12.50|
00002a  e004              B        |L12.54|
                  |L12.44|
00002c  68c0              LDR      r0,[r0,#0xc]          ;1125
00002e  6ac0              LDR      r0,[r0,#0x2c]         ;1125
000030  e7f8              B        |L12.36|
                  |L12.50|
;;;1135       {
;;;1136         hcchar.b.chen = 0;
000032  f0214100          BIC      r1,r1,#0x80000000
                  |L12.54|
;;;1137       }
;;;1138     }
;;;1139     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000036  6011              STR      r1,[r2,#0]
;;;1140     return status;
000038  4618              MOV      r0,r3
;;;1141   }
00003a  bd10              POP      {r4,pc}
;;;1142   
                          ENDP


                          AREA ||i.USB_OTG_HC_Init||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_Init PROC
;;;881    */
;;;882    USB_OTG_STS USB_OTG_HC_Init(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b5f0              PUSH     {r4-r7,lr}
;;;883    {
;;;884      USB_OTG_STS status = USB_OTG_OK;
;;;885      uint32_t intr_enable = 0;
;;;886      USB_OTG_HCGINTMSK_TypeDef  hcintmsk;
;;;887      USB_OTG_GINTMSK_TypeDef    gintmsk;
;;;888      USB_OTG_HCCHAR_TypeDef     hcchar;
;;;889      USB_OTG_HCINTn_TypeDef     hcint;
;;;890      
;;;891      
;;;892      gintmsk.d32 = 0;
;;;893      hcintmsk.d32 = 0;
;;;894      hcchar.d32 = 0;
;;;895      
;;;896      /* Clear old interrupt conditions for this host channel. */
;;;897      hcint.d32 = 0xFFFFFFFF;
;;;898      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCINT, hcint.d32);
000002  eb000681          ADD      r6,r0,r1,LSL #2
000006  2700              MOVS     r7,#0                 ;884
000008  f8d64090          LDR      r4,[r6,#0x90]
00000c  463d              MOV      r5,r7                 ;892
00000e  1e7b              SUBS     r3,r7,#1              ;897
000010  462a              MOV      r2,r5                 ;892
000012  60a3              STR      r3,[r4,#8]
;;;899      
;;;900      /* Enable channel interrupts required for this transfer. */
;;;901      hcintmsk.d32 = 0;
;;;902      
;;;903      if (pdev->cfg.dma_enable == 1)
000014  78c3              LDRB     r3,[r0,#3]
000016  2b01              CMP      r3,#1
000018  d100              BNE      |L13.28|
;;;904      {
;;;905        hcintmsk.b.ahberr = 1;
00001a  2204              MOVS     r2,#4
                  |L13.28|
;;;906      }
;;;907      
;;;908      switch (pdev->host.hc[hc_num].ep_type) 
00001c  eb001341          ADD      r3,r0,r1,LSL #5
000020  f89342b1          LDRB     r4,[r3,#0x2b1]
000024  b134              CBZ      r4,|L13.52|
000026  2c01              CMP      r4,#1
000028  d01f              BEQ      |L13.106|
00002a  2c02              CMP      r4,#2
00002c  d002              BEQ      |L13.52|
00002e  2c03              CMP      r4,#3
000030  d127              BNE      |L13.130|
000032  e00e              B        |L13.82|
                  |L13.52|
;;;909      {
;;;910      case EP_TYPE_CTRL:
;;;911      case EP_TYPE_BULK:
;;;912        hcintmsk.b.xfercompl = 1;
000034  f0420289          ORR      r2,r2,#0x89
;;;913        hcintmsk.b.stall = 1;
;;;914        hcintmsk.b.xacterr = 1;
;;;915        hcintmsk.b.datatglerr = 1;
;;;916        hcintmsk.b.nak = 1;  
;;;917        if (pdev->host.hc[hc_num].ep_is_in) 
000038  f89342ae          LDRB     r4,[r3,#0x2ae]
00003c  f4426282          ORR      r2,r2,#0x410          ;915
000040  b984              CBNZ     r4,|L13.100|
;;;918        {
;;;919          hcintmsk.b.bblerr = 1;
;;;920        } 
;;;921        else 
;;;922        {
;;;923          hcintmsk.b.nyet = 1;
;;;924          if (pdev->host.hc[hc_num].do_ping) 
000042  f89342b0          LDRB     r4,[r3,#0x2b0]
000046  f0420240          ORR      r2,r2,#0x40           ;923
00004a  b1d4              CBZ      r4,|L13.130|
;;;925          {
;;;926            hcintmsk.b.ack = 1;
00004c  f0420220          ORR      r2,r2,#0x20
000050  e017              B        |L13.130|
                  |L13.82|
;;;927          }
;;;928        }
;;;929        break;
;;;930      case EP_TYPE_INTR:
;;;931        hcintmsk.b.xfercompl = 1;
;;;932        hcintmsk.b.nak = 1;
;;;933        hcintmsk.b.stall = 1;
;;;934        hcintmsk.b.xacterr = 1;
;;;935        hcintmsk.b.datatglerr = 1;
;;;936        hcintmsk.b.frmovrun = 1;
;;;937        
;;;938        if (pdev->host.hc[hc_num].ep_is_in) 
000052  f893c2ae          LDRB     r12,[r3,#0x2ae]
000056  f0420299          ORR      r2,r2,#0x99           ;931
00005a  f44262c0          ORR      r2,r2,#0x600          ;935
00005e  f1bc0f00          CMP      r12,#0
000062  d00e              BEQ      |L13.130|
                  |L13.100|
;;;939        {
;;;940          hcintmsk.b.bblerr = 1;
000064  f4427280          ORR      r2,r2,#0x100
000068  e00b              B        |L13.130|
                  |L13.106|
;;;941        }
;;;942        
;;;943        break;
;;;944      case EP_TYPE_ISOC:
;;;945        hcintmsk.b.xfercompl = 1;
;;;946        hcintmsk.b.frmovrun = 1;
;;;947        hcintmsk.b.ack = 1;
;;;948        
;;;949        if (pdev->host.hc[hc_num].ep_is_in) 
00006a  f893c2ae          LDRB     r12,[r3,#0x2ae]
00006e  f0420201          ORR      r2,r2,#1              ;945
000072  f4427208          ORR      r2,r2,#0x220          ;946
000076  f1bc0f00          CMP      r12,#0
00007a  d002              BEQ      |L13.130|
;;;950        {
;;;951          hcintmsk.b.xacterr = 1;
00007c  f0420280          ORR      r2,r2,#0x80
;;;952          hcintmsk.b.bblerr = 1;
000080  e7f0              B        |L13.100|
                  |L13.130|
;;;953        }
;;;954        break;
;;;955      }
;;;956      
;;;957      
;;;958      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCGINTMSK, hcintmsk.d32);
000082  f8d64090          LDR      r4,[r6,#0x90]
000086  60e2              STR      r2,[r4,#0xc]
;;;959      
;;;960      
;;;961      /* Enable the top level host channel interrupt. */
;;;962      intr_enable = (1 << hc_num);
000088  2201              MOVS     r2,#1
00008a  408a              LSLS     r2,r2,r1
;;;963      USB_OTG_MODIFY_REG32(&pdev->regs.HREGS->HAINTMSK, 0, intr_enable);
00008c  6941              LDR      r1,[r0,#0x14]
00008e  698c              LDR      r4,[r1,#0x18]
000090  4314              ORRS     r4,r4,r2
000092  618c              STR      r4,[r1,#0x18]
;;;964      
;;;965      /* Make sure host channel interrupts are enabled. */
;;;966      gintmsk.b.hcintr = 1;
;;;967      USB_OTG_MODIFY_REG32(&pdev->regs.GREGS->GINTMSK, 0, gintmsk.d32);
000094  68c0              LDR      r0,[r0,#0xc]
000096  6981              LDR      r1,[r0,#0x18]
000098  f0417100          ORR      r1,r1,#0x2000000
00009c  6181              STR      r1,[r0,#0x18]
;;;968      
;;;969      /* Program the HCCHAR register */
;;;970      hcchar.d32 = 0;
;;;971      hcchar.b.devaddr = pdev->host.hc[hc_num].dev_addr;
00009e  f89302ac          LDRB     r0,[r3,#0x2ac]
0000a2  f360559c          BFI      r5,r0,#22,#7
;;;972      hcchar.b.epnum   = pdev->host.hc[hc_num].ep_num;
0000a6  f89302ad          LDRB     r0,[r3,#0x2ad]
0000aa  f36025ce          BFI      r5,r0,#11,#4
;;;973      hcchar.b.epdir   = pdev->host.hc[hc_num].ep_is_in;
0000ae  f89302ae          LDRB     r0,[r3,#0x2ae]
0000b2  f36035cf          BFI      r5,r0,#15,#1
;;;974      hcchar.b.lspddev = (pdev->host.hc[hc_num].speed == HPRT0_PRTSPD_LOW_SPEED);
0000b6  f89302af          LDRB     r0,[r3,#0x2af]
0000ba  2802              CMP      r0,#2
0000bc  d00c              BEQ      |L13.216|
0000be  f4253000          BIC      r0,r5,#0x20000
                  |L13.194|
;;;975      hcchar.b.eptype  = pdev->host.hc[hc_num].ep_type;
0000c2  f89312b1          LDRB     r1,[r3,#0x2b1]
;;;976      hcchar.b.mps     = pdev->host.hc[hc_num].max_packet;
0000c6  f8b322b2          LDRH     r2,[r3,#0x2b2]
0000ca  f3614093          BFI      r0,r1,#18,#2          ;975
0000ce  f362000a          BFI      r0,r2,#0,#11
;;;977      if (pdev->host.hc[hc_num].ep_type == HCCHAR_INTR)
0000d2  2903              CMP      r1,#3
0000d4  d003              BEQ      |L13.222|
0000d6  e004              B        |L13.226|
                  |L13.216|
0000d8  f4453000          ORR      r0,r5,#0x20000        ;974
0000dc  e7f1              B        |L13.194|
                  |L13.222|
;;;978      {
;;;979        hcchar.b.oddfrm  = 1;
0000de  f0405000          ORR      r0,r0,#0x20000000
                  |L13.226|
;;;980      }
;;;981      USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
0000e2  f8d61090          LDR      r1,[r6,#0x90]
0000e6  6008              STR      r0,[r1,#0]
;;;982      return status;
0000e8  4638              MOV      r0,r7
;;;983    }
0000ea  bdf0              POP      {r4-r7,pc}
;;;984    
                          ENDP


                          AREA ||i.USB_OTG_HC_StartXfer||, CODE, READONLY, ALIGN=1

                  USB_OTG_HC_StartXfer PROC
;;;991    */
;;;992    USB_OTG_STS USB_OTG_HC_StartXfer(USB_OTG_CORE_HANDLE *pdev , uint8_t hc_num)
000000  b5f0              PUSH     {r4-r7,lr}
;;;993    {
;;;994      USB_OTG_STS status = USB_OTG_OK;
;;;995      USB_OTG_HCCHAR_TypeDef   hcchar;
;;;996      USB_OTG_HCTSIZn_TypeDef  hctsiz;
;;;997      USB_OTG_HNPTXSTS_TypeDef hnptxsts; 
;;;998      USB_OTG_HPTXSTS_TypeDef  hptxsts; 
;;;999      USB_OTG_GINTMSK_TypeDef  intmsk;
;;;1000     uint16_t                 len_words = 0;   
;;;1001     
;;;1002     uint16_t num_packets;
;;;1003     uint16_t max_hc_pkt_count;
;;;1004     
;;;1005     max_hc_pkt_count = 256;
;;;1006     hctsiz.d32 = 0;
;;;1007     hcchar.d32 = 0;
;;;1008     intmsk.d32 = 0;
;;;1009     
;;;1010     /* Compute the expected number of packets associated to the transfer */
;;;1011     if (pdev->host.hc[hc_num].xfer_len > 0)
000002  eb001441          ADD      r4,r0,r1,LSL #5
000006  2600              MOVS     r6,#0                 ;994
000008  f8d432bc          LDR      r3,[r4,#0x2bc]        ;993
00000c  4605              MOV      r5,r0                 ;993
00000e  f44f7c80          MOV      r12,#0x100            ;1005
000012  4637              MOV      r7,r6                 ;1006
000014  b16b              CBZ      r3,|L14.50|
;;;1012     {
;;;1013       num_packets = (pdev->host.hc[hc_num].xfer_len + \
000016  f8b422b2          LDRH     r2,[r4,#0x2b2]
00001a  1898              ADDS     r0,r3,r2
00001c  1e40              SUBS     r0,r0,#1
00001e  fbb0f0f2          UDIV     r0,r0,r2
000022  b280              UXTH     r0,r0
;;;1014         pdev->host.hc[hc_num].max_packet - 1) / pdev->host.hc[hc_num].max_packet;
;;;1015       
;;;1016       if (num_packets > max_hc_pkt_count)
000024  4560              CMP      r0,r12
000026  d905              BLS      |L14.52|
;;;1017       {
;;;1018         num_packets = max_hc_pkt_count;
;;;1019         pdev->host.hc[hc_num].xfer_len = num_packets * \
000028  0212              LSLS     r2,r2,#8
00002a  4660              MOV      r0,r12                ;1018
00002c  f8c422bc          STR      r2,[r4,#0x2bc]
000030  e000              B        |L14.52|
                  |L14.50|
;;;1020           pdev->host.hc[hc_num].max_packet;
;;;1021       }
;;;1022     }
;;;1023     else
;;;1024     {
;;;1025       num_packets = 1;
000032  2001              MOVS     r0,#1
                  |L14.52|
;;;1026     }
;;;1027     if (pdev->host.hc[hc_num].ep_is_in)
000034  f89422ae          LDRB     r2,[r4,#0x2ae]
000038  b1aa              CBZ      r2,|L14.102|
;;;1028     {
;;;1029       pdev->host.hc[hc_num].xfer_len = num_packets * \
00003a  f8b422b2          LDRH     r2,[r4,#0x2b2]
00003e  4342              MULS     r2,r0,r2
000040  f8c422bc          STR      r2,[r4,#0x2bc]
                  |L14.68|
;;;1030         pdev->host.hc[hc_num].max_packet;
;;;1031     }
;;;1032     /* Initialize the HCTSIZn register */
;;;1033     hctsiz.b.xfersize = pdev->host.hc[hc_num].xfer_len;
000044  f3620712          BFI      r7,r2,#0,#19
;;;1034     hctsiz.b.pktcnt = num_packets;
000048  f36047dc          BFI      r7,r0,#19,#10
;;;1035     hctsiz.b.pid = pdev->host.hc[hc_num].data_pid;
00004c  f89402b4          LDRB     r0,[r4,#0x2b4]
;;;1036     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCTSIZ, hctsiz.d32);
000050  eb050281          ADD      r2,r5,r1,LSL #2
000054  f360775e          BFI      r7,r0,#29,#2          ;1035
000058  f8d20090          LDR      r0,[r2,#0x90]
00005c  6107              STR      r7,[r0,#0x10]
;;;1037     
;;;1038     if (pdev->cfg.dma_enable == 1)
00005e  78e8              LDRB     r0,[r5,#3]
000060  2801              CMP      r0,#1
000062  d003              BEQ      |L14.108|
000064  e007              B        |L14.118|
                  |L14.102|
000066  f8d422bc          LDR      r2,[r4,#0x2bc]        ;1029
00006a  e7eb              B        |L14.68|
                  |L14.108|
;;;1039     {
;;;1040       USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCDMA, (unsigned int)pdev->host.hc[hc_num].xfer_buff);
00006c  f8d23090          LDR      r3,[r2,#0x90]
000070  f8d402b8          LDR      r0,[r4,#0x2b8]
000074  6158              STR      r0,[r3,#0x14]
                  |L14.118|
;;;1041     }
;;;1042     
;;;1043     
;;;1044     hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR);
000076  f8520f90          LDR      r0,[r2,#0x90]!
00007a  6803              LDR      r3,[r0,#0]
;;;1045     hcchar.b.oddfrm = USB_OTG_IsEvenFrame(pdev);
00007c  4628              MOV      r0,r5
00007e  f7fffffe          BL       USB_OTG_IsEvenFrame
000082  f360735d          BFI      r3,r0,#29,#1
;;;1046     
;;;1047     /* Set host channel enable */
;;;1048     hcchar.b.chen = 1;
;;;1049     hcchar.b.chdis = 0;
;;;1050     USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[hc_num]->HCCHAR, hcchar.d32);
000086  6812              LDR      r2,[r2,#0]
000088  f0234080          BIC      r0,r3,#0x40000000     ;1048
00008c  f0404000          ORR      r0,r0,#0x80000000     ;1049
000090  6010              STR      r0,[r2,#0]
;;;1051   
;;;1052     if (pdev->cfg.dma_enable == 0) /* Slave mode */
000092  78e8              LDRB     r0,[r5,#3]
000094  bb90              CBNZ     r0,|L14.252|
;;;1053     {  
;;;1054       if((pdev->host.hc[hc_num].ep_is_in == 0) && 
000096  f89402ae          LDRB     r0,[r4,#0x2ae]
00009a  bb78              CBNZ     r0,|L14.252|
;;;1055           (pdev->host.hc[hc_num].xfer_len > 0))
00009c  f8d422bc          LDR      r2,[r4,#0x2bc]
0000a0  b362              CBZ      r2,|L14.252|
;;;1056       {
;;;1057         switch(pdev->host.hc[hc_num].ep_type) 
0000a2  f89402b1          LDRB     r0,[r4,#0x2b1]
0000a6  b130              CBZ      r0,|L14.182|
0000a8  2801              CMP      r0,#1
0000aa  d010              BEQ      |L14.206|
0000ac  2802              CMP      r0,#2
0000ae  d002              BEQ      |L14.182|
0000b0  2803              CMP      r0,#3
0000b2  d119              BNE      |L14.232|
0000b4  e00b              B        |L14.206|
                  |L14.182|
;;;1058         {
;;;1059           /* Non periodic transfer */
;;;1060         case EP_TYPE_CTRL:
;;;1061         case EP_TYPE_BULK:
;;;1062           
;;;1063           hnptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->HNPTXSTS);
0000b6  68e8              LDR      r0,[r5,#0xc]
0000b8  6ac3              LDR      r3,[r0,#0x2c]
;;;1064           len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
0000ba  1cd2              ADDS     r2,r2,#3
0000bc  f3c2028f          UBFX     r2,r2,#2,#16
;;;1065           
;;;1066           /* check if there is enough space in FIFO space */
;;;1067           if(len_words > hnptxsts.b.nptxfspcavail)
0000c0  b29b              UXTH     r3,r3
0000c2  4293              CMP      r3,r2
0000c4  d210              BCS      |L14.232|
;;;1068           {
;;;1069             /* need to process data in nptxfempty interrupt */
;;;1070             intmsk.b.nptxfempty = 1;
;;;1071             USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
0000c6  6982              LDR      r2,[r0,#0x18]
0000c8  f0420220          ORR      r2,r2,#0x20
0000cc  e00b              B        |L14.230|
                  |L14.206|
;;;1072           }
;;;1073           
;;;1074           break;
;;;1075           /* Periodic transfer */
;;;1076         case EP_TYPE_INTR:
;;;1077         case EP_TYPE_ISOC:
;;;1078           hptxsts.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HPTXSTS);
0000ce  6968              LDR      r0,[r5,#0x14]
0000d0  6900              LDR      r0,[r0,#0x10]
;;;1079           len_words = (pdev->host.hc[hc_num].xfer_len + 3) / 4;
0000d2  1cd2              ADDS     r2,r2,#3
0000d4  f3c2028f          UBFX     r2,r2,#2,#16
;;;1080           /* check if there is enough space in FIFO space */
;;;1081           if(len_words > hptxsts.b.ptxfspcavail) /* split the transfer */
0000d8  b280              UXTH     r0,r0
0000da  4290              CMP      r0,r2
0000dc  d204              BCS      |L14.232|
;;;1082           {
;;;1083             /* need to process data in ptxfempty interrupt */
;;;1084             intmsk.b.ptxfempty = 1;
;;;1085             USB_OTG_MODIFY_REG32( &pdev->regs.GREGS->GINTMSK, 0, intmsk.d32);  
0000de  68e8              LDR      r0,[r5,#0xc]
0000e0  6982              LDR      r2,[r0,#0x18]
0000e2  f0426280          ORR      r2,r2,#0x4000000
                  |L14.230|
0000e6  6182              STR      r2,[r0,#0x18]
                  |L14.232|
;;;1086           }
;;;1087           break;
;;;1088           
;;;1089         default:
;;;1090           break;
;;;1091         }
;;;1092         
;;;1093         /* Write packet into the Tx FIFO. */
;;;1094         USB_OTG_WritePacket(pdev, 
0000e8  f8b402bc          LDRH     r0,[r4,#0x2bc]
0000ec  460a              MOV      r2,r1
0000ee  b283              UXTH     r3,r0
0000f0  f8d402b8          LDR      r0,[r4,#0x2b8]
0000f4  4601              MOV      r1,r0
0000f6  4628              MOV      r0,r5
0000f8  f7fffffe          BL       USB_OTG_WritePacket
                  |L14.252|
;;;1095                             pdev->host.hc[hc_num].xfer_buff , 
;;;1096                             hc_num, pdev->host.hc[hc_num].xfer_len);
;;;1097       }
;;;1098     }
;;;1099     return status;
0000fc  4630              MOV      r0,r6
;;;1100   }
0000fe  bdf0              POP      {r4-r7,pc}
;;;1101   
                          ENDP


                          AREA ||i.USB_OTG_InitFSLSPClkSel||, CODE, READONLY, ALIGN=1

                  USB_OTG_InitFSLSPClkSel PROC
;;;814    */
;;;815    void USB_OTG_InitFSLSPClkSel(USB_OTG_CORE_HANDLE *pdev , uint8_t freq)
000000  6940              LDR      r0,[r0,#0x14]
;;;816    {
;;;817      USB_OTG_HCFG_TypeDef   hcfg;
;;;818      
;;;819      hcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.HREGS->HCFG);
000002  6802              LDR      r2,[r0,#0]
;;;820      hcfg.b.fslspclksel = freq;
000004  f3610201          BFI      r2,r1,#0,#2
;;;821      USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HCFG, hcfg.d32);
000008  6002              STR      r2,[r0,#0]
;;;822    }
00000a  4770              BX       lr
;;;823    
                          ENDP


                          AREA ||i.USB_OTG_IsDeviceMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsDeviceMode PROC
;;;597    */
;;;598    uint8_t USB_OTG_IsDeviceMode(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
000002  6940              LDR      r0,[r0,#0x14]
000004  f0100f01          TST      r0,#1
;;;599    {
000008  d001              BEQ      |L16.14|
;;;600      return (USB_OTG_GetMode(pdev) != HOST_MODE);
00000a  2000              MOVS     r0,#0
;;;601    }
00000c  4770              BX       lr
                  |L16.14|
00000e  2001              MOVS     r0,#1                 ;600
000010  4770              BX       lr
;;;602    
                          ENDP


                          AREA ||i.USB_OTG_IsEvenFrame||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsEvenFrame PROC
;;;740    */
;;;741    uint8_t USB_OTG_IsEvenFrame (USB_OTG_CORE_HANDLE *pdev) 
000000  6940              LDR      r0,[r0,#0x14]
;;;742    {
;;;743      return !(USB_OTG_READ_REG32(&pdev->regs.HREGS->HFNUM) & 0x1);
000002  6880              LDR      r0,[r0,#8]
000004  f3400000          SBFX     r0,r0,#0,#1
000008  1c40              ADDS     r0,r0,#1
;;;744    }
00000a  4770              BX       lr
;;;745    
                          ENDP


                          AREA ||i.USB_OTG_IsHostMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_IsHostMode PROC
;;;608    */
;;;609    uint8_t USB_OTG_IsHostMode(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
000002  6940              LDR      r0,[r0,#0x14]
000004  f0100001          ANDS     r0,r0,#1
;;;610    {
000008  d000              BEQ      |L18.12|
;;;611      return (USB_OTG_GetMode(pdev) == HOST_MODE);
00000a  2001              MOVS     r0,#1
                  |L18.12|
;;;612    }
00000c  4770              BX       lr
;;;613    
                          ENDP


                          AREA ||i.USB_OTG_ReadCoreItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadCoreItr PROC
;;;619    */
;;;620    uint32_t USB_OTG_ReadCoreItr(USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;621    {
;;;622      uint32_t v = 0;
;;;623      v = USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTSTS);
000002  6941              LDR      r1,[r0,#0x14]
;;;624      v &= USB_OTG_READ_REG32(&pdev->regs.GREGS->GINTMSK);
000004  6980              LDR      r0,[r0,#0x18]
000006  4008              ANDS     r0,r0,r1
;;;625      return v;
;;;626    }
000008  4770              BX       lr
;;;627    
                          ENDP


                          AREA ||i.USB_OTG_ReadHPRT0||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadHPRT0 PROC
;;;829    */
;;;830    uint32_t USB_OTG_ReadHPRT0(USB_OTG_CORE_HANDLE *pdev)
000000  f8d000cc          LDR      r0,[r0,#0xcc]
;;;831    {
;;;832      USB_OTG_HPRT0_TypeDef  hprt0;
;;;833      
;;;834      hprt0.d32 = USB_OTG_READ_REG32(pdev->regs.HPRT0);
000004  6800              LDR      r0,[r0,#0]
;;;835      hprt0.b.prtena = 0;
;;;836      hprt0.b.prtconndet = 0;
;;;837      hprt0.b.prtenchng = 0;
;;;838      hprt0.b.prtovrcurrchng = 0;
000006  f020002e          BIC      r0,r0,#0x2e
;;;839      return hprt0.d32;
;;;840    }
00000a  4770              BX       lr
;;;841    
                          ENDP


                          AREA ||i.USB_OTG_ReadHostAllChannels_intr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadHostAllChannels_intr PROC
;;;847    */
;;;848    uint32_t USB_OTG_ReadHostAllChannels_intr (USB_OTG_CORE_HANDLE *pdev)
000000  6940              LDR      r0,[r0,#0x14]
;;;849    {
;;;850      return (USB_OTG_READ_REG32 (&pdev->regs.HREGS->HAINT));
000002  6940              LDR      r0,[r0,#0x14]
;;;851    }
000004  4770              BX       lr
;;;852    
                          ENDP


                          AREA ||i.USB_OTG_ReadOtgItr||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadOtgItr PROC
;;;633    */
;;;634    uint32_t USB_OTG_ReadOtgItr (USB_OTG_CORE_HANDLE *pdev)
000000  68c0              LDR      r0,[r0,#0xc]
;;;635    {
;;;636      return (USB_OTG_READ_REG32 (&pdev->regs.GREGS->GOTGINT));
000002  6840              LDR      r0,[r0,#4]
;;;637    }
000004  4770              BX       lr
;;;638    
                          ENDP


                          AREA ||i.USB_OTG_ReadPacket||, CODE, READONLY, ALIGN=1

                  USB_OTG_ReadPacket PROC
;;;190    */
;;;191    void *USB_OTG_ReadPacket(USB_OTG_CORE_HANDLE *pdev, 
000000  b510              PUSH     {r4,lr}
;;;192                             uint8_t *dest, 
;;;193                             uint16_t len)
;;;194    {
000002  4604              MOV      r4,r0
;;;195      uint32_t i=0;
000004  2300              MOVS     r3,#0
;;;196      uint32_t count32b = (len + 3) / 4;
000006  1cd2              ADDS     r2,r2,#3
000008  0890              LSRS     r0,r2,#2
00000a  f8d420d0          LDR      r2,[r4,#0xd0]         ;194
00000e  e003              B        |L23.24|
                  |L23.16|
;;;197      
;;;198      __IO uint32_t *fifo = pdev->regs.DFIFO[0];
;;;199      
;;;200      for ( i = 0; i < count32b; i++, dest += 4 )
;;;201      {
;;;202        *(__packed uint32_t *)dest = USB_OTG_READ_REG32(fifo);
000010  6814              LDR      r4,[r2,#0]
000012  f8414b04          STR      r4,[r1],#4
000016  1c5b              ADDS     r3,r3,#1              ;200
                  |L23.24|
000018  4283              CMP      r3,r0                 ;200
00001a  d3f9              BCC      |L23.16|
;;;203        
;;;204      }
;;;205      return ((void *)dest);
00001c  4608              MOV      r0,r1
;;;206    }
00001e  bd10              POP      {r4,pc}
;;;207    
                          ENDP


                          AREA ||i.USB_OTG_ResetPort||, CODE, READONLY, ALIGN=1

                  USB_OTG_ResetPort PROC
;;;860    */
;;;861    uint32_t USB_OTG_ResetPort(USB_OTG_CORE_HANDLE *pdev)
000000  b570              PUSH     {r4-r6,lr}
;;;862    {
000002  4605              MOV      r5,r0
;;;863      USB_OTG_HPRT0_TypeDef  hprt0;
;;;864      
;;;865      hprt0.d32 = USB_OTG_ReadHPRT0(pdev);
000004  f7fffffe          BL       USB_OTG_ReadHPRT0
;;;866      hprt0.b.prtrst = 1;
000008  f4407480          ORR      r4,r0,#0x100
;;;867      USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
00000c  f8550fcc          LDR      r0,[r5,#0xcc]!
000010  6004              STR      r4,[r0,#0]
;;;868      USB_OTG_BSP_mDelay (10);                                /* See Note #1 */
000012  200a              MOVS     r0,#0xa
000014  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;869      hprt0.b.prtrst = 0;
;;;870      USB_OTG_WRITE_REG32(pdev->regs.HPRT0, hprt0.d32);
000018  6829              LDR      r1,[r5,#0]
00001a  f4247080          BIC      r0,r4,#0x100          ;869
00001e  6008              STR      r0,[r1,#0]
;;;871      USB_OTG_BSP_mDelay (20);   
000020  2014              MOVS     r0,#0x14
000022  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;872      return 1;
000026  2001              MOVS     r0,#1
;;;873    }
000028  bd70              POP      {r4-r6,pc}
;;;874    
                          ENDP


                          AREA ||i.USB_OTG_SelectCore||, CODE, READONLY, ALIGN=2

                  USB_OTG_SelectCore PROC
;;;214    */
;;;215    USB_OTG_STS USB_OTG_SelectCore(USB_OTG_CORE_HANDLE *pdev, 
000000  b570              PUSH     {r4-r6,lr}
;;;216                                   USB_OTG_CORE_ID_TypeDef coreID)
;;;217    {
;;;218      uint32_t i , baseAddress = 0;
000002  2200              MOVS     r2,#0
;;;219      USB_OTG_STS status = USB_OTG_OK;
;;;220      
;;;221      pdev->cfg.dma_enable       = 0;
;;;222      
;;;223      /* at startup the core is in FS mode */
;;;224      pdev->cfg.speed            = USB_OTG_SPEED_FULL;
000004  2301              MOVS     r3,#1
000006  70c2              STRB     r2,[r0,#3]            ;221
;;;225      pdev->cfg.mps              = USB_OTG_FS_MAX_PACKET_SIZE ;    
000008  2640              MOVS     r6,#0x40
00000a  7083              STRB     r3,[r0,#2]            ;224
00000c  4615              MOV      r5,r2                 ;219
00000e  4614              MOV      r4,r2                 ;221
000010  8086              STRH     r6,[r0,#4]
;;;226        
;;;227      /* initialize device cfg following its address */
;;;228      if (coreID == USB_OTG_FS_CORE_ID)
000012  2901              CMP      r1,#1
000014  d001              BEQ      |L25.26|
;;;229      {
;;;230        baseAddress                = USB_OTG_FS_BASE_ADDR;
;;;231        pdev->cfg.coreID           = USB_OTG_FS_CORE_ID;
;;;232        pdev->cfg.host_channels    = 8 ;
;;;233        pdev->cfg.dev_endpoints    = 4 ;
;;;234        pdev->cfg.TotalFifoSize    = 320; /* in 32-bits */
;;;235        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;     
;;;236        
;;;237    #ifdef USB_OTG_FS_SOF_OUTPUT_ENABLED    
;;;238        pdev->cfg.Sof_output       = 1;    
;;;239    #endif 
;;;240        
;;;241    #ifdef USB_OTG_FS_LOW_PWR_MGMT_SUPPORT    
;;;242        pdev->cfg.low_power        = 1;    
;;;243    #endif     
;;;244      }
;;;245      else if (coreID == USB_OTG_HS_CORE_ID)
000016  b161              CBZ      r1,|L25.50|
000018  e014              B        |L25.68|
                  |L25.26|
00001a  72c3              STRB     r3,[r0,#0xb]          ;231
00001c  2108              MOVS     r1,#8                 ;232
00001e  7001              STRB     r1,[r0,#0]            ;232
000020  2104              MOVS     r1,#4                 ;233
000022  f04f42a0          MOV      r2,#0x50000000        ;230
000026  7041              STRB     r1,[r0,#1]            ;233
000028  1591              ASRS     r1,r2,#22             ;234
00002a  80c1              STRH     r1,[r0,#6]            ;234
00002c  2102              MOVS     r1,#2                 ;235
00002e  7201              STRB     r1,[r0,#8]            ;235
000030  e008              B        |L25.68|
                  |L25.50|
;;;246      {
;;;247        baseAddress                = USB_OTG_HS_BASE_ADDR;
;;;248        pdev->cfg.coreID           = USB_OTG_HS_CORE_ID;    
000032  72c4              STRB     r4,[r0,#0xb]
;;;249        pdev->cfg.host_channels    = 12 ;
000034  210c              MOVS     r1,#0xc
000036  7001              STRB     r1,[r0,#0]
;;;250        pdev->cfg.dev_endpoints    = 6 ;
000038  2106              MOVS     r1,#6
00003a  7041              STRB     r1,[r0,#1]
00003c  4a1f              LDR      r2,|L25.188|
;;;251        pdev->cfg.TotalFifoSize    = 1280;/* in 32-bits */
00003e  f44f61a0          MOV      r1,#0x500
000042  80c1              STRH     r1,[r0,#6]
                  |L25.68|
;;;252        
;;;253    #ifdef USB_OTG_ULPI_PHY_ENABLED
;;;254        pdev->cfg.phy_itface       = USB_OTG_ULPI_PHY;
;;;255    #else    
;;;256     #ifdef USB_OTG_EMBEDDED_PHY_ENABLED
;;;257        pdev->cfg.phy_itface       = USB_OTG_EMBEDDED_PHY;
;;;258     #else   
;;;259       #ifdef USB_OTG_I2C_PHY_ENABLED    
;;;260        pdev->cfg.phy_itface       = USB_OTG_I2C_PHY; 
;;;261       #endif
;;;262     #endif  
;;;263    #endif      
;;;264        
;;;265    #ifdef USB_OTG_HS_INTERNAL_DMA_ENABLED    
;;;266        pdev->cfg.dma_enable       = 1;    
;;;267    #endif
;;;268        
;;;269    #ifdef USB_OTG_HS_SOF_OUTPUT_ENABLED    
;;;270        pdev->cfg.Sof_output       = 1;    
;;;271    #endif 
;;;272        
;;;273    #ifdef USB_OTG_HS_LOW_PWR_MGMT_SUPPORT    
;;;274        pdev->cfg.low_power        = 1;    
;;;275    #endif 
;;;276        
;;;277      }
;;;278      
;;;279      pdev->regs.GREGS = (USB_OTG_GREGS *)(baseAddress + \
;;;280        USB_OTG_CORE_GLOBAL_REGS_OFFSET);
;;;281      pdev->regs.DREGS =  (USB_OTG_DREGS  *)  (baseAddress + \
000044  f5026100          ADD      r1,r2,#0x800
000048  e9c02103          STRD     r2,r1,[r0,#0xc]
;;;282        USB_OTG_DEV_GLOBAL_REG_OFFSET);
;;;283      
;;;284      for (i = 0; i < pdev->cfg.dev_endpoints; i++)
00004c  2100              MOVS     r1,#0
00004e  e00a              B        |L25.102|
                  |L25.80|
;;;285      {
;;;286        pdev->regs.INEP_REGS[i]  = (USB_OTG_INEPREGS *)  \
000050  eb021341          ADD      r3,r2,r1,LSL #5
000054  f5036610          ADD      r6,r3,#0x900
000058  eb000481          ADD      r4,r0,r1,LSL #2
;;;287          (baseAddress + USB_OTG_DEV_IN_EP_REG_OFFSET + \
;;;288            (i * USB_OTG_EP_REG_OFFSET));
;;;289        pdev->regs.OUTEP_REGS[i] = (USB_OTG_OUTEPREGS *) \
00005c  f5036330          ADD      r3,r3,#0xb00
000060  61a6              STR      r6,[r4,#0x18]         ;284
000062  1c49              ADDS     r1,r1,#1              ;284
000064  6563              STR      r3,[r4,#0x54]         ;284
                  |L25.102|
000066  7843              LDRB     r3,[r0,#1]            ;284
000068  428b              CMP      r3,r1                 ;284
00006a  d8f1              BHI      |L25.80|
;;;290          (baseAddress + USB_OTG_DEV_OUT_EP_REG_OFFSET + \
;;;291            (i * USB_OTG_EP_REG_OFFSET));
;;;292      }
;;;293      pdev->regs.HREGS = (USB_OTG_HREGS *)(baseAddress + \
00006c  f5026180          ADD      r1,r2,#0x400
;;;294        USB_OTG_HOST_GLOBAL_REG_OFFSET);
;;;295      pdev->regs.HPRT0 = (uint32_t *)(baseAddress + USB_OTG_HOST_PORT_REGS_OFFSET);
000070  6141              STR      r1,[r0,#0x14]
000072  3140              ADDS     r1,r1,#0x40
;;;296      
;;;297      for (i = 0; i < pdev->cfg.host_channels; i++)
000074  f8c010cc          STR      r1,[r0,#0xcc]
000078  2100              MOVS     r1,#0
00007a  e008              B        |L25.142|
                  |L25.124|
;;;298      {
;;;299        pdev->regs.HC_REGS[i] = (USB_OTG_HC_REGS *)(baseAddress + \
00007c  eb021341          ADD      r3,r2,r1,LSL #5
000080  eb000481          ADD      r4,r0,r1,LSL #2
000084  f50363a0          ADD      r3,r3,#0x500
000088  1c49              ADDS     r1,r1,#1              ;297
00008a  f8c43090          STR      r3,[r4,#0x90]         ;297
                  |L25.142|
00008e  7803              LDRB     r3,[r0,#0]            ;297
000090  428b              CMP      r3,r1                 ;297
000092  d8f3              BHI      |L25.124|
;;;300          USB_OTG_HOST_CHAN_REGS_OFFSET + \
;;;301            (i * USB_OTG_CHAN_REGS_OFFSET));
;;;302      }
;;;303      for (i = 0; i < pdev->cfg.host_channels; i++)
000094  2100              MOVS     r1,#0
000096  e008              B        |L25.170|
                  |L25.152|
;;;304      {
;;;305        pdev->regs.DFIFO[i] = (uint32_t *)(baseAddress + USB_OTG_DATA_FIFO_OFFSET +\
000098  eb023301          ADD      r3,r2,r1,LSL #12
00009c  eb000481          ADD      r4,r0,r1,LSL #2
0000a0  f5035380          ADD      r3,r3,#0x1000
0000a4  1c49              ADDS     r1,r1,#1              ;303
0000a6  f8c430d0          STR      r3,[r4,#0xd0]         ;303
                  |L25.170|
0000aa  7803              LDRB     r3,[r0,#0]            ;303
0000ac  428b              CMP      r3,r1                 ;303
0000ae  d8f3              BHI      |L25.152|
;;;306          (i * USB_OTG_DATA_FIFO_SIZE));
;;;307      }
;;;308      pdev->regs.PCGCCTL = (uint32_t *)(baseAddress + USB_OTG_PCGCCTL_OFFSET);
0000b0  f5026260          ADD      r2,r2,#0xe00
;;;309      
;;;310      return status;
0000b4  f8c0210c          STR      r2,[r0,#0x10c]
0000b8  4628              MOV      r0,r5
;;;311    }
0000ba  bd70              POP      {r4-r6,pc}
;;;312    
                          ENDP

                  |L25.188|
                          DCD      0x40040000

                          AREA ||i.USB_OTG_SetCurrentMode||, CODE, READONLY, ALIGN=1

                  USB_OTG_SetCurrentMode PROC
;;;556    */
;;;557    USB_OTG_STS USB_OTG_SetCurrentMode(USB_OTG_CORE_HANDLE *pdev , uint8_t mode)
000000  b510              PUSH     {r4,lr}
;;;558    {
;;;559      USB_OTG_STS status = USB_OTG_OK;
;;;560      USB_OTG_GUSBCFG_TypeDef  usbcfg;
;;;561      
;;;562      usbcfg.d32 = USB_OTG_READ_REG32(&pdev->regs.GREGS->GUSBCFG);
000002  68c3              LDR      r3,[r0,#0xc]
000004  2400              MOVS     r4,#0                 ;559
000006  68d8              LDR      r0,[r3,#0xc]
;;;563      
;;;564      usbcfg.b.force_host = 0;
;;;565      usbcfg.b.force_dev = 0;
;;;566      
;;;567      if ( mode == HOST_MODE)
000008  2901              CMP      r1,#1
00000a  f02042c0          BIC      r2,r0,#0x60000000     ;565
00000e  d001              BEQ      |L26.20|
;;;568      {
;;;569        usbcfg.b.force_host = 1;
;;;570      }
;;;571      else if ( mode == DEVICE_MODE)
000010  b119              CBZ      r1,|L26.26|
000012  e004              B        |L26.30|
                  |L26.20|
000014  f0425200          ORR      r2,r2,#0x20000000     ;569
000018  e001              B        |L26.30|
                  |L26.26|
;;;572      {
;;;573        usbcfg.b.force_dev = 1;
00001a  f0424280          ORR      r2,r2,#0x40000000
                  |L26.30|
;;;574      }
;;;575      
;;;576      USB_OTG_WRITE_REG32(&pdev->regs.GREGS->GUSBCFG, usbcfg.d32);
00001e  60da              STR      r2,[r3,#0xc]
;;;577      USB_OTG_BSP_mDelay(50);
000020  2032              MOVS     r0,#0x32
000022  f7fffffe          BL       USB_OTG_BSP_mDelay
;;;578      return status;
000026  4620              MOV      r0,r4
;;;579    }
000028  bd10              POP      {r4,pc}
;;;580    
                          ENDP


                          AREA ||i.USB_OTG_StopHost||, CODE, READONLY, ALIGN=1

                  USB_OTG_StopHost PROC
;;;1170   */
;;;1171   void USB_OTG_StopHost(USB_OTG_CORE_HANDLE *pdev)
000000  b510              PUSH     {r4,lr}
;;;1172   {
000002  4604              MOV      r4,r0
;;;1173     USB_OTG_HCCHAR_TypeDef  hcchar;
;;;1174     uint32_t                i;
;;;1175     
;;;1176     USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINTMSK , 0);
000004  2000              MOVS     r0,#0
000006  6961              LDR      r1,[r4,#0x14]
000008  6188              STR      r0,[r1,#0x18]
;;;1177     USB_OTG_WRITE_REG32(&pdev->regs.HREGS->HAINT,      0xFFFFFFFF);
00000a  6961              LDR      r1,[r4,#0x14]
00000c  1e40              SUBS     r0,r0,#1
00000e  6148              STR      r0,[r1,#0x14]
;;;1178     /* Flush out any leftover queued requests. */
;;;1179     
;;;1180     for (i = 0; i < pdev->cfg.host_channels; i++)
000010  2100              MOVS     r1,#0
000012  e00a              B        |L27.42|
                  |L27.20|
;;;1181     {
;;;1182       hcchar.d32 = USB_OTG_READ_REG32(&pdev->regs.HC_REGS[i]->HCCHAR);
000014  eb040081          ADD      r0,r4,r1,LSL #2
000018  f8d00090          LDR      r0,[r0,#0x90]
00001c  6802              LDR      r2,[r0,#0]
;;;1183       hcchar.b.chen = 0;
;;;1184       hcchar.b.chdis = 1;
00001e  f0222280          BIC      r2,r2,#0x80008000
;;;1185       hcchar.b.epdir = 0;
000022  f0424280          ORR      r2,r2,#0x40000000
;;;1186       USB_OTG_WRITE_REG32(&pdev->regs.HC_REGS[i]->HCCHAR, hcchar.d32);
000026  6002              STR      r2,[r0,#0]
000028  1c49              ADDS     r1,r1,#1              ;1180
                  |L27.42|
00002a  7820              LDRB     r0,[r4,#0]            ;1180
00002c  4288              CMP      r0,r1                 ;1180
00002e  d8f1              BHI      |L27.20|
;;;1187     }
;;;1188     
;;;1189     /* Flush the FIFO */
;;;1190     USB_OTG_FlushRxFifo(pdev);
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       USB_OTG_FlushRxFifo
;;;1191     USB_OTG_FlushTxFifo(pdev ,  0x10 );  
000036  4620              MOV      r0,r4
000038  e8bd4010          POP      {r4,lr}
00003c  2110              MOVS     r1,#0x10
00003e  f7ffbffe          B.W      USB_OTG_FlushTxFifo
;;;1192   }
;;;1193   #endif
                          ENDP


                          AREA ||i.USB_OTG_WritePacket||, CODE, READONLY, ALIGN=1

                  USB_OTG_WritePacket PROC
;;;161    */
;;;162    USB_OTG_STS USB_OTG_WritePacket(USB_OTG_CORE_HANDLE *pdev, 
000000  b530              PUSH     {r4,r5,lr}
;;;163                                    uint8_t             *src, 
;;;164                                    uint8_t             ch_ep_num, 
;;;165                                    uint16_t            len)
;;;166    {
000002  4605              MOV      r5,r0
;;;167      USB_OTG_STS status = USB_OTG_OK;
000004  2000              MOVS     r0,#0
;;;168      if (pdev->cfg.dma_enable == 0)
000006  78ec              LDRB     r4,[r5,#3]
000008  2c00              CMP      r4,#0                 ;166
00000a  d10c              BNE      |L28.38|
;;;169      {
;;;170        uint32_t count32b= 0 , i= 0;
;;;171        __IO uint32_t *fifo;
;;;172        
;;;173        count32b =  (len + 3) / 4;
;;;174        fifo = pdev->regs.DFIFO[ch_ep_num];
00000c  eb050282          ADD      r2,r5,r2,LSL #2
000010  1cdb              ADDS     r3,r3,#3              ;173
000012  089b              LSRS     r3,r3,#2              ;173
000014  f8d220d0          LDR      r2,[r2,#0xd0]
;;;175        for (i = 0; i < count32b; i++, src+=4)
000018  e003              B        |L28.34|
                  |L28.26|
;;;176        {
;;;177          USB_OTG_WRITE_REG32( fifo, *((__packed uint32_t *)src) );
00001a  f8515b04          LDR      r5,[r1],#4
00001e  6015              STR      r5,[r2,#0]
000020  1c64              ADDS     r4,r4,#1              ;175
                  |L28.34|
000022  429c              CMP      r4,r3                 ;175
000024  d3f9              BCC      |L28.26|
                  |L28.38|
;;;178        }
;;;179      }
;;;180      return status;
;;;181    }
000026  bd30              POP      {r4,r5,pc}
;;;182    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Libraries\\STM32_USB_OTG_Driver\\usb_core.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_usb_core_c_0d2ec05c____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___10_usb_core_c_0d2ec05c____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_usb_core_c_0d2ec05c____REVSH|
#line 128
|__asm___10_usb_core_c_0d2ec05c____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
