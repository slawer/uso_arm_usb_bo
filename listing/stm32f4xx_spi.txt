; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\media_usb_key\stm32f4xx_spi.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\media_usb_key\stm32f4xx_spi.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\media_usb_key\stm32f4xx_spi.crf Libraries\CMSIS\stm32f4xx_spi.c]
                          THUMB

                          AREA ||i.I2S_Cmd||, CODE, READONLY, ALIGN=1

                  I2S_Cmd PROC
;;;534      */
;;;535    void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;536    {
;;;537      /* Check the parameters */
;;;538      assert_param(IS_SPI_23_PERIPH_EXT(SPIx));
;;;539      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;540      
;;;541      if (NewState != DISABLE)
;;;542      {
;;;543        /* Enable the selected SPI peripheral (in I2S mode) */
;;;544        SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
;;;545      }
;;;546      else
;;;547      {
;;;548        /* Disable the selected SPI peripheral in I2S mode */
;;;549        SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
000002  8b81              LDRH     r1,[r0,#0x1c]
000004  d002              BEQ      |L1.12|
000006  f4416180          ORR      r1,r1,#0x400          ;544
00000a  e001              B        |L1.16|
                  |L1.12|
00000c  f4216180          BIC      r1,r1,#0x400
                  |L1.16|
000010  8381              STRH     r1,[r0,#0x1c]         ;544
;;;550      }
;;;551    }
000012  4770              BX       lr
;;;552    
                          ENDP


                          AREA ||i.I2S_FullDuplexConfig||, CODE, READONLY, ALIGN=1

                  I2S_FullDuplexConfig PROC
;;;699      */
;;;700    void I2S_FullDuplexConfig(SPI_TypeDef* I2Sxext, I2S_InitTypeDef* I2S_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;701    {
;;;702      uint16_t tmpreg = 0, tmp = 0;
;;;703      
;;;704      /* Check the I2S parameters */
;;;705      assert_param(IS_I2S_EXT_PERIPH(I2Sxext));
;;;706      assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
;;;707      assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
;;;708      assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
;;;709      assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
;;;710    
;;;711    /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
;;;712      /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
;;;713      I2Sxext->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
000002  8b82              LDRH     r2,[r0,#0x1c]
000004  2300              MOVS     r3,#0                 ;702
000006  f24f0440          MOV      r4,#0xf040
00000a  4022              ANDS     r2,r2,r4
00000c  8382              STRH     r2,[r0,#0x1c]
;;;714      I2Sxext->I2SPR = 0x0002;
00000e  2202              MOVS     r2,#2
000010  8402              STRH     r2,[r0,#0x20]
;;;715      
;;;716      /* Get the I2SCFGR register value */
;;;717      tmpreg = I2Sxext->I2SCFGR;
000012  8b84              LDRH     r4,[r0,#0x1c]
;;;718      
;;;719      /* Get the mode to be configured for the extended I2S */
;;;720      if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterTx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveTx))
000014  880a              LDRH     r2,[r1,#0]
;;;721      {
;;;722        tmp = I2S_Mode_SlaveRx;
000016  f44f7580          MOV      r5,#0x100
00001a  f5b27f00          CMP      r2,#0x200             ;720
00001e  d000              BEQ      |L2.34|
000020  b902              CBNZ     r2,|L2.36|
                  |L2.34|
000022  462b              MOV      r3,r5
                  |L2.36|
;;;723      }
;;;724      else
;;;725      {
;;;726        if ((I2S_InitStruct->I2S_Mode == I2S_Mode_MasterRx) || (I2S_InitStruct->I2S_Mode == I2S_Mode_SlaveRx))
;;;727        {
;;;728          tmp = I2S_Mode_SlaveTx;
;;;729        }
;;;730      }
;;;731    
;;;732     
;;;733      /* Configure the I2S with the SPI_InitStruct values */
;;;734      tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(tmp | \
000024  884a              LDRH     r2,[r1,#2]
000026  888d              LDRH     r5,[r1,#4]
000028  8989              LDRH     r1,[r1,#0xc]
00002a  432a              ORRS     r2,r2,r5
00002c  4319              ORRS     r1,r1,r3
00002e  430a              ORRS     r2,r2,r1
000030  4322              ORRS     r2,r2,r4
000032  f4426100          ORR      r1,r2,#0x800
;;;735                      (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
;;;736                      (uint16_t)I2S_InitStruct->I2S_CPOL))));
;;;737     
;;;738      /* Write to SPIx I2SCFGR */  
;;;739      I2Sxext->I2SCFGR = tmpreg;
000036  8381              STRH     r1,[r0,#0x1c]
;;;740    }
000038  bd30              POP      {r4,r5,pc}
;;;741    
                          ENDP


                          AREA ||i.I2S_Init||, CODE, READONLY, ALIGN=2

                  I2S_Init PROC
;;;320      */
;;;321    void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
000000  b5f0              PUSH     {r4-r7,lr}
;;;322    {
;;;323      uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
000002  2202              MOVS     r2,#2
000004  2300              MOVS     r3,#0
;;;324      uint32_t tmp = 0, i2sclk = 0;
;;;325    #ifndef I2S_EXTERNAL_CLOCK_VAL
;;;326      uint32_t pllm = 0, plln = 0, pllr = 0;
;;;327    #endif /* I2S_EXTERNAL_CLOCK_VAL */
;;;328      
;;;329      /* Check the I2S parameters */
;;;330      assert_param(IS_SPI_23_PERIPH(SPIx));
;;;331      assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
;;;332      assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
;;;333      assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
;;;334      assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
;;;335      assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
;;;336      assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
;;;337    
;;;338    /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
;;;339      /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
;;;340      SPIx->I2SCFGR &= I2SCFGR_CLEAR_MASK; 
000006  8b85              LDRH     r5,[r0,#0x1c]
000008  2401              MOVS     r4,#1                 ;323
00000a  f24f0640          MOV      r6,#0xf040
00000e  4035              ANDS     r5,r5,r6
000010  8385              STRH     r5,[r0,#0x1c]
;;;341      SPIx->I2SPR = 0x0002;
000012  8402              STRH     r2,[r0,#0x20]
;;;342      
;;;343      /* Get the I2SCFGR register value */
;;;344      tmpreg = SPIx->I2SCFGR;
000014  8b85              LDRH     r5,[r0,#0x1c]
;;;345      
;;;346      /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
;;;347      if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
000016  688e              LDR      r6,[r1,#8]
000018  2e02              CMP      r6,#2
00001a  d038              BEQ      |L3.142|
;;;348      {
;;;349        i2sodd = (uint16_t)0;
;;;350        i2sdiv = (uint16_t)2;   
;;;351      }
;;;352      /* If the requested audio frequency is not the default, compute the prescaler */
;;;353      else
;;;354      {
;;;355        /* Check the frame length (For the Prescaler computing) *******************/
;;;356        if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
00001c  888a              LDRH     r2,[r1,#4]
00001e  b102              CBZ      r2,|L3.34|
;;;357        {
;;;358          /* Packet length is 16 bits */
;;;359          packetlength = 1;
;;;360        }
;;;361        else
;;;362        {
;;;363          /* Packet length is 32 bits */
;;;364          packetlength = 2;
000020  2402              MOVS     r4,#2
                  |L3.34|
;;;365        }
;;;366    
;;;367        /* Get I2S source Clock frequency  ****************************************/
;;;368          
;;;369        /* If an external I2S clock has to be used, this define should be set  
;;;370           in the project configuration or in the stm32f4xx_conf.h file */
;;;371      #ifdef I2S_EXTERNAL_CLOCK_VAL     
;;;372        /* Set external clock as I2S clock source */
;;;373        if ((RCC->CFGR & RCC_CFGR_I2SSRC) == 0)
;;;374        {
;;;375          RCC->CFGR |= (uint32_t)RCC_CFGR_I2SSRC;
;;;376        }
;;;377        
;;;378        /* Set the I2S clock to the external clock  value */
;;;379        i2sclk = I2S_EXTERNAL_CLOCK_VAL;
;;;380    
;;;381      #else /* There is no define for External I2S clock source */
;;;382        /* Set PLLI2S as I2S clock source */
;;;383        if ((RCC->CFGR & RCC_CFGR_I2SSRC) != 0)
000022  4a26              LDR      r2,|L3.188|
000024  6813              LDR      r3,[r2,#0]
000026  021b              LSLS     r3,r3,#8
000028  d503              BPL      |L3.50|
;;;384        {
;;;385          RCC->CFGR &= ~(uint32_t)RCC_CFGR_I2SSRC;
00002a  6813              LDR      r3,[r2,#0]
00002c  f4230300          BIC      r3,r3,#0x800000
000030  6013              STR      r3,[r2,#0]
                  |L3.50|
;;;386        }    
;;;387        
;;;388        /* Get the PLLI2SN value */
;;;389        plln = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SN) >> 6) & \
000032  4a22              LDR      r2,|L3.188|
000034  327c              ADDS     r2,r2,#0x7c
000036  6813              LDR      r3,[r2,#0]
;;;390                          (RCC_PLLI2SCFGR_PLLI2SN >> 6));
;;;391        
;;;392        /* Get the PLLI2SR value */
;;;393        pllr = (uint32_t)(((RCC->PLLI2SCFGR & RCC_PLLI2SCFGR_PLLI2SR) >> 28) & \
000038  6812              LDR      r2,[r2,#0]
00003a  f3c31388          UBFX     r3,r3,#6,#9           ;389
;;;394                          (RCC_PLLI2SCFGR_PLLI2SR >> 28));
;;;395        
;;;396        /* Get the PLLM value */
;;;397        pllm = (uint32_t)(RCC->PLLCFGR & RCC_PLLCFGR_PLLM);      
00003e  4e1f              LDR      r6,|L3.188|
000040  f3c27202          UBFX     r2,r2,#28,#3          ;393
000044  1f36              SUBS     r6,r6,#4
000046  6836              LDR      r6,[r6,#0]
;;;398        
;;;399        /* Get the I2S source clock value */
;;;400        i2sclk = (uint32_t)(((HSE_VALUE / pllm) * plln) / pllr);
000048  4f1d              LDR      r7,|L3.192|
00004a  f006063f          AND      r6,r6,#0x3f           ;397
00004e  fbb7f6f6          UDIV     r6,r7,r6
000052  435e              MULS     r6,r3,r6
000054  fbb6f2f2          UDIV     r2,r6,r2
;;;401      #endif /* I2S_EXTERNAL_CLOCK_VAL */
;;;402        
;;;403        /* Compute the Real divider depending on the MCLK output state, with a floating point */
;;;404        if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
000058  88cb              LDRH     r3,[r1,#6]
00005a  f5b37f00          CMP      r3,#0x200
00005e  d02b              BEQ      |L3.184|
;;;405        {
;;;406          /* MCLK output is enabled */
;;;407          tmp = (uint16_t)(((((i2sclk / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
;;;408        }
;;;409        else
;;;410        {
;;;411          /* MCLK output is disabled */
;;;412          tmp = (uint16_t)(((((i2sclk / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
000060  0163              LSLS     r3,r4,#5
000062  fbb2f2f3          UDIV     r2,r2,r3
                  |L3.102|
000066  eb020282          ADD      r2,r2,r2,LSL #2
00006a  688b              LDR      r3,[r1,#8]
00006c  0052              LSLS     r2,r2,#1
00006e  fbb2f2f3          UDIV     r2,r2,r3
000072  1d52              ADDS     r2,r2,#5
000074  b292              UXTH     r2,r2
;;;413        }
;;;414        
;;;415        /* Remove the flatting point */
;;;416        tmp = tmp / 10;  
000076  230a              MOVS     r3,#0xa
000078  fbb2f2f3          UDIV     r2,r2,r3
;;;417          
;;;418        /* Check the parity of the divider */
;;;419        i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
00007c  f0020301          AND      r3,r2,#1
;;;420       
;;;421        /* Compute the i2sdiv prescaler */
;;;422        i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
000080  1ad2              SUBS     r2,r2,r3
;;;423       
;;;424        /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
;;;425        i2sodd = (uint16_t) (i2sodd << 8);
000082  f64f74ff          MOV      r4,#0xffff
000086  f3c2024f          UBFX     r2,r2,#1,#16          ;422
00008a  ea042303          AND      r3,r4,r3,LSL #8
                  |L3.142|
;;;426      }
;;;427    
;;;428      /* Test if the divider is 1 or 0 or greater than 0xFF */
;;;429      if ((i2sdiv < 2) || (i2sdiv > 0xFF))
00008e  1e94              SUBS     r4,r2,#2
000090  2cfe              CMP      r4,#0xfe
000092  d301              BCC      |L3.152|
;;;430      {
;;;431        /* Set the default values */
;;;432        i2sdiv = 2;
000094  2202              MOVS     r2,#2
;;;433        i2sodd = 0;
000096  2300              MOVS     r3,#0
                  |L3.152|
;;;434      }
;;;435    
;;;436      /* Write to SPIx I2SPR register the computed value */
;;;437      SPIx->I2SPR = (uint16_t)((uint16_t)i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
000098  88cc              LDRH     r4,[r1,#6]
00009a  431a              ORRS     r2,r2,r3
00009c  4314              ORRS     r4,r4,r2
00009e  8404              STRH     r4,[r0,#0x20]
;;;438     
;;;439      /* Configure the I2S with the SPI_InitStruct values */
;;;440      tmpreg |= (uint16_t)((uint16_t)SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
0000a0  880a              LDRH     r2,[r1,#0]
0000a2  884b              LDRH     r3,[r1,#2]
0000a4  431a              ORRS     r2,r2,r3
0000a6  888b              LDRH     r3,[r1,#4]
0000a8  8989              LDRH     r1,[r1,#0xc]
0000aa  430b              ORRS     r3,r3,r1
0000ac  431a              ORRS     r2,r2,r3
0000ae  432a              ORRS     r2,r2,r5
0000b0  f4426100          ORR      r1,r2,#0x800
;;;441                      (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
;;;442                      (uint16_t)I2S_InitStruct->I2S_CPOL))));
;;;443     
;;;444      /* Write to SPIx I2SCFGR */  
;;;445      SPIx->I2SCFGR = tmpreg;
0000b4  8381              STRH     r1,[r0,#0x1c]
;;;446    }
0000b6  bdf0              POP      {r4-r7,pc}
                  |L3.184|
0000b8  0a12              LSRS     r2,r2,#8              ;407
0000ba  e7d4              B        |L3.102|
;;;447    
                          ENDP

                  |L3.188|
                          DCD      0x40023808
                  |L3.192|
                          DCD      0x007a1200

                          AREA ||i.I2S_StructInit||, CODE, READONLY, ALIGN=1

                  I2S_StructInit PROC
;;;480      */
;;;481    void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
000000  2100              MOVS     r1,#0
;;;482    {
;;;483    /*--------------- Reset I2S init structure parameters values -----------------*/
;;;484      /* Initialize the I2S_Mode member */
;;;485      I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
000002  8001              STRH     r1,[r0,#0]
;;;486      
;;;487      /* Initialize the I2S_Standard member */
;;;488      I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
000004  8041              STRH     r1,[r0,#2]
;;;489      
;;;490      /* Initialize the I2S_DataFormat member */
;;;491      I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
000006  8081              STRH     r1,[r0,#4]
;;;492      
;;;493      /* Initialize the I2S_MCLKOutput member */
;;;494      I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;495      
;;;496      /* Initialize the I2S_AudioFreq member */
;;;497      I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
00000a  2202              MOVS     r2,#2
;;;498      
;;;499      /* Initialize the I2S_CPOL member */
;;;500      I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
00000c  6082              STR      r2,[r0,#8]
00000e  8181              STRH     r1,[r0,#0xc]
;;;501    }
000010  4770              BX       lr
;;;502    
                          ENDP


                          AREA ||i.SPI_BiDirectionalLineConfig||, CODE, READONLY, ALIGN=1

                  SPI_BiDirectionalLineConfig PROC
;;;581      */
;;;582    void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
000000  f5b14f80          CMP      r1,#0x4000
;;;583    {
;;;584      /* Check the parameters */
;;;585      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;586      assert_param(IS_SPI_DIRECTION(SPI_Direction));
;;;587      if (SPI_Direction == SPI_Direction_Tx)
;;;588      {
;;;589        /* Set the Tx only mode */
;;;590        SPIx->CR1 |= SPI_Direction_Tx;
;;;591      }
;;;592      else
;;;593      {
;;;594        /* Set the Rx only mode */
;;;595        SPIx->CR1 &= SPI_Direction_Rx;
000004  8801              LDRH     r1,[r0,#0]
000006  d003              BEQ      |L5.16|
000008  f4214180          BIC      r1,r1,#0x4000
                  |L5.12|
00000c  8001              STRH     r1,[r0,#0]            ;590
;;;596      }
;;;597    }
00000e  4770              BX       lr
                  |L5.16|
000010  f4414180          ORR      r1,r1,#0x4000         ;590
000014  e7fa              B        |L5.12|
;;;598    
                          ENDP


                          AREA ||i.SPI_CalculateCRC||, CODE, READONLY, ALIGN=1

                  SPI_CalculateCRC PROC
;;;879      */
;;;880    void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;881    {
;;;882      /* Check the parameters */
;;;883      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;884      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;885      if (NewState != DISABLE)
;;;886      {
;;;887        /* Enable the selected SPI CRC calculation */
;;;888        SPIx->CR1 |= SPI_CR1_CRCEN;
;;;889      }
;;;890      else
;;;891      {
;;;892        /* Disable the selected SPI CRC calculation */
;;;893        SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L6.12|
000006  f4415100          ORR      r1,r1,#0x2000         ;888
00000a  e001              B        |L6.16|
                  |L6.12|
00000c  f4215100          BIC      r1,r1,#0x2000
                  |L6.16|
000010  8001              STRH     r1,[r0,#0]            ;888
;;;894      }
;;;895    }
000012  4770              BX       lr
;;;896    
                          ENDP


                          AREA ||i.SPI_Cmd||, CODE, READONLY, ALIGN=1

                  SPI_Cmd PROC
;;;509      */
;;;510    void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;511    {
;;;512      /* Check the parameters */
;;;513      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;514      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;515      if (NewState != DISABLE)
;;;516      {
;;;517        /* Enable the selected SPI peripheral */
;;;518        SPIx->CR1 |= SPI_CR1_SPE;
;;;519      }
;;;520      else
;;;521      {
;;;522        /* Disable the selected SPI peripheral */
;;;523        SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L7.12|
000006  f0410140          ORR      r1,r1,#0x40           ;518
00000a  e001              B        |L7.16|
                  |L7.12|
00000c  f0210140          BIC      r1,r1,#0x40
                  |L7.16|
000010  8001              STRH     r1,[r0,#0]            ;518
;;;524      }
;;;525    }
000012  4770              BX       lr
;;;526    
                          ENDP


                          AREA ||i.SPI_DataSizeConfig||, CODE, READONLY, ALIGN=1

                  SPI_DataSizeConfig PROC
;;;561      */
;;;562    void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
000000  8802              LDRH     r2,[r0,#0]
;;;563    {
;;;564      /* Check the parameters */
;;;565      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;566      assert_param(IS_SPI_DATASIZE(SPI_DataSize));
;;;567      /* Clear DFF bit */
;;;568      SPIx->CR1 &= (uint16_t)~SPI_DataSize_16b;
000002  f4226200          BIC      r2,r2,#0x800
000006  8002              STRH     r2,[r0,#0]
;;;569      /* Set new DFF bit value */
;;;570      SPIx->CR1 |= SPI_DataSize;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;571    }
00000e  4770              BX       lr
;;;572    
                          ENDP


                          AREA ||i.SPI_GetCRC||, CODE, READONLY, ALIGN=1

                  SPI_GetCRC PROC
;;;919      */
;;;920    uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
000000  2901              CMP      r1,#1
;;;921    {
000002  d001              BEQ      |L9.8|
;;;922      uint16_t crcreg = 0;
;;;923      /* Check the parameters */
;;;924      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;925      assert_param(IS_SPI_CRC(SPI_CRC));
;;;926      if (SPI_CRC != SPI_CRC_Rx)
;;;927      {
;;;928        /* Get the Tx CRC register */
;;;929        crcreg = SPIx->TXCRCR;
000004  8b00              LDRH     r0,[r0,#0x18]
;;;930      }
;;;931      else
;;;932      {
;;;933        /* Get the Rx CRC register */
;;;934        crcreg = SPIx->RXCRCR;
;;;935      }
;;;936      /* Return the selected CRC register */
;;;937      return crcreg;
;;;938    }
000006  4770              BX       lr
                  |L9.8|
000008  8a80              LDRH     r0,[r0,#0x14]         ;934
00000a  4770              BX       lr
;;;939    
                          ENDP


                          AREA ||i.SPI_GetCRCPolynomial||, CODE, READONLY, ALIGN=1

                  SPI_GetCRCPolynomial PROC
;;;944      */
;;;945    uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
000000  8a00              LDRH     r0,[r0,#0x10]
;;;946    {
;;;947      /* Check the parameters */
;;;948      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;949      
;;;950      /* Return the CRC polynomial register */
;;;951      return SPIx->CRCPR;
;;;952    }
000002  4770              BX       lr
;;;953    
                          ENDP


                          AREA ||i.SPI_I2S_ClearFlag||, CODE, READONLY, ALIGN=1

                  SPI_I2S_ClearFlag PROC
;;;1175     */
;;;1176   void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
000000  43c9              MVNS     r1,r1
;;;1177   {
;;;1178     /* Check the parameters */
;;;1179     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;1180     assert_param(IS_SPI_I2S_CLEAR_FLAG(SPI_I2S_FLAG));
;;;1181       
;;;1182     /* Clear the selected SPI CRC Error (CRCERR) flag */
;;;1183     SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
000002  8101              STRH     r1,[r0,#8]
;;;1184   }
000004  4770              BX       lr
;;;1185   
                          ENDP


                          AREA ||i.SPI_I2S_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  SPI_I2S_ClearITPendingBit PROC
;;;1255     */
;;;1256   void SPI_I2S_ClearITPendingBit(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
000000  f001020f          AND      r2,r1,#0xf
;;;1257   {
;;;1258     uint16_t itpos = 0;
;;;1259     /* Check the parameters */
;;;1260     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;1261     assert_param(IS_SPI_I2S_CLEAR_IT(SPI_I2S_IT));
;;;1262   
;;;1263     /* Get the SPI_I2S IT index */
;;;1264     itpos = 0x01 << (SPI_I2S_IT & 0x0F);
000004  2101              MOVS     r1,#1
000006  4091              LSLS     r1,r1,r2
;;;1265   
;;;1266     /* Clear the selected SPI CRC Error (CRCERR) interrupt pending bit */
;;;1267     SPIx->SR = (uint16_t)~itpos;
000008  43c9              MVNS     r1,r1
00000a  8101              STRH     r1,[r0,#8]
;;;1268   }
00000c  4770              BX       lr
;;;1269   
                          ENDP


                          AREA ||i.SPI_I2S_DMACmd||, CODE, READONLY, ALIGN=1

                  SPI_I2S_DMACmd PROC
;;;981      */
;;;982    void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;983    {
;;;984      /* Check the parameters */
;;;985      assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;986      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;987      assert_param(IS_SPI_I2S_DMAREQ(SPI_I2S_DMAReq));
;;;988    
;;;989      if (NewState != DISABLE)
;;;990      {
;;;991        /* Enable the selected SPI DMA requests */
;;;992        SPIx->CR2 |= SPI_I2S_DMAReq;
;;;993      }
;;;994      else
;;;995      {
;;;996        /* Disable the selected SPI DMA requests */
;;;997        SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
000002  8882              LDRH     r2,[r0,#4]
000004  d001              BEQ      |L13.10|
000006  430a              ORRS     r2,r2,r1              ;992
000008  e000              B        |L13.12|
                  |L13.10|
00000a  438a              BICS     r2,r2,r1
                  |L13.12|
00000c  8082              STRH     r2,[r0,#4]            ;992
;;;998      }
;;;999    }
00000e  4770              BX       lr
;;;1000   
                          ENDP


                          AREA ||i.SPI_I2S_DeInit||, CODE, READONLY, ALIGN=2

                  SPI_I2S_DeInit PROC
;;;217      */
;;;218    void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
000000  4911              LDR      r1,|L14.72|
;;;219    {
000002  b510              PUSH     {r4,lr}
;;;220      /* Check the parameters */
;;;221      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;222    
;;;223      if (SPIx == SPI1)
000004  4288              CMP      r0,r1
000006  d10a              BNE      |L14.30|
;;;224      {
;;;225        /* Enable SPI1 reset state */
;;;226        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
000008  1484              ASRS     r4,r0,#18
00000a  2101              MOVS     r1,#1
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;227        /* Release SPI1 from reset state */
;;;228        RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  2100              MOVS     r1,#0
00001a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L14.30|
;;;229      }
;;;230      else if (SPIx == SPI2)
00001e  490b              LDR      r1,|L14.76|
000020  4288              CMP      r0,r1
000022  d102              BNE      |L14.42|
;;;231      {
;;;232        /* Enable SPI2 reset state */
;;;233        RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
000024  2101              MOVS     r1,#1
000026  1404              ASRS     r4,r0,#16
;;;234        /* Release SPI2 from reset state */
;;;235        RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
000028  e004              B        |L14.52|
                  |L14.42|
;;;236        }
;;;237      else
;;;238      {
;;;239        if (SPIx == SPI3)
00002a  4909              LDR      r1,|L14.80|
00002c  4288              CMP      r0,r1
00002e  d10a              BNE      |L14.70|
;;;240        {
;;;241          /* Enable SPI3 reset state */
;;;242          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, ENABLE);
000030  2101              MOVS     r1,#1
000032  13c4              ASRS     r4,r0,#15
                  |L14.52|
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;243          /* Release SPI3 from reset state */
;;;244          RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI3, DISABLE);
00003a  4620              MOV      r0,r4
00003c  e8bd4010          POP      {r4,lr}
000040  2100              MOVS     r1,#0
000042  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L14.70|
;;;245        }
;;;246      }
;;;247    }
000046  bd10              POP      {r4,pc}
;;;248    
                          ENDP

                  |L14.72|
                          DCD      0x40013000
                  |L14.76|
                          DCD      0x40003800
                  |L14.80|
                          DCD      0x40003c00

                          AREA ||i.SPI_I2S_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  SPI_I2S_GetFlagStatus PROC
;;;1134     */
;;;1135   FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
000000  4602              MOV      r2,r0
;;;1136   {
;;;1137     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1138     /* Check the parameters */
;;;1139     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;1140     assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
;;;1141     
;;;1142     /* Check the status of the specified SPI flag */
;;;1143     if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
000004  8912              LDRH     r2,[r2,#8]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L15.12|
;;;1144     {
;;;1145       /* SPI_I2S_FLAG is set */
;;;1146       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L15.12|
;;;1147     }
;;;1148     else
;;;1149     {
;;;1150       /* SPI_I2S_FLAG is reset */
;;;1151       bitstatus = RESET;
;;;1152     }
;;;1153     /* Return the SPI_I2S_FLAG status */
;;;1154     return  bitstatus;
;;;1155   }
00000c  4770              BX       lr
;;;1156   
                          ENDP


                          AREA ||i.SPI_I2S_GetITStatus||, CODE, READONLY, ALIGN=1

                  SPI_I2S_GetITStatus PROC
;;;1200     */
;;;1201   ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
000000  b530              PUSH     {r4,r5,lr}
;;;1202   {
;;;1203     ITStatus bitstatus = RESET;
;;;1204     uint16_t itpos = 0, itmask = 0, enablestatus = 0;
;;;1205   
;;;1206     /* Check the parameters */
;;;1207     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;1208     assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
;;;1209   
;;;1210     /* Get the SPI_I2S_IT index */
;;;1211     itpos = 0x01 << (SPI_I2S_IT & 0x0F);
000002  f001030f          AND      r3,r1,#0xf
000006  2501              MOVS     r5,#1
000008  4602              MOV      r2,r0                 ;1202
00000a  fa05f403          LSL      r4,r5,r3
00000e  2000              MOVS     r0,#0                 ;1203
000010  b2a3              UXTH     r3,r4
;;;1212   
;;;1213     /* Get the SPI_I2S_IT IT mask */
;;;1214     itmask = SPI_I2S_IT >> 4;
000012  0909              LSRS     r1,r1,#4
;;;1215   
;;;1216     /* Set the IT mask */
;;;1217     itmask = 0x01 << itmask;
000014  fa05f401          LSL      r4,r5,r1
;;;1218   
;;;1219     /* Get the SPI_I2S_IT enable bit status */
;;;1220     enablestatus = (SPIx->CR2 & itmask) ;
000018  8891              LDRH     r1,[r2,#4]
00001a  b2a4              UXTH     r4,r4                 ;1217
;;;1221   
;;;1222     /* Check the status of the specified SPI interrupt */
;;;1223     if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
00001c  8912              LDRH     r2,[r2,#8]
00001e  4021              ANDS     r1,r1,r4              ;1220
000020  421a              TST      r2,r3
000022  d002              BEQ      |L16.42|
000024  2900              CMP      r1,#0
000026  d000              BEQ      |L16.42|
;;;1224     {
;;;1225       /* SPI_I2S_IT is set */
;;;1226       bitstatus = SET;
000028  2001              MOVS     r0,#1
                  |L16.42|
;;;1227     }
;;;1228     else
;;;1229     {
;;;1230       /* SPI_I2S_IT is reset */
;;;1231       bitstatus = RESET;
;;;1232     }
;;;1233     /* Return the SPI_I2S_IT status */
;;;1234     return bitstatus;
;;;1235   }
00002a  bd30              POP      {r4,r5,pc}
;;;1236   
                          ENDP


                          AREA ||i.SPI_I2S_ITConfig||, CODE, READONLY, ALIGN=1

                  SPI_I2S_ITConfig PROC
;;;1090     */
;;;1091   void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
000000  0909              LSRS     r1,r1,#4
;;;1092   {
;;;1093     uint16_t itpos = 0, itmask = 0 ;
;;;1094     
;;;1095     /* Check the parameters */
;;;1096     assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;1097     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1098     assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
;;;1099   
;;;1100     /* Get the SPI IT index */
;;;1101     itpos = SPI_I2S_IT >> 4;
;;;1102   
;;;1103     /* Set the IT mask */
;;;1104     itmask = (uint16_t)1 << (uint16_t)itpos;
000002  2301              MOVS     r3,#1
000004  408b              LSLS     r3,r3,r1
;;;1105   
;;;1106     if (NewState != DISABLE)
000006  2a00              CMP      r2,#0
;;;1107     {
;;;1108       /* Enable the selected SPI interrupt */
;;;1109       SPIx->CR2 |= itmask;
;;;1110     }
;;;1111     else
;;;1112     {
;;;1113       /* Disable the selected SPI interrupt */
;;;1114       SPIx->CR2 &= (uint16_t)~itmask;
000008  8882              LDRH     r2,[r0,#4]
00000a  b299              UXTH     r1,r3                 ;1104
00000c  d001              BEQ      |L17.18|
00000e  430a              ORRS     r2,r2,r1              ;1109
000010  e000              B        |L17.20|
                  |L17.18|
000012  438a              BICS     r2,r2,r1
                  |L17.20|
000014  8082              STRH     r2,[r0,#4]            ;1109
;;;1115     }
;;;1116   }
000016  4770              BX       lr
;;;1117   
                          ENDP


                          AREA ||i.SPI_I2S_ReceiveData||, CODE, READONLY, ALIGN=1

                  SPI_I2S_ReceiveData PROC
;;;774      */
;;;775    uint16_t SPI_I2S_ReceiveData(SPI_TypeDef* SPIx)
000000  8980              LDRH     r0,[r0,#0xc]
;;;776    {
;;;777      /* Check the parameters */
;;;778      assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;779      
;;;780      /* Return the data in the DR register */
;;;781      return SPIx->DR;
;;;782    }
000002  4770              BX       lr
;;;783    
                          ENDP


                          AREA ||i.SPI_I2S_SendData||, CODE, READONLY, ALIGN=1

                  SPI_I2S_SendData PROC
;;;790      */
;;;791    void SPI_I2S_SendData(SPI_TypeDef* SPIx, uint16_t Data)
000000  8181              STRH     r1,[r0,#0xc]
;;;792    {
;;;793      /* Check the parameters */
;;;794      assert_param(IS_SPI_ALL_PERIPH_EXT(SPIx));
;;;795      
;;;796      /* Write in the DR register the data to be sent */
;;;797      SPIx->DR = Data;
;;;798    }
000002  4770              BX       lr
;;;799    
                          ENDP


                          AREA ||i.SPI_Init||, CODE, READONLY, ALIGN=1

                  SPI_Init PROC
;;;256      */
;;;257    void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;258    {
;;;259      uint16_t tmpreg = 0;
;;;260      
;;;261      /* check the parameters */
;;;262      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;263      
;;;264      /* Check the SPI parameters */
;;;265      assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
;;;266      assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
;;;267      assert_param(IS_SPI_DATASIZE(SPI_InitStruct->SPI_DataSize));
;;;268      assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
;;;269      assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
;;;270      assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
;;;271      assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
;;;272      assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
;;;273      assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
;;;274    
;;;275    /*---------------------------- SPIx CR1 Configuration ------------------------*/
;;;276      /* Get the SPIx CR1 value */
;;;277      tmpreg = SPIx->CR1;
000002  8802              LDRH     r2,[r0,#0]
;;;278      /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, MSTR, CPOL and CPHA bits */
;;;279      tmpreg &= CR1_CLEAR_MASK;
;;;280      /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
;;;281         master/salve mode, CPOL and CPHA */
;;;282      /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
;;;283      /* Set SSM, SSI and MSTR bits according to SPI_Mode and SPI_NSS values */
;;;284      /* Set LSBFirst bit according to SPI_FirstBit value */
;;;285      /* Set BR bits according to SPI_BaudRatePrescaler value */
;;;286      /* Set CPOL bit according to SPI_CPOL value */
;;;287      /* Set CPHA bit according to SPI_CPHA value */
;;;288      tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_Mode |
000004  884c              LDRH     r4,[r1,#2]
000006  f4025341          AND      r3,r2,#0x3040         ;279
00000a  880a              LDRH     r2,[r1,#0]
00000c  88cd              LDRH     r5,[r1,#6]
00000e  4322              ORRS     r2,r2,r4
000010  888c              LDRH     r4,[r1,#4]
000012  432c              ORRS     r4,r4,r5
000014  4322              ORRS     r2,r2,r4
000016  890c              LDRH     r4,[r1,#8]
000018  4322              ORRS     r2,r2,r4
00001a  894c              LDRH     r4,[r1,#0xa]
00001c  4322              ORRS     r2,r2,r4
00001e  898c              LDRH     r4,[r1,#0xc]
000020  4322              ORRS     r2,r2,r4
000022  89cc              LDRH     r4,[r1,#0xe]
000024  4322              ORRS     r2,r2,r4
000026  431a              ORRS     r2,r2,r3
;;;289                      SPI_InitStruct->SPI_DataSize | SPI_InitStruct->SPI_CPOL |  
;;;290                      SPI_InitStruct->SPI_CPHA | SPI_InitStruct->SPI_NSS |  
;;;291                      SPI_InitStruct->SPI_BaudRatePrescaler | SPI_InitStruct->SPI_FirstBit);
;;;292      /* Write to SPIx CR1 */
;;;293      SPIx->CR1 = tmpreg;
000028  8002              STRH     r2,[r0,#0]
;;;294    
;;;295      /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
;;;296      SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
00002a  8b82              LDRH     r2,[r0,#0x1c]
00002c  f4226200          BIC      r2,r2,#0x800
000030  8382              STRH     r2,[r0,#0x1c]
;;;297    /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
;;;298      /* Write to SPIx CRCPOLY */
;;;299      SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
000032  8a09              LDRH     r1,[r1,#0x10]
000034  8201              STRH     r1,[r0,#0x10]
;;;300    }
000036  bd30              POP      {r4,r5,pc}
;;;301    
                          ENDP


                          AREA ||i.SPI_NSSInternalSoftwareConfig||, CODE, READONLY, ALIGN=1

                  SPI_NSSInternalSoftwareConfig PROC
;;;607      */
;;;608    void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
000000  f5a1427e          SUB      r2,r1,#0xfe00
;;;609    {
;;;610      /* Check the parameters */
;;;611      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;612      assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
;;;613      if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
;;;614      {
;;;615        /* Set NSS pin internally by software */
;;;616        SPIx->CR1 |= SPI_NSSInternalSoft_Set;
;;;617      }
;;;618      else
;;;619      {
;;;620        /* Reset NSS pin internally by software */
;;;621        SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
000004  8801              LDRH     r1,[r0,#0]
000006  3aff              SUBS     r2,r2,#0xff           ;613
000008  d002              BEQ      |L21.16|
00000a  f4417180          ORR      r1,r1,#0x100          ;616
00000e  e001              B        |L21.20|
                  |L21.16|
000010  f4217180          BIC      r1,r1,#0x100
                  |L21.20|
000014  8001              STRH     r1,[r0,#0]            ;616
;;;622      }
;;;623    }
000016  4770              BX       lr
;;;624    
                          ENDP


                          AREA ||i.SPI_SSOutputCmd||, CODE, READONLY, ALIGN=1

                  SPI_SSOutputCmd PROC
;;;631      */
;;;632    void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;633    {
;;;634      /* Check the parameters */
;;;635      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;636      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;637      if (NewState != DISABLE)
;;;638      {
;;;639        /* Enable the selected SPI SS output */
;;;640        SPIx->CR2 |= (uint16_t)SPI_CR2_SSOE;
;;;641      }
;;;642      else
;;;643      {
;;;644        /* Disable the selected SPI SS output */
;;;645        SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L22.12|
000006  f0410104          ORR      r1,r1,#4              ;640
00000a  e001              B        |L22.16|
                  |L22.12|
00000c  f0210104          BIC      r1,r1,#4
                  |L22.16|
000010  8081              STRH     r1,[r0,#4]            ;640
;;;646      }
;;;647    }
000012  4770              BX       lr
;;;648    
                          ENDP


                          AREA ||i.SPI_StructInit||, CODE, READONLY, ALIGN=1

                  SPI_StructInit PROC
;;;452      */
;;;453    void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
000000  2100              MOVS     r1,#0
;;;454    {
;;;455    /*--------------- Reset SPI init structure parameters values -----------------*/
;;;456      /* Initialize the SPI_Direction member */
;;;457      SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
000002  8001              STRH     r1,[r0,#0]
;;;458      /* initialize the SPI_Mode member */
;;;459      SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
000004  8041              STRH     r1,[r0,#2]
;;;460      /* initialize the SPI_DataSize member */
;;;461      SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
000006  8081              STRH     r1,[r0,#4]
;;;462      /* Initialize the SPI_CPOL member */
;;;463      SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
000008  80c1              STRH     r1,[r0,#6]
;;;464      /* Initialize the SPI_CPHA member */
;;;465      SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
00000a  8101              STRH     r1,[r0,#8]
;;;466      /* Initialize the SPI_NSS member */
;;;467      SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
00000c  8141              STRH     r1,[r0,#0xa]
;;;468      /* Initialize the SPI_BaudRatePrescaler member */
;;;469      SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
00000e  8181              STRH     r1,[r0,#0xc]
;;;470      /* Initialize the SPI_FirstBit member */
;;;471      SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
000010  81c1              STRH     r1,[r0,#0xe]
;;;472      /* Initialize the SPI_CRCPolynomial member */
;;;473      SPI_InitStruct->SPI_CRCPolynomial = 7;
000012  2107              MOVS     r1,#7
000014  8201              STRH     r1,[r0,#0x10]
;;;474    }
000016  4770              BX       lr
;;;475    
                          ENDP


                          AREA ||i.SPI_TIModeCmd||, CODE, READONLY, ALIGN=1

                  SPI_TIModeCmd PROC
;;;662      */
;;;663    void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;664    {
;;;665      /* Check the parameters */
;;;666      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;667      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;668    
;;;669      if (NewState != DISABLE)
;;;670      {
;;;671        /* Enable the TI mode for the selected SPI peripheral */
;;;672        SPIx->CR2 |= SPI_CR2_FRF;
;;;673      }
;;;674      else
;;;675      {
;;;676        /* Disable the TI mode for the selected SPI peripheral */
;;;677        SPIx->CR2 &= (uint16_t)~SPI_CR2_FRF;
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L24.12|
000006  f0410110          ORR      r1,r1,#0x10           ;672
00000a  e001              B        |L24.16|
                  |L24.12|
00000c  f0210110          BIC      r1,r1,#0x10
                  |L24.16|
000010  8081              STRH     r1,[r0,#4]            ;672
;;;678      }
;;;679    }
000012  4770              BX       lr
;;;680    
                          ENDP


                          AREA ||i.SPI_TransmitCRC||, CODE, READONLY, ALIGN=1

                  SPI_TransmitCRC PROC
;;;901      */
;;;902    void SPI_TransmitCRC(SPI_TypeDef* SPIx)
000000  8801              LDRH     r1,[r0,#0]
;;;903    {
;;;904      /* Check the parameters */
;;;905      assert_param(IS_SPI_ALL_PERIPH(SPIx));
;;;906      
;;;907      /* Enable the selected SPI CRC transmission */
;;;908      SPIx->CR1 |= SPI_CR1_CRCNEXT;
000002  f4415180          ORR      r1,r1,#0x1000
000006  8001              STRH     r1,[r0,#0]
;;;909    }
000008  4770              BX       lr
;;;910    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Libraries\\CMSIS\\stm32f4xx_spi.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_spi_c_2b928927____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___15_stm32f4xx_spi_c_2b928927____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_spi_c_2b928927____REVSH|
#line 128
|__asm___15_stm32f4xx_spi_c_2b928927____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
