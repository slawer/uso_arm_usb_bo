; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\media_usb_key\stm32f4xx_rcc.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\media_usb_key\stm32f4xx_rcc.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\media_usb_key\stm32f4xx_rcc.crf Libraries\CMSIS\stm32f4xx_rcc.c]
                          THUMB

                          AREA ||i.RCC_AHB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockCmd PROC
;;;1084     */
;;;1085   void RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L1.20|
;;;1086   {
;;;1087     /* Check the parameters */
;;;1088     assert_param(IS_RCC_AHB1_CLOCK_PERIPH(RCC_AHB1Periph));
;;;1089   
;;;1090     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1091     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1092     {
;;;1093       RCC->AHB1ENR |= RCC_AHB1Periph;
;;;1094     }
;;;1095     else
;;;1096     {
;;;1097       RCC->AHB1ENR &= ~RCC_AHB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L1.12|
000008  4301              ORRS     r1,r1,r0              ;1093
00000a  e000              B        |L1.14|
                  |L1.12|
00000c  4381              BICS     r1,r1,r0
                  |L1.14|
00000e  6011              STR      r1,[r2,#0]            ;1093
;;;1098     }
;;;1099   }
000010  4770              BX       lr
;;;1100   
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      0x40023830

                          AREA ||i.RCC_AHB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphClockLPModeCmd PROC
;;;1454     */
;;;1455   void RCC_AHB1PeriphClockLPModeCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L2.20|
;;;1456   {
;;;1457     /* Check the parameters */
;;;1458     assert_param(IS_RCC_AHB1_LPMODE_PERIPH(RCC_AHB1Periph));
;;;1459     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1460     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1461     {
;;;1462       RCC->AHB1LPENR |= RCC_AHB1Periph;
;;;1463     }
;;;1464     else
;;;1465     {
;;;1466       RCC->AHB1LPENR &= ~RCC_AHB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L2.12|
000008  4301              ORRS     r1,r1,r0              ;1462
00000a  e000              B        |L2.14|
                  |L2.12|
00000c  4381              BICS     r1,r1,r0
                  |L2.14|
00000e  6011              STR      r1,[r2,#0]            ;1462
;;;1467     }
;;;1468   }
000010  4770              BX       lr
;;;1469   
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40023850

                          AREA ||i.RCC_AHB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB1PeriphResetCmd PROC
;;;1272     */
;;;1273   void RCC_AHB1PeriphResetCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L3.20|
;;;1274   {
;;;1275     /* Check the parameters */
;;;1276     assert_param(IS_RCC_AHB1_RESET_PERIPH(RCC_AHB1Periph));
;;;1277     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1278   
;;;1279     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1280     {
;;;1281       RCC->AHB1RSTR |= RCC_AHB1Periph;
;;;1282     }
;;;1283     else
;;;1284     {
;;;1285       RCC->AHB1RSTR &= ~RCC_AHB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L3.12|
000008  4301              ORRS     r1,r1,r0              ;1281
00000a  e000              B        |L3.14|
                  |L3.12|
00000c  4381              BICS     r1,r1,r0
                  |L3.14|
00000e  6011              STR      r1,[r2,#0]            ;1281
;;;1286     }
;;;1287   }
000010  4770              BX       lr
;;;1288   
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40023810

                          AREA ||i.RCC_AHB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockCmd PROC
;;;1116     */
;;;1117   void RCC_AHB2PeriphClockCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L4.20|
;;;1118   {
;;;1119     /* Check the parameters */
;;;1120     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1121     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1122   
;;;1123     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1124     {
;;;1125       RCC->AHB2ENR |= RCC_AHB2Periph;
;;;1126     }
;;;1127     else
;;;1128     {
;;;1129       RCC->AHB2ENR &= ~RCC_AHB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L4.12|
000008  4301              ORRS     r1,r1,r0              ;1125
00000a  e000              B        |L4.14|
                  |L4.12|
00000c  4381              BICS     r1,r1,r0
                  |L4.14|
00000e  6011              STR      r1,[r2,#0]            ;1125
;;;1130     }
;;;1131   }
000010  4770              BX       lr
;;;1132   
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40023834

                          AREA ||i.RCC_AHB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphClockLPModeCmd PROC
;;;1486     */
;;;1487   void RCC_AHB2PeriphClockLPModeCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L5.20|
;;;1488   {
;;;1489     /* Check the parameters */
;;;1490     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1491     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1492     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1493     {
;;;1494       RCC->AHB2LPENR |= RCC_AHB2Periph;
;;;1495     }
;;;1496     else
;;;1497     {
;;;1498       RCC->AHB2LPENR &= ~RCC_AHB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L5.12|
000008  4301              ORRS     r1,r1,r0              ;1494
00000a  e000              B        |L5.14|
                  |L5.12|
00000c  4381              BICS     r1,r1,r0
                  |L5.14|
00000e  6011              STR      r1,[r2,#0]            ;1494
;;;1499     }
;;;1500   }
000010  4770              BX       lr
;;;1501   
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40023854

                          AREA ||i.RCC_AHB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB2PeriphResetCmd PROC
;;;1301     */
;;;1302   void RCC_AHB2PeriphResetCmd(uint32_t RCC_AHB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L6.20|
;;;1303   {
;;;1304     /* Check the parameters */
;;;1305     assert_param(IS_RCC_AHB2_PERIPH(RCC_AHB2Periph));
;;;1306     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1307   
;;;1308     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1309     {
;;;1310       RCC->AHB2RSTR |= RCC_AHB2Periph;
;;;1311     }
;;;1312     else
;;;1313     {
;;;1314       RCC->AHB2RSTR &= ~RCC_AHB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L6.12|
000008  4301              ORRS     r1,r1,r0              ;1310
00000a  e000              B        |L6.14|
                  |L6.12|
00000c  4381              BICS     r1,r1,r0
                  |L6.14|
00000e  6011              STR      r1,[r2,#0]            ;1310
;;;1315     }
;;;1316   }
000010  4770              BX       lr
;;;1317   
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40023814

                          AREA ||i.RCC_AHB3PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockCmd PROC
;;;1143     */
;;;1144   void RCC_AHB3PeriphClockCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L7.20|
;;;1145   {
;;;1146     /* Check the parameters */
;;;1147     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));  
;;;1148     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1149   
;;;1150     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1151     {
;;;1152       RCC->AHB3ENR |= RCC_AHB3Periph;
;;;1153     }
;;;1154     else
;;;1155     {
;;;1156       RCC->AHB3ENR &= ~RCC_AHB3Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L7.12|
000008  4301              ORRS     r1,r1,r0              ;1152
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  4381              BICS     r1,r1,r0
                  |L7.14|
00000e  6011              STR      r1,[r2,#0]            ;1152
;;;1157     }
;;;1158   }
000010  4770              BX       lr
;;;1159   
                          ENDP

000012  0000              DCW      0x0000
                  |L7.20|
                          DCD      0x40023838

                          AREA ||i.RCC_AHB3PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphClockLPModeCmd PROC
;;;1513     */
;;;1514   void RCC_AHB3PeriphClockLPModeCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L8.20|
;;;1515   {
;;;1516     /* Check the parameters */
;;;1517     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1518     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1519     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1520     {
;;;1521       RCC->AHB3LPENR |= RCC_AHB3Periph;
;;;1522     }
;;;1523     else
;;;1524     {
;;;1525       RCC->AHB3LPENR &= ~RCC_AHB3Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L8.12|
000008  4301              ORRS     r1,r1,r0              ;1521
00000a  e000              B        |L8.14|
                  |L8.12|
00000c  4381              BICS     r1,r1,r0
                  |L8.14|
00000e  6011              STR      r1,[r2,#0]            ;1521
;;;1526     }
;;;1527   }
000010  4770              BX       lr
;;;1528   
                          ENDP

000012  0000              DCW      0x0000
                  |L8.20|
                          DCD      0x40023858

                          AREA ||i.RCC_AHB3PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHB3PeriphResetCmd PROC
;;;1325     */
;;;1326   void RCC_AHB3PeriphResetCmd(uint32_t RCC_AHB3Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L9.20|
;;;1327   {
;;;1328     /* Check the parameters */
;;;1329     assert_param(IS_RCC_AHB3_PERIPH(RCC_AHB3Periph));
;;;1330     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1331   
;;;1332     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1333     {
;;;1334       RCC->AHB3RSTR |= RCC_AHB3Periph;
;;;1335     }
;;;1336     else
;;;1337     {
;;;1338       RCC->AHB3RSTR &= ~RCC_AHB3Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L9.12|
000008  4301              ORRS     r1,r1,r0              ;1334
00000a  e000              B        |L9.14|
                  |L9.12|
00000c  4381              BICS     r1,r1,r0
                  |L9.14|
00000e  6011              STR      r1,[r2,#0]            ;1334
;;;1339     }
;;;1340   }
000010  4770              BX       lr
;;;1341   
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40023818

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1193     */
;;;1194   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L10.20|
;;;1195   {
;;;1196     /* Check the parameters */
;;;1197     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));  
;;;1198     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1199   
;;;1200     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1201     {
;;;1202       RCC->APB1ENR |= RCC_APB1Periph;
;;;1203     }
;;;1204     else
;;;1205     {
;;;1206       RCC->APB1ENR &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L10.12|
000008  4301              ORRS     r1,r1,r0              ;1202
00000a  e000              B        |L10.14|
                  |L10.12|
00000c  4381              BICS     r1,r1,r0
                  |L10.14|
00000e  6011              STR      r1,[r2,#0]            ;1202
;;;1207     }
;;;1208   }
000010  4770              BX       lr
;;;1209   
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x40023840

                          AREA ||i.RCC_APB1PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockLPModeCmd PROC
;;;1563     */
;;;1564   void RCC_APB1PeriphClockLPModeCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L11.20|
;;;1565   {
;;;1566     /* Check the parameters */
;;;1567     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1568     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1569     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1570     {
;;;1571       RCC->APB1LPENR |= RCC_APB1Periph;
;;;1572     }
;;;1573     else
;;;1574     {
;;;1575       RCC->APB1LPENR &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L11.12|
000008  4301              ORRS     r1,r1,r0              ;1571
00000a  e000              B        |L11.14|
                  |L11.12|
00000c  4381              BICS     r1,r1,r0
                  |L11.14|
00000e  6011              STR      r1,[r2,#0]            ;1571
;;;1576     }
;;;1577   }
000010  4770              BX       lr
;;;1578   
                          ENDP

000012  0000              DCW      0x0000
                  |L11.20|
                          DCD      0x40023860

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1372     */
;;;1373   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L12.20|
;;;1374   {
;;;1375     /* Check the parameters */
;;;1376     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1377     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1378     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1379     {
;;;1380       RCC->APB1RSTR |= RCC_APB1Periph;
;;;1381     }
;;;1382     else
;;;1383     {
;;;1384       RCC->APB1RSTR &= ~RCC_APB1Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L12.12|
000008  4301              ORRS     r1,r1,r0              ;1380
00000a  e000              B        |L12.14|
                  |L12.12|
00000c  4381              BICS     r1,r1,r0
                  |L12.14|
00000e  6011              STR      r1,[r2,#0]            ;1380
;;;1385     }
;;;1386   }
000010  4770              BX       lr
;;;1387   
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      0x40023820

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1233     */
;;;1234   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L13.20|
;;;1235   {
;;;1236     /* Check the parameters */
;;;1237     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1238     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1239   
;;;1240     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1241     {
;;;1242       RCC->APB2ENR |= RCC_APB2Periph;
;;;1243     }
;;;1244     else
;;;1245     {
;;;1246       RCC->APB2ENR &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L13.12|
000008  4301              ORRS     r1,r1,r0              ;1242
00000a  e000              B        |L13.14|
                  |L13.12|
00000c  4381              BICS     r1,r1,r0
                  |L13.14|
00000e  6011              STR      r1,[r2,#0]            ;1242
;;;1247     }
;;;1248   }
000010  4770              BX       lr
;;;1249   
                          ENDP

000012  0000              DCW      0x0000
                  |L13.20|
                          DCD      0x40023844

                          AREA ||i.RCC_APB2PeriphClockLPModeCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockLPModeCmd PROC
;;;1603     */
;;;1604   void RCC_APB2PeriphClockLPModeCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L14.20|
;;;1605   {
;;;1606     /* Check the parameters */
;;;1607     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1608     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1609     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1610     {
;;;1611       RCC->APB2LPENR |= RCC_APB2Periph;
;;;1612     }
;;;1613     else
;;;1614     {
;;;1615       RCC->APB2LPENR &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L14.12|
000008  4301              ORRS     r1,r1,r0              ;1611
00000a  e000              B        |L14.14|
                  |L14.12|
00000c  4381              BICS     r1,r1,r0
                  |L14.14|
00000e  6011              STR      r1,[r2,#0]            ;1611
;;;1616     }
;;;1617   }
000010  4770              BX       lr
;;;1618   
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40023864

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1408     */
;;;1409   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L15.20|
;;;1410   {
;;;1411     /* Check the parameters */
;;;1412     assert_param(IS_RCC_APB2_RESET_PERIPH(RCC_APB2Periph));
;;;1413     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1414     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1415     {
;;;1416       RCC->APB2RSTR |= RCC_APB2Periph;
;;;1417     }
;;;1418     else
;;;1419     {
;;;1420       RCC->APB2RSTR &= ~RCC_APB2Periph;
000004  6811              LDR      r1,[r2,#0]
000006  d001              BEQ      |L15.12|
000008  4301              ORRS     r1,r1,r0              ;1416
00000a  e000              B        |L15.14|
                  |L15.12|
00000c  4381              BICS     r1,r1,r0
                  |L15.14|
00000e  6011              STR      r1,[r2,#0]            ;1416
;;;1421     }
;;;1422   }
000010  4770              BX       lr
;;;1423   
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      0x40023824

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;291      */
;;;292    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4a03              LDR      r2,|L16.16|
;;;293    {
;;;294      uint32_t tmpreg = 0;
;;;295      /* Check the parameters */
;;;296      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;297    
;;;298      tmpreg = RCC->CR;
000002  6811              LDR      r1,[r2,#0]
;;;299    
;;;300      /* Clear HSITRIM[4:0] bits */
;;;301      tmpreg &= ~RCC_CR_HSITRIM;
000004  f02101f8          BIC      r1,r1,#0xf8
;;;302    
;;;303      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;304      tmpreg |= (uint32_t)HSICalibrationValue << 3;
000008  ea4100c0          ORR      r0,r1,r0,LSL #3
;;;305    
;;;306      /* Store the new value */
;;;307      RCC->CR = tmpreg;
00000c  6010              STR      r0,[r2,#0]
;;;308    }
00000e  4770              BX       lr
;;;309    
                          ENDP

                  |L16.16|
                          DCD      0x40023800

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1028     */
;;;1029   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L17.8|
;;;1030   {
;;;1031     /* Check the parameters */
;;;1032     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1033     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1034   }
000004  4770              BX       lr
;;;1035   
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x42470e40

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1729     */
;;;1730   void RCC_ClearFlag(void)
000000  4802              LDR      r0,|L18.12|
;;;1731   {
;;;1732     /* Set RMVF bit to clear the reset flags */
;;;1733     RCC->CSR |= RCC_CSR_RMVF;
000002  6801              LDR      r1,[r0,#0]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6001              STR      r1,[r0,#0]
;;;1734   }
00000a  4770              BX       lr
;;;1735   
                          ENDP

                  |L18.12|
                          DCD      0x40023874

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1781     */
;;;1782   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L19.8|
;;;1783   {
;;;1784     /* Check the parameters */
;;;1785     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1786   
;;;1787     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1788        pending bits */
;;;1789     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7008              STRB     r0,[r1,#0]
;;;1790   }
000004  4770              BX       lr
;;;1791   
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x4002380e

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;517      */
;;;518    void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L20.8|
;;;519    {
;;;520      /* Check the parameters */
;;;521      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;522      *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;523    }
000004  4770              BX       lr
;;;524    
                          ENDP

000006  0000              DCW      0x0000
                  |L20.8|
                          DCD      0x42470000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;195      */
;;;196    void RCC_DeInit(void)
000000  480b              LDR      r0,|L21.48|
;;;197    {
;;;198      /* Set HSION bit */
;;;199      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;200    
;;;201      /* Reset CFGR register */
;;;202      RCC->CFGR = 0x00000000;
00000a  4a09              LDR      r2,|L21.48|
00000c  2100              MOVS     r1,#0
00000e  3208              ADDS     r2,r2,#8
000010  6011              STR      r1,[r2,#0]
;;;203    
;;;204      /* Reset HSEON, CSSON and PLLON bits */
;;;205      RCC->CR &= (uint32_t)0xFEF6FFFF;
000012  6802              LDR      r2,[r0,#0]
000014  4b07              LDR      r3,|L21.52|
000016  401a              ANDS     r2,r2,r3
000018  6002              STR      r2,[r0,#0]
;;;206    
;;;207      /* Reset PLLCFGR register */
;;;208      RCC->PLLCFGR = 0x24003010;
00001a  1d03              ADDS     r3,r0,#4
00001c  4a06              LDR      r2,|L21.56|
00001e  601a              STR      r2,[r3,#0]
;;;209    
;;;210      /* Reset HSEBYP bit */
;;;211      RCC->CR &= (uint32_t)0xFFFBFFFF;
000020  6802              LDR      r2,[r0,#0]
000022  f4222280          BIC      r2,r2,#0x40000
000026  6002              STR      r2,[r0,#0]
;;;212    
;;;213      /* Disable all interrupts */
;;;214      RCC->CIR = 0x00000000;
000028  4801              LDR      r0,|L21.48|
00002a  300c              ADDS     r0,r0,#0xc
00002c  6001              STR      r1,[r0,#0]
;;;215    }
00002e  4770              BX       lr
;;;216    
                          ENDP

                  |L21.48|
                          DCD      0x40023800
                  |L21.52|
                          DCD      0xfef6ffff
                  |L21.56|
                          DCD      0x24003010

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;854      */
;;;855    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  b570              PUSH     {r4-r6,lr}
;;;856    {
;;;857      uint32_t tmp = 0, presc = 0, pllvco = 0, pllp = 2, pllsource = 0, pllm = 2;
;;;858    
;;;859      /* Get SYSCLK source -------------------------------------------------------*/
;;;860      tmp = RCC->CFGR & RCC_CFGR_SWS;
000002  4b20              LDR      r3,|L22.132|
000004  6819              LDR      r1,[r3,#0]
;;;861    
;;;862      switch (tmp)
;;;863      {
;;;864        case 0x00:  /* HSI used as system clock source */
;;;865          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000006  4c20              LDR      r4,|L22.136|
000008  f011010c          ANDS     r1,r1,#0xc            ;860
00000c  d004              BEQ      |L22.24|
;;;866          break;
;;;867        case 0x04:  /* HSE used as system clock  source */
;;;868          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
00000e  1066              ASRS     r6,r4,#1
000010  2904              CMP      r1,#4                 ;862
000012  d003              BEQ      |L22.28|
000014  2908              CMP      r1,#8                 ;862
000016  d003              BEQ      |L22.32|
                  |L22.24|
000018  6004              STR      r4,[r0,#0]            ;866
00001a  e01b              B        |L22.84|
                  |L22.28|
;;;869          break;
00001c  6006              STR      r6,[r0,#0]
00001e  e019              B        |L22.84|
                  |L22.32|
;;;870        case 0x08:  /* PLL used as system clock  source */
;;;871    
;;;872          /* PLL_VCO = (HSE_VALUE or HSI_VALUE / PLLM) * PLLN
;;;873             SYSCLK = PLL_VCO / PLLP
;;;874             */    
;;;875          pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC) >> 22;
000020  4a18              LDR      r2,|L22.132|
000022  1f12              SUBS     r2,r2,#4
000024  6811              LDR      r1,[r2,#0]
000026  f3c15580          UBFX     r5,r1,#22,#1
;;;876          pllm = RCC->PLLCFGR & RCC_PLLCFGR_PLLM;
00002a  6811              LDR      r1,[r2,#0]
00002c  f001013f          AND      r1,r1,#0x3f
;;;877          
;;;878          if (pllsource != 0)
000030  b115              CBZ      r5,|L22.56|
;;;879          {
;;;880            /* HSE used as PLL clock source */
;;;881            pllvco = (HSE_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);
000032  fbb6f1f1          UDIV     r1,r6,r1
000036  e001              B        |L22.60|
                  |L22.56|
;;;882          }
;;;883          else
;;;884          {
;;;885            /* HSI used as PLL clock source */
;;;886            pllvco = (HSI_VALUE / pllm) * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 6);      
000038  fbb4f1f1          UDIV     r1,r4,r1
                  |L22.60|
00003c  6814              LDR      r4,[r2,#0]
;;;887          }
;;;888    
;;;889          pllp = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLP) >>16) + 1 ) *2;
00003e  6812              LDR      r2,[r2,#0]
000040  f3c41488          UBFX     r4,r4,#6,#9           ;886
000044  4361              MULS     r1,r4,r1              ;886
000046  f3c24201          UBFX     r2,r2,#16,#2
00004a  1c52              ADDS     r2,r2,#1
00004c  0052              LSLS     r2,r2,#1
;;;890          RCC_Clocks->SYSCLK_Frequency = pllvco/pllp;
00004e  fbb1f1f2          UDIV     r1,r1,r2
000052  6001              STR      r1,[r0,#0]
                  |L22.84|
;;;891          break;
;;;892        default:
;;;893          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
;;;894          break;
;;;895      }
;;;896      /* Compute HCLK, PCLK1 and PCLK2 clocks frequencies ------------------------*/
;;;897    
;;;898      /* Get HCLK prescaler */
;;;899      tmp = RCC->CFGR & RCC_CFGR_HPRE;
000054  6819              LDR      r1,[r3,#0]
;;;900      tmp = tmp >> 4;
;;;901      presc = APBAHBPrescTable[tmp];
;;;902      /* HCLK clock frequency */
;;;903      RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
;;;904    
;;;905      /* Get PCLK1 prescaler */
;;;906      tmp = RCC->CFGR & RCC_CFGR_PPRE1;
;;;907      tmp = tmp >> 10;
;;;908      presc = APBAHBPrescTable[tmp];
;;;909      /* PCLK1 clock frequency */
;;;910      RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;911    
;;;912      /* Get PCLK2 prescaler */
;;;913      tmp = RCC->CFGR & RCC_CFGR_PPRE2;
;;;914      tmp = tmp >> 13;
;;;915      presc = APBAHBPrescTable[tmp];
;;;916      /* PCLK2 clock frequency */
;;;917      RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
;;;918    }
000056  220f              MOVS     r2,#0xf
000058  ea021111          AND      r1,r2,r1,LSR #4
00005c  4a0b              LDR      r2,|L22.140|
00005e  5c54              LDRB     r4,[r2,r1]            ;901
000060  6801              LDR      r1,[r0,#0]            ;903
000062  40e1              LSRS     r1,r1,r4              ;903
000064  6041              STR      r1,[r0,#4]            ;906
000066  681c              LDR      r4,[r3,#0]            ;906
000068  2507              MOVS     r5,#7
00006a  ea052494          AND      r4,r5,r4,LSR #10
00006e  5d14              LDRB     r4,[r2,r4]            ;908
000070  fa21f404          LSR      r4,r1,r4              ;910
000074  6084              STR      r4,[r0,#8]            ;913
000076  681b              LDR      r3,[r3,#0]            ;913
000078  ea053353          AND      r3,r5,r3,LSR #13
00007c  5cd2              LDRB     r2,[r2,r3]            ;915
00007e  40d1              LSRS     r1,r1,r2              ;917
000080  60c1              STR      r1,[r0,#0xc]          ;917
000082  bd70              POP      {r4-r6,pc}
;;;919    
                          ENDP

                  |L22.132|
                          DCD      0x40023808
                  |L22.136|
                          DCD      0x00f42400
                  |L22.140|
                          DCD      ||.data||

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1684     */
;;;1685   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  4602              MOV      r2,r0
;;;1686   {
;;;1687     uint32_t tmp = 0;
;;;1688     uint32_t statusreg = 0;
;;;1689     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1690   
;;;1691     /* Check the parameters */
;;;1692     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1693   
;;;1694     /* Get the RCC register index */
;;;1695     tmp = RCC_FLAG >> 5;
000004  0951              LSRS     r1,r2,#5
;;;1696     if (tmp == 1)               /* The flag to check is in CR register */
000006  2901              CMP      r1,#1
000008  d00b              BEQ      |L23.34|
;;;1697     {
;;;1698       statusreg = RCC->CR;
;;;1699     }
;;;1700     else if (tmp == 2)          /* The flag to check is in BDCR register */
00000a  2902              CMP      r1,#2
00000c  d00c              BEQ      |L23.40|
;;;1701     {
;;;1702       statusreg = RCC->BDCR;
;;;1703     }
;;;1704     else                       /* The flag to check is in CSR register */
;;;1705     {
;;;1706       statusreg = RCC->CSR;
00000e  4908              LDR      r1,|L23.48|
                  |L23.16|
000010  6809              LDR      r1,[r1,#0]            ;1702
;;;1707     }
;;;1708   
;;;1709     /* Get the flag position */
;;;1710     tmp = RCC_FLAG & FLAG_MASK;
000012  f002021f          AND      r2,r2,#0x1f
;;;1711     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000016  2301              MOVS     r3,#1
000018  4093              LSLS     r3,r3,r2
00001a  420b              TST      r3,r1
00001c  d000              BEQ      |L23.32|
;;;1712     {
;;;1713       bitstatus = SET;
00001e  2001              MOVS     r0,#1
                  |L23.32|
;;;1714     }
;;;1715     else
;;;1716     {
;;;1717       bitstatus = RESET;
;;;1718     }
;;;1719     /* Return the flag status */
;;;1720     return bitstatus;
;;;1721   }
000020  4770              BX       lr
                  |L23.34|
000022  4903              LDR      r1,|L23.48|
000024  3974              SUBS     r1,r1,#0x74           ;1698
000026  e7f3              B        |L23.16|
                  |L23.40|
000028  4901              LDR      r1,|L23.48|
00002a  1f09              SUBS     r1,r1,#4              ;1702
00002c  e7f0              B        |L23.16|
;;;1722   
                          ENDP

00002e  0000              DCW      0x0000
                  |L23.48|
                          DCD      0x40023874

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1748     */
;;;1749   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4a03              LDR      r2,|L24.16|
;;;1750   {
000002  4601              MOV      r1,r0
;;;1751     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1752   
;;;1753     /* Check the parameters */
;;;1754     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1755   
;;;1756     /* Check the status of the specified RCC interrupt */
;;;1757     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000006  6812              LDR      r2,[r2,#0]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L24.14|
;;;1758     {
;;;1759       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L24.14|
;;;1760     }
;;;1761     else
;;;1762     {
;;;1763       bitstatus = RESET;
;;;1764     }
;;;1765     /* Return the RCC_IT status */
;;;1766     return  bitstatus;
;;;1767   }
00000e  4770              BX       lr
;;;1768   
                          ENDP

                  |L24.16|
                          DCD      0x4002380c

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;714      */
;;;715    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L25.12|
;;;716    {
;;;717      return ((uint8_t)(RCC->CFGR & RCC_CFGR_SWS));
000002  6800              LDR      r0,[r0,#0]
000004  f000000c          AND      r0,r0,#0xc
;;;718    }
000008  4770              BX       lr
;;;719    
                          ENDP

00000a  0000              DCW      0x0000
                  |L25.12|
                          DCD      0x40023808

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;739      */
;;;740    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4a03              LDR      r2,|L26.16|
;;;741    {
;;;742      uint32_t tmpreg = 0;
;;;743      
;;;744      /* Check the parameters */
;;;745      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;746    
;;;747      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;748    
;;;749      /* Clear HPRE[3:0] bits */
;;;750      tmpreg &= ~RCC_CFGR_HPRE;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;751    
;;;752      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;753      tmpreg |= RCC_SYSCLK;
000008  4301              ORRS     r1,r1,r0
;;;754    
;;;755      /* Store the new value */
;;;756      RCC->CFGR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;757    }
00000c  4770              BX       lr
;;;758    
                          ENDP

00000e  0000              DCW      0x0000
                  |L26.16|
                          DCD      0x40023808

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;236      */
;;;237    void RCC_HSEConfig(uint8_t RCC_HSE)
000000  4902              LDR      r1,|L27.12|
;;;238    {
;;;239      /* Check the parameters */
;;;240      assert_param(IS_RCC_HSE(RCC_HSE));
;;;241    
;;;242      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;243      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE_OFF;
000002  2200              MOVS     r2,#0
000004  700a              STRB     r2,[r1,#0]
;;;244    
;;;245      /* Set the new HSE configuration -------------------------------------------*/
;;;246      *(__IO uint8_t *) CR_BYTE3_ADDRESS = RCC_HSE;
000006  7008              STRB     r0,[r1,#0]
;;;247    }
000008  4770              BX       lr
;;;248    
                          ENDP

00000a  0000              DCW      0x0000
                  |L27.12|
                          DCD      0x40023802

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;327      */
;;;328    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;329    {
;;;330      /* Check the parameters */
;;;331      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;332    
;;;333      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;334    }
000004  4770              BX       lr
;;;335    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x42470000

                          AREA ||i.RCC_I2SCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_I2SCLKConfig PROC
;;;1045     */
;;;1046   void RCC_I2SCLKConfig(uint32_t RCC_I2SCLKSource)
000000  4901              LDR      r1,|L29.8|
;;;1047   {
;;;1048     /* Check the parameters */
;;;1049     assert_param(IS_RCC_I2SCLK_SOURCE(RCC_I2SCLKSource));
;;;1050   
;;;1051     *(__IO uint32_t *) CFGR_I2SSRC_BB = RCC_I2SCLKSource;
000002  6008              STR      r0,[r1,#0]
;;;1052   }
000004  4770              BX       lr
;;;1053   
                          ENDP

000006  0000              DCW      0x0000
                  |L29.8|
                          DCD      0x4247015c

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;1648     */
;;;1649   void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L30.20|
;;;1650   {
;;;1651     /* Check the parameters */
;;;1652     assert_param(IS_RCC_IT(RCC_IT));
;;;1653     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1654     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1655     {
;;;1656       /* Perform Byte access to RCC_CIR[14:8] bits to enable the selected interrupts */
;;;1657       *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
;;;1658     }
;;;1659     else
;;;1660     {
;;;1661       /* Perform Byte access to RCC_CIR[14:8] bits to disable the selected interrupts */
;;;1662       *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000004  7811              LDRB     r1,[r2,#0]
000006  d001              BEQ      |L30.12|
000008  4301              ORRS     r1,r1,r0              ;1657
00000a  e000              B        |L30.14|
                  |L30.12|
00000c  4381              BICS     r1,r1,r0
                  |L30.14|
00000e  7011              STRB     r1,[r2,#0]            ;1657
;;;1663     }
;;;1664   }
000010  4770              BX       lr
;;;1665   
                          ENDP

000012  0000              DCW      0x0000
                  |L30.20|
                          DCD      0x4002380d

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;352      */
;;;353    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  4905              LDR      r1,|L31.24|
;;;354    {
;;;355      /* Check the parameters */
;;;356      assert_param(IS_RCC_LSE(RCC_LSE));
;;;357    
;;;358      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;359      /* Reset LSEON bit */
;;;360      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  2200              MOVS     r2,#0
000004  700a              STRB     r2,[r1,#0]
;;;361    
;;;362      /* Reset LSEBYP bit */
;;;363      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000006  700a              STRB     r2,[r1,#0]
;;;364    
;;;365      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;366      switch (RCC_LSE)
000008  2801              CMP      r0,#1
00000a  d002              BEQ      |L31.18|
00000c  2804              CMP      r0,#4
00000e  d101              BNE      |L31.20|
;;;367      {
;;;368        case RCC_LSE_ON:
;;;369          /* Set LSEON bit */
;;;370          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
;;;371          break;
;;;372        case RCC_LSE_Bypass:
;;;373          /* Set LSEBYP and LSEON bits */
;;;374          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000010  2005              MOVS     r0,#5
                  |L31.18|
000012  7008              STRB     r0,[r1,#0]
                  |L31.20|
;;;375          break;
;;;376        default:
;;;377          break;
;;;378      }
;;;379    }
000014  4770              BX       lr
;;;380    
                          ENDP

000016  0000              DCW      0x0000
                  |L31.24|
                          DCD      0x40023870

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;392      */
;;;393    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L32.8|
;;;394    {
;;;395      /* Check the parameters */
;;;396      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;397    
;;;398      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;399    }
000004  4770              BX       lr
;;;400    
                          ENDP

000006  0000              DCW      0x0000
                  |L32.8|
                          DCD      0x42470e80

                          AREA ||i.RCC_MCO1Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO1Config PROC
;;;542      */
;;;543    void RCC_MCO1Config(uint32_t RCC_MCO1Source, uint32_t RCC_MCO1Div)
000000  4b03              LDR      r3,|L33.16|
;;;544    {
;;;545      uint32_t tmpreg = 0;
;;;546      
;;;547      /* Check the parameters */
;;;548      assert_param(IS_RCC_MCO1SOURCE(RCC_MCO1Source));
;;;549      assert_param(IS_RCC_MCO1DIV(RCC_MCO1Div));  
;;;550    
;;;551      tmpreg = RCC->CFGR;
000002  681a              LDR      r2,[r3,#0]
;;;552    
;;;553      /* Clear MCO1[1:0] and MCO1PRE[2:0] bits */
;;;554      tmpreg &= CFGR_MCO1_RESET_MASK;
;;;555    
;;;556      /* Select MCO1 clock source and prescaler */
;;;557      tmpreg |= RCC_MCO1Source | RCC_MCO1Div;
000004  4308              ORRS     r0,r0,r1
000006  f02262ec          BIC      r2,r2,#0x7600000      ;554
00000a  4310              ORRS     r0,r0,r2
;;;558    
;;;559      /* Store the new value */
;;;560      RCC->CFGR = tmpreg;  
00000c  6018              STR      r0,[r3,#0]
;;;561    }
00000e  4770              BX       lr
;;;562    
                          ENDP

                  |L33.16|
                          DCD      0x40023808

                          AREA ||i.RCC_MCO2Config||, CODE, READONLY, ALIGN=2

                  RCC_MCO2Config PROC
;;;580      */
;;;581    void RCC_MCO2Config(uint32_t RCC_MCO2Source, uint32_t RCC_MCO2Div)
000000  4b03              LDR      r3,|L34.16|
;;;582    {
;;;583      uint32_t tmpreg = 0;
;;;584      
;;;585      /* Check the parameters */
;;;586      assert_param(IS_RCC_MCO2SOURCE(RCC_MCO2Source));
;;;587      assert_param(IS_RCC_MCO2DIV(RCC_MCO2Div));
;;;588      
;;;589      tmpreg = RCC->CFGR;
000002  681a              LDR      r2,[r3,#0]
;;;590      
;;;591      /* Clear MCO2 and MCO2PRE[2:0] bits */
;;;592      tmpreg &= CFGR_MCO2_RESET_MASK;
;;;593    
;;;594      /* Select MCO2 clock source and prescaler */
;;;595      tmpreg |= RCC_MCO2Source | RCC_MCO2Div;
000004  4308              ORRS     r0,r0,r1
000006  f0224278          BIC      r2,r2,#0xf8000000     ;592
00000a  4310              ORRS     r0,r0,r2
;;;596    
;;;597      /* Store the new value */
;;;598      RCC->CFGR = tmpreg;  
00000c  6018              STR      r0,[r3,#0]
;;;599    }
00000e  4770              BX       lr
;;;600    
                          ENDP

                  |L34.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;771      */
;;;772    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4a03              LDR      r2,|L35.16|
;;;773    {
;;;774      uint32_t tmpreg = 0;
;;;775    
;;;776      /* Check the parameters */
;;;777      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;778    
;;;779      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;780    
;;;781      /* Clear PPRE1[2:0] bits */
;;;782      tmpreg &= ~RCC_CFGR_PPRE1;
000004  f42151e0          BIC      r1,r1,#0x1c00
;;;783    
;;;784      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;785      tmpreg |= RCC_HCLK;
000008  4301              ORRS     r1,r1,r0
;;;786    
;;;787      /* Store the new value */
;;;788      RCC->CFGR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;789    }
00000c  4770              BX       lr
;;;790    
                          ENDP

00000e  0000              DCW      0x0000
                  |L35.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;802      */
;;;803    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4a03              LDR      r2,|L36.16|
;;;804    {
;;;805      uint32_t tmpreg = 0;
;;;806    
;;;807      /* Check the parameters */
;;;808      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;809    
;;;810      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;811    
;;;812      /* Clear PPRE2[2:0] bits */
;;;813      tmpreg &= ~RCC_CFGR_PPRE2;
000004  f4214160          BIC      r1,r1,#0xe000
;;;814    
;;;815      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;816      tmpreg |= RCC_HCLK << 3;
000008  ea4100c0          ORR      r0,r1,r0,LSL #3
;;;817    
;;;818      /* Store the new value */
;;;819      RCC->CFGR = tmpreg;
00000c  6010              STR      r0,[r2,#0]
;;;820    }
00000e  4770              BX       lr
;;;821    
                          ENDP

                  |L36.16|
                          DCD      0x40023808

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;458      */
;;;459    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L37.8|
;;;460    {
;;;461      /* Check the parameters */
;;;462      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;463      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;464    }
000004  4770              BX       lr
;;;465    
                          ENDP

000006  0000              DCW      0x0000
                  |L37.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;435      */
;;;436    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t PLLM, uint32_t PLLN, uint32_t PLLP, uint32_t PLLQ)
000000  ea411182          ORR      r1,r1,r2,LSL #6
;;;437    {
;;;438      /* Check the parameters */
;;;439      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;440      assert_param(IS_RCC_PLLM_VALUE(PLLM));
;;;441      assert_param(IS_RCC_PLLN_VALUE(PLLN));
;;;442      assert_param(IS_RCC_PLLP_VALUE(PLLP));
;;;443      assert_param(IS_RCC_PLLQ_VALUE(PLLQ));
;;;444    
;;;445      RCC->PLLCFGR = PLLM | (PLLN << 6) | (((PLLP >> 1) -1) << 16) | (RCC_PLLSource) |
000004  085a              LSRS     r2,r3,#1
000006  b510              PUSH     {r4,lr}               ;437
000008  4b05              LDR      r3,|L38.32|
00000a  9c02              LDR      r4,[sp,#8]
00000c  eb034202          ADD      r2,r3,r2,LSL #16
000010  4311              ORRS     r1,r1,r2
000012  4301              ORRS     r1,r1,r0
000014  ea416004          ORR      r0,r1,r4,LSL #24
000018  4902              LDR      r1,|L38.36|
00001a  6008              STR      r0,[r1,#0]
;;;446                     (PLLQ << 24);
;;;447    }
00001c  bd10              POP      {r4,pc}
;;;448    
                          ENDP

00001e  0000              DCW      0x0000
                  |L38.32|
                          DCD      0xffff0000
                  |L38.36|
                          DCD      0x40023804

                          AREA ||i.RCC_PLLI2SCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SCmd PROC
;;;499      */
;;;500    void RCC_PLLI2SCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L39.8|
;;;501    {
;;;502      /* Check the parameters */
;;;503      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;504      *(__IO uint32_t *) CR_PLLI2SON_BB = (uint32_t)NewState;
000002  6688              STR      r0,[r1,#0x68]
;;;505    }
000004  4770              BX       lr
;;;506    
                          ENDP

000006  0000              DCW      0x0000
                  |L39.8|
                          DCD      0x42470000

                          AREA ||i.RCC_PLLI2SConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLI2SConfig PROC
;;;484      */
;;;485    void RCC_PLLI2SConfig(uint32_t PLLI2SN, uint32_t PLLI2SR)
000000  0180              LSLS     r0,r0,#6
;;;486    {
;;;487      /* Check the parameters */
;;;488      assert_param(IS_RCC_PLLI2SN_VALUE(PLLI2SN));
;;;489      assert_param(IS_RCC_PLLI2SR_VALUE(PLLI2SR));
;;;490    
;;;491      RCC->PLLI2SCFGR = (PLLI2SN << 6) | (PLLI2SR << 28);
000002  ea407001          ORR      r0,r0,r1,LSL #28
000006  4901              LDR      r1,|L40.12|
000008  6008              STR      r0,[r1,#0]
;;;492    }
00000a  4770              BX       lr
;;;493    
                          ENDP

                  |L40.12|
                          DCD      0x40023884

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;1011     */
;;;1012   void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L41.8|
;;;1013   {
;;;1014     /* Check the parameters */
;;;1015     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1016   
;;;1017     *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1018   }
000004  4770              BX       lr
;;;1019   
                          ENDP

000006  0000              DCW      0x0000
                  |L41.8|
                          DCD      0x42470e3c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;979      */
;;;980    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  f3c02101          UBFX     r1,r0,#8,#2
;;;981    {
;;;982      uint32_t tmpreg = 0;
;;;983    
;;;984      /* Check the parameters */
;;;985      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;986    
;;;987      if ((RCC_RTCCLKSource & 0x00000300) == 0x00000300)
000004  2903              CMP      r1,#3
000006  d107              BNE      |L42.24|
;;;988      { /* If HSE is selected as RTC clock source, configure HSE division factor for RTC clock */
;;;989        tmpreg = RCC->CFGR;
000008  4b07              LDR      r3,|L42.40|
00000a  6819              LDR      r1,[r3,#0]
;;;990    
;;;991        /* Clear RTCPRE[4:0] bits */
;;;992        tmpreg &= ~RCC_CFGR_RTCPRE;
;;;993    
;;;994        /* Configure HSE division factor for RTC clock */
;;;995        tmpreg |= (RCC_RTCCLKSource & 0xFFFFCFF);
00000c  4a07              LDR      r2,|L42.44|
00000e  f42111f8          BIC      r1,r1,#0x1f0000       ;992
000012  4002              ANDS     r2,r2,r0
000014  430a              ORRS     r2,r2,r1
;;;996    
;;;997        /* Store the new value */
;;;998        RCC->CFGR = tmpreg;
000016  601a              STR      r2,[r3,#0]
                  |L42.24|
;;;999      }
;;;1000       
;;;1001     /* Select the RTC clock source */
;;;1002     RCC->BDCR |= (RCC_RTCCLKSource & 0x00000FFF);
000018  4903              LDR      r1,|L42.40|
00001a  3168              ADDS     r1,r1,#0x68
00001c  680a              LDR      r2,[r1,#0]
00001e  f3c0000b          UBFX     r0,r0,#0,#12
000022  4302              ORRS     r2,r2,r0
000024  600a              STR      r2,[r1,#0]
;;;1003   }
000026  4770              BX       lr
;;;1004   
                          ENDP

                  |L42.40|
                          DCD      0x40023808
                  |L42.44|
                          DCD      0x0ffffcff

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;686      */
;;;687    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4a03              LDR      r2,|L43.16|
;;;688    {
;;;689      uint32_t tmpreg = 0;
;;;690    
;;;691      /* Check the parameters */
;;;692      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;693    
;;;694      tmpreg = RCC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;695    
;;;696      /* Clear SW[1:0] bits */
;;;697      tmpreg &= ~RCC_CFGR_SW;
000004  f0210103          BIC      r1,r1,#3
;;;698    
;;;699      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;700      tmpreg |= RCC_SYSCLKSource;
000008  4301              ORRS     r1,r1,r0
;;;701    
;;;702      /* Store the new value */
;;;703      RCC->CFGR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;704    }
00000c  4770              BX       lr
;;;705    
                          ENDP

00000e  0000              DCW      0x0000
                  |L43.16|
                          DCD      0x40023808

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;260      */
;;;261    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b518              PUSH     {r3,r4,lr}
;;;262    {
;;;263      __IO uint32_t startupcounter = 0;
000002  2000              MOVS     r0,#0
;;;264      ErrorStatus status = ERROR;
;;;265      FlagStatus hsestatus = RESET;
;;;266      /* Wait till HSE is ready and if Time out is reached exit */
;;;267      do
;;;268      {
;;;269        hsestatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;270        startupcounter++;
;;;271      } while((startupcounter != HSE_STARTUP_TIMEOUT) && (hsestatus == RESET));
000004  f44f64a0          MOV      r4,#0x500
000008  9000              STR      r0,[sp,#0]
                  |L44.10|
00000a  2031              MOVS     r0,#0x31              ;269
00000c  f7fffffe          BL       RCC_GetFlagStatus
000010  9900              LDR      r1,[sp,#0]            ;270
000012  1c49              ADDS     r1,r1,#1              ;270
000014  9100              STR      r1,[sp,#0]
000016  42a1              CMP      r1,r4
000018  d001              BEQ      |L44.30|
00001a  2800              CMP      r0,#0
00001c  d0f5              BEQ      |L44.10|
                  |L44.30|
;;;272    
;;;273      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
00001e  2031              MOVS     r0,#0x31
000020  f7fffffe          BL       RCC_GetFlagStatus
000024  2800              CMP      r0,#0
000026  d000              BEQ      |L44.42|
;;;274      {
;;;275        status = SUCCESS;
000028  2001              MOVS     r0,#1
                  |L44.42|
;;;276      }
;;;277      else
;;;278      {
;;;279        status = ERROR;
;;;280      }
;;;281      return (status);
;;;282    }
00002a  bd18              POP      {r3,r4,pc}
;;;283    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  APBAHBPrescTable
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  01020304          DCB      0x01,0x02,0x03,0x04
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "Libraries\\CMSIS\\stm32f4xx_rcc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___15_stm32f4xx_rcc_c_49e27980____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f4xx_rcc_c_49e27980____REVSH|
#line 128
|__asm___15_stm32f4xx_rcc_c_49e27980____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
