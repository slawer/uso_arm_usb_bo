; generated by ARM C/C++ Compiler, 5.03 [Build 24]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\MEDIA_USB_KEY\usbh_ioreq.o --asm_dir=.\listing\ --list_dir=.\listing\ --depend=.\MEDIA_USB_KEY\usbh_ioreq.d --cpu=Cortex-M4 --apcs=interwork -I.\Libraries -I.\Utilities -I.\Libraries\CMSIS\ST\STM32F4xx\Include -I.\inc -I.\src -I.\Libraries\STM32F4xx_StdPeriph_Driver -I.\Libraries\STM32_USB_HOST_Library -I.\Libraries\STM32_USB_OTG_Driver -I.\Utilities\STM32F4-Discovery -I.\Libraries\CMSIS -I.\Utilities\Third_Party\fat_fs -IC:\Keil4\ARM\RV31\INC -IC:\Keil4\ARM\CMSIS\Include -IC:\Keil4\ARM\Inc\ST\STM32F4xx -D__MICROLIB -DUSE_STDPERIPH_DRIVER -DUSE_USB_OTG_FS -DSTM32F4XX -DMEDIA_USB_KEY -D__FPU_PRESENT=0 --omf_browse=.\MEDIA_USB_KEY\usbh_ioreq.crf Libraries\STM32_USB_HOST_Library\usbh_ioreq.c]
                          THUMB

                          AREA ||i.USBH_BulkReceiveData||, CODE, READONLY, ALIGN=1

                  USBH_BulkReceiveData PROC
;;;274      */
;;;275    USBH_Status USBH_BulkReceiveData( USB_OTG_CORE_HANDLE *pdev, 
000000  b570              PUSH     {r4-r6,lr}
;;;276                                    uint8_t *buff, 
;;;277                                    uint16_t length,
;;;278                                    uint8_t hc_num)
;;;279    {
000002  460c              MOV      r4,r1
;;;280      pdev->host.hc[hc_num].ep_is_in = 1;   
000004  eb001143          ADD      r1,r0,r3,LSL #5
000008  2501              MOVS     r5,#1
00000a  f88152ae          STRB     r5,[r1,#0x2ae]
00000e  e9c142ae          STRD     r4,r2,[r1,#0x2b8]
;;;281      pdev->host.hc[hc_num].xfer_buff = buff;
;;;282      pdev->host.hc[hc_num].xfer_len = length;
;;;283      
;;;284    
;;;285      if( pdev->host.hc[hc_num].toggle_in == 0)
000012  f89122c4          LDRB     r2,[r1,#0x2c4]
000016  b102              CBZ      r2,|L1.26|
;;;286      {
;;;287        pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
;;;288      }
;;;289      else
;;;290      {
;;;291        pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
000018  2202              MOVS     r2,#2
                  |L1.26|
00001a  f88122b4          STRB     r2,[r1,#0x2b4]
;;;292      }
;;;293    
;;;294      HCD_SubmitRequest (pdev , hc_num);  
00001e  4619              MOV      r1,r3
000020  f7fffffe          BL       HCD_SubmitRequest
;;;295      return USBH_OK;
000024  2000              MOVS     r0,#0
;;;296    }
000026  bd70              POP      {r4-r6,pc}
;;;297    
                          ENDP


                          AREA ||i.USBH_BulkSendData||, CODE, READONLY, ALIGN=1

                  USBH_BulkSendData PROC
;;;241      */
;;;242    USBH_Status USBH_BulkSendData ( USB_OTG_CORE_HANDLE *pdev, 
000000  b570              PUSH     {r4-r6,lr}
;;;243                                    uint8_t *buff, 
;;;244                                    uint16_t length,
;;;245                                    uint8_t hc_num)
;;;246    { 
;;;247      pdev->host.hc[hc_num].ep_is_in = 0;
000002  eb001443          ADD      r4,r0,r3,LSL #5
000006  2500              MOVS     r5,#0
000008  f88452ae          STRB     r5,[r4,#0x2ae]
00000c  e9c412ae          STRD     r1,r2,[r4,#0x2b8]
;;;248      pdev->host.hc[hc_num].xfer_buff = buff;
;;;249      pdev->host.hc[hc_num].xfer_len = length;  
;;;250    
;;;251     /* Set the Data Toggle bit as per the Flag */
;;;252      if ( pdev->host.hc[hc_num].toggle_out == 0)
000010  f89412c5          LDRB     r1,[r4,#0x2c5]
000014  b139              CBZ      r1,|L2.38|
;;;253      { /* Put the PID 0 */
;;;254          pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;    
;;;255      }
;;;256     else
;;;257     { /* Put the PID 1 */
;;;258          pdev->host.hc[hc_num].data_pid = HC_PID_DATA1 ;
000016  2102              MOVS     r1,#2
000018  f88412b4          STRB     r1,[r4,#0x2b4]
                  |L2.28|
;;;259     }
;;;260    
;;;261      HCD_SubmitRequest (pdev , hc_num);   
00001c  4619              MOV      r1,r3
00001e  f7fffffe          BL       HCD_SubmitRequest
;;;262      return USBH_OK;
000022  2000              MOVS     r0,#0
;;;263    }
000024  bd70              POP      {r4-r6,pc}
                  |L2.38|
000026  f88452b4          STRB     r5,[r4,#0x2b4]        ;254
00002a  e7f7              B        |L2.28|
;;;264    
                          ENDP


                          AREA ||i.USBH_CtlReceiveData||, CODE, READONLY, ALIGN=1

                  USBH_CtlReceiveData PROC
;;;214      */
;;;215    USBH_Status USBH_CtlReceiveData(USB_OTG_CORE_HANDLE *pdev, 
000000  b570              PUSH     {r4-r6,lr}
;;;216                                    uint8_t* buff, 
;;;217                                    uint8_t length,
;;;218                                    uint8_t hc_num)
;;;219    {
000002  460c              MOV      r4,r1
;;;220    
;;;221      pdev->host.hc[hc_num].ep_is_in = 1;
000004  eb001143          ADD      r1,r0,r3,LSL #5
000008  f501712c          ADD      r1,r1,#0x2b0
00000c  2501              MOVS     r5,#1
00000e  f8015c02          STRB     r5,[r1,#-2]
;;;222      pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
000012  2502              MOVS     r5,#2
000014  710d              STRB     r5,[r1,#4]
000016  e9c14202          STRD     r4,r2,[r1,#8]
;;;223      pdev->host.hc[hc_num].xfer_buff = buff;
;;;224      pdev->host.hc[hc_num].xfer_len = length;  
;;;225    
;;;226      HCD_SubmitRequest (pdev , hc_num);   
00001a  4619              MOV      r1,r3
00001c  f7fffffe          BL       HCD_SubmitRequest
;;;227      
;;;228      return USBH_OK;
000020  2000              MOVS     r0,#0
;;;229      
;;;230    }
000022  bd70              POP      {r4-r6,pc}
;;;231    
                          ENDP


                          AREA ||i.USBH_CtlReq||, CODE, READONLY, ALIGN=1

                  USBH_CtlReq PROC
;;;98       */
;;;99     USBH_Status USBH_CtlReq     (USB_OTG_CORE_HANDLE *pdev, 
000000  b570              PUSH     {r4-r6,lr}
;;;100                                 USBH_HOST           *phost, 
;;;101                                 uint8_t             *buff,
;;;102                                 uint16_t            length)
;;;103    {
000002  460c              MOV      r4,r1
000004  461d              MOV      r5,r3
000006  4616              MOV      r6,r2
;;;104      USBH_Status status;
;;;105      URB_STATE URB_Status = URB_IDLE;
;;;106      
;;;107      URB_Status = HCD_GetURB_State(pdev, phost->Control.hc_num_out); 
000008  7949              LDRB     r1,[r1,#5]
00000a  f7fffffe          BL       HCD_GetURB_State
00000e  4601              MOV      r1,r0
;;;108      
;;;109      status = USBH_BUSY;
000010  2001              MOVS     r0,#1
;;;110      
;;;111      switch (phost->RequestState)
000012  78e2              LDRB     r2,[r4,#3]
000014  4603              MOV      r3,r0                 ;109
000016  2a01              CMP      r2,#1
000018  d00a              BEQ      |L4.48|
00001a  2a02              CMP      r2,#2
00001c  d107              BNE      |L4.46|
;;;112      {
;;;113      case CMD_SEND:
;;;114        /* Start a SETUP transfer */
;;;115        USBH_SubmitSetupRequest(phost, buff, length);
;;;116        phost->RequestState = CMD_WAIT;
;;;117        status = USBH_BUSY;
;;;118        break;
;;;119        
;;;120      case CMD_WAIT:
;;;121        if  (URB_Status == URB_DONE)
00001e  2901              CMP      r1,#1
000020  d010              BEQ      |L4.68|
;;;122        {
;;;123          /* Commands successfully sent and Response Received  */       
;;;124          phost->RequestState = CMD_SEND;
;;;125          status = USBH_OK;
;;;126        }
;;;127        else if  (URB_Status == URB_ERROR)
000022  2903              CMP      r1,#3
000024  d011              BEQ      |L4.74|
;;;128        {
;;;129          /* Failure Mode */
;;;130          phost->RequestState = CMD_SEND;
;;;131          status = USBH_FAIL;
;;;132        }   
;;;133         else if  (URB_Status == URB_STALL)
000026  2904              CMP      r1,#4
000028  d101              BNE      |L4.46|
;;;134        {
;;;135          /* Commands successfully sent and Response Received  */       
;;;136          phost->RequestState = CMD_SEND;
00002a  70e3              STRB     r3,[r4,#3]
;;;137          status = USBH_NOT_SUPPORTED;
00002c  2003              MOVS     r0,#3
                  |L4.46|
;;;138        }
;;;139        break;
;;;140        
;;;141      default:
;;;142        break; 
;;;143      }
;;;144      return status;
;;;145    }
00002e  bd70              POP      {r4-r6,pc}
                  |L4.48|
000030  7821              LDRB     r1,[r4,#0]
000032  7061              STRB     r1,[r4,#1]
000034  2109              MOVS     r1,#9
000036  7021              STRB     r1,[r4,#0]
000038  60a6              STR      r6,[r4,#8]
00003a  81a5              STRH     r5,[r4,#0xc]
00003c  7723              STRB     r3,[r4,#0x1c]
00003e  2102              MOVS     r1,#2                 ;116
000040  70e1              STRB     r1,[r4,#3]            ;116
000042  bd70              POP      {r4-r6,pc}
                  |L4.68|
000044  70e3              STRB     r3,[r4,#3]            ;124
000046  2000              MOVS     r0,#0                 ;125
000048  bd70              POP      {r4-r6,pc}
                  |L4.74|
00004a  70e3              STRB     r3,[r4,#3]            ;130
00004c  2002              MOVS     r0,#2                 ;131
00004e  bd70              POP      {r4-r6,pc}
;;;146    
                          ENDP


                          AREA ||i.USBH_CtlSendData||, CODE, READONLY, ALIGN=1

                  USBH_CtlSendData PROC
;;;175      */
;;;176    USBH_Status USBH_CtlSendData ( USB_OTG_CORE_HANDLE *pdev, 
000000  b570              PUSH     {r4-r6,lr}
;;;177                                    uint8_t *buff, 
;;;178                                    uint8_t length,
;;;179                                    uint8_t hc_num)
;;;180    {
;;;181      pdev->host.hc[hc_num].ep_is_in = 0;
000002  eb001443          ADD      r4,r0,r3,LSL #5
000006  2500              MOVS     r5,#0
000008  f88452ae          STRB     r5,[r4,#0x2ae]
00000c  e9c412ae          STRD     r1,r2,[r4,#0x2b8]
000010  b11a              CBZ      r2,|L5.26|
;;;182      pdev->host.hc[hc_num].xfer_buff = buff;
;;;183      pdev->host.hc[hc_num].xfer_len = length;
;;;184     
;;;185      if ( length == 0 )
;;;186      { /* For Status OUT stage, Length==0, Status Out PID = 1 */
;;;187        pdev->host.hc[hc_num].toggle_out = 1;   
;;;188      }
;;;189     
;;;190     /* Set the Data Toggle bit as per the Flag */
;;;191      if ( pdev->host.hc[hc_num].toggle_out == 0)
000012  f89412c5          LDRB     r1,[r4,#0x2c5]
000016  b159              CBZ      r1,|L5.48|
000018  e002              B        |L5.32|
                  |L5.26|
00001a  2101              MOVS     r1,#1                 ;187
00001c  f88412c5          STRB     r1,[r4,#0x2c5]        ;187
                  |L5.32|
;;;192      { /* Put the PID 0 */
;;;193          pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;    
;;;194      }
;;;195     else
;;;196     { /* Put the PID 1 */
;;;197          pdev->host.hc[hc_num].data_pid = HC_PID_DATA1 ;
000020  2102              MOVS     r1,#2
000022  f88412b4          STRB     r1,[r4,#0x2b4]
                  |L5.38|
;;;198     }
;;;199    
;;;200      HCD_SubmitRequest (pdev , hc_num);   
000026  4619              MOV      r1,r3
000028  f7fffffe          BL       HCD_SubmitRequest
;;;201       
;;;202      return USBH_OK;
00002c  2000              MOVS     r0,#0
;;;203    }
00002e  bd70              POP      {r4-r6,pc}
                  |L5.48|
000030  f88452b4          STRB     r5,[r4,#0x2b4]        ;193
000034  e7f7              B        |L5.38|
;;;204    
                          ENDP


                          AREA ||i.USBH_CtlSendSetup||, CODE, READONLY, ALIGN=1

                  USBH_CtlSendSetup PROC
;;;154      */
;;;155    USBH_Status USBH_CtlSendSetup ( USB_OTG_CORE_HANDLE *pdev, 
000000  460b              MOV      r3,r1
;;;156                                    uint8_t *buff, 
;;;157                                    uint8_t hc_num){
000002  b510              PUSH     {r4,lr}
;;;158      pdev->host.hc[hc_num].ep_is_in = 0;
000004  eb001142          ADD      r1,r0,r2,LSL #5
000008  f501712c          ADD      r1,r1,#0x2b0
00000c  2400              MOVS     r4,#0
00000e  f8014c02          STRB     r4,[r1,#-2]
;;;159      pdev->host.hc[hc_num].data_pid = HC_PID_SETUP;   
000012  2403              MOVS     r4,#3
000014  710c              STRB     r4,[r1,#4]
;;;160      pdev->host.hc[hc_num].xfer_buff = buff;
;;;161      pdev->host.hc[hc_num].xfer_len = USBH_SETUP_PKT_SIZE;   
000016  608b              STR      r3,[r1,#8]
000018  2308              MOVS     r3,#8
;;;162    
;;;163      return (USBH_Status)HCD_SubmitRequest (pdev , hc_num);   
00001a  60cb              STR      r3,[r1,#0xc]
00001c  4611              MOV      r1,r2
00001e  f7fffffe          BL       HCD_SubmitRequest
000022  b2c0              UXTB     r0,r0
;;;164    }
000024  bd10              POP      {r4,pc}
;;;165    
                          ENDP


                          AREA ||i.USBH_InterruptReceiveData||, CODE, READONLY, ALIGN=1

                  USBH_InterruptReceiveData PROC
;;;307      */
;;;308    USBH_Status USBH_InterruptReceiveData( USB_OTG_CORE_HANDLE *pdev, 
000000  b570              PUSH     {r4-r6,lr}
;;;309                                    uint8_t *buff, 
;;;310                                    uint8_t length,
;;;311                                    uint8_t hc_num)
;;;312    {
000002  460c              MOV      r4,r1
;;;313    
;;;314      pdev->host.hc[hc_num].ep_is_in = 1;  
000004  eb001143          ADD      r1,r0,r3,LSL #5
000008  2501              MOVS     r5,#1
00000a  f88152ae          STRB     r5,[r1,#0x2ae]
00000e  e9c142ae          STRD     r4,r2,[r1,#0x2b8]
;;;315      pdev->host.hc[hc_num].xfer_buff = buff;
;;;316      pdev->host.hc[hc_num].xfer_len = length;
;;;317      
;;;318    
;;;319      
;;;320      if(pdev->host.hc[hc_num].toggle_in == 0)
000012  f89122c4          LDRB     r2,[r1,#0x2c4]
000016  b15a              CBZ      r2,|L7.48|
;;;321      {
;;;322        pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
;;;323      }
;;;324      else
;;;325      {
;;;326        pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
000018  2402              MOVS     r4,#2
                  |L7.26|
00001a  f88142b4          STRB     r4,[r1,#0x2b4]
;;;327      }
;;;328    
;;;329      /* toggle DATA PID */
;;;330      pdev->host.hc[hc_num].toggle_in ^= 1;  
00001e  f0820201          EOR      r2,r2,#1
000022  f88122c4          STRB     r2,[r1,#0x2c4]
;;;331      
;;;332      HCD_SubmitRequest (pdev , hc_num);  
000026  4619              MOV      r1,r3
000028  f7fffffe          BL       HCD_SubmitRequest
;;;333      
;;;334      return USBH_OK;
00002c  2000              MOVS     r0,#0
;;;335    }
00002e  bd70              POP      {r4-r6,pc}
                  |L7.48|
000030  2400              MOVS     r4,#0                 ;322
000032  e7f2              B        |L7.26|
;;;336    
                          ENDP


                          AREA ||i.USBH_InterruptSendData||, CODE, READONLY, ALIGN=1

                  USBH_InterruptSendData PROC
;;;345      */
;;;346    USBH_Status USBH_InterruptSendData( USB_OTG_CORE_HANDLE *pdev, 
000000  b570              PUSH     {r4-r6,lr}
;;;347                                    uint8_t *buff, 
;;;348                                    uint8_t length,
;;;349                                    uint8_t hc_num)
;;;350    {
000002  460d              MOV      r5,r1
;;;351    
;;;352      pdev->host.hc[hc_num].ep_is_in = 0;  
000004  eb001443          ADD      r4,r0,r3,LSL #5
000008  2100              MOVS     r1,#0
00000a  f88412ae          STRB     r1,[r4,#0x2ae]
00000e  e9c452ae          STRD     r5,r2,[r4,#0x2b8]
;;;353      pdev->host.hc[hc_num].xfer_buff = buff;
;;;354      pdev->host.hc[hc_num].xfer_len = length;
;;;355      
;;;356      if(pdev->host.hc[hc_num].toggle_in == 0)
000012  f89422c4          LDRB     r2,[r4,#0x2c4]
000016  b102              CBZ      r2,|L8.26|
;;;357      {
;;;358        pdev->host.hc[hc_num].data_pid = HC_PID_DATA0;
;;;359      }
;;;360      else
;;;361      {
;;;362        pdev->host.hc[hc_num].data_pid = HC_PID_DATA1;
000018  2102              MOVS     r1,#2
                  |L8.26|
00001a  f88412b4          STRB     r1,[r4,#0x2b4]        ;358
;;;363      }
;;;364    
;;;365      pdev->host.hc[hc_num].toggle_in ^= 1;  
00001e  f0820101          EOR      r1,r2,#1
000022  f88412c4          STRB     r1,[r4,#0x2c4]
;;;366      
;;;367      HCD_SubmitRequest (pdev , hc_num);  
000026  4619              MOV      r1,r3
000028  f7fffffe          BL       HCD_SubmitRequest
;;;368      
;;;369      return USBH_OK;
00002c  2000              MOVS     r0,#0
;;;370    }
00002e  bd70              POP      {r4-r6,pc}
;;;371    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Libraries\\STM32_USB_HOST_Library\\usbh_ioreq.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_usbh_ioreq_c_4b12c4a6____REV16|
#line 114 ".\\Libraries\\CMSIS\\core_cmInstr.h"
|__asm___12_usbh_ioreq_c_4b12c4a6____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___12_usbh_ioreq_c_4b12c4a6____REVSH|
#line 128
|__asm___12_usbh_ioreq_c_4b12c4a6____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
