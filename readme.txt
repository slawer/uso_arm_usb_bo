

если нет таблицы калибровки пишется на флешку 3276,8 почему то


прибавляются по 100 раз в секунду:

butt_menu_vkl	-	conf.tm_antidreb   сравнивается 10 раз в секунду
butt_menu_vikl	-	conf.tm_antidreb   сравнивается 10 раз в секунду

switch_key_vkl	-	conf.tm_antidreb   сравнивается 10 раз в секунду
switch_key_vikl	-	conf.tm_antidreb   сравнивается 10 раз в секунду

kol_pribl_vikl	-	conf.tm_antidreb
kol_pribl_vkl	-	conf.tm_antidreb

kol_gr1_vkl		-	conf.tm_antidreb
kol_gr2_vkl		-	conf.tm_antidreb


10 раз в секунду
tek_kol_dmk
tek_kol
это переменные для усреднения

kol_rele_on
kol_rele_off


раз в секунду
time_max		-	conf.time_max

значения моментов в программе как бы умножено на 10 потому что в десятых


основной конфиг						мак значение в программе 
	u8 address;
	u8 ver_po_st;
	u8 ver_po_ml;
	u8 tek_gr_kal; 
	u8 tm_antidreb;					1..255  0,01-
	u8 revers_group_select;
	u8 revers_peredacha_select;
	u16	per_usr;
	u16	time_max;
	u16 por_rele;
	u16 tm_rele_on;
	u16 tm_rele_off;
	u16 rez16;

конфиг дмк
	u8 tm_antidreb;
	u16	per_usr;
	u16	time_max;
	u16 por_rele;
	u16 tm_rele_on;
	u16 tm_rele_off;
	u16 rez16;
	u8 revers_switch;
	u8 revers_menu;
	u16 lin_max;





i2c

Подтверждение

Таким образом передача 8 бит данных от передатчика к приемнику завершаются дополнительным циклом (формированием 9-го тактового импульса линии SCL), при котором приемник выставляет низкий уровень сигнала на линии SDA, как признак успешного приема байта.

Подтверждение при передаче данных обязательно, кроме случаев окончания передачи ведомой стороной. Соответствующий импульс синхронизации генерируется ведущим. Передатчик отпускает (ВЫСОКОЕ) линию SDA на время синхроимпульса подтверждения. Приёмник должен удерживать линию SDA в течение ВЫСОКОГО состояния синхроимпульса подтверждения в стабильном НИЗКОМ состоянии.

В том случае, когда ведомый-приёмник не может подтвердить свой адрес (например, когда он выполняет в данный момент какие-либо функции реального времени), линия данных должна быть оставлена в ВЫСОКОМ состоянии. После этого ведущий может выдать сигнал СТОП для прерывания пересылки данных. Если в пересылке участвует ведущий-приёмник, то он должен сообщить об окончании передачи ведомому-передатчику путем не подтверждения последнего байта. Ведомый-передатчик должен освободить линию данных для того, чтобы позволить ведущему выдать сигнал СТОП или повторить сигнал СТАРТ.


Для управления линиями применяются выходные каскады с открытым коллектором, поэтому линии шины должны быть подтянуты к источнику питания +5 В через резисторы сопротивлением 1...10 кОм

В начальный момент времени – в режиме ожидания – обе лини SCL и SDA находятся в состоянии лог. 1 (транзистор выходного каскада с открытым коллектором закрыт). В режиме передачи (рисунок 1) бит данных SDA стробируется положительным импульсом SCL. Смена информации на линии SDA производится при нулевом состоянии линии SCL. "Slave"-устройство может "придерживать" линию SCL в нулевом состоянии, например, на время обработки очередного принятого байта, при этом "Master"-устройство обязано дождаться освобождения линии SCL, прежде чем продолжать передачу информации. 

Каждый информационный байт (8 битов) содержит 9 тактовых периодов линии SCL.

При совершении операции чтения "Master" абонент должен сопровождать прочитанный байт сигналом ACK, если необходимо прочитать следующий байт, и не выдавать сигнал ACK, если собирается закончить чтение пакета (см. рисунок 3б). 

Сигнал окончания чтения – отсутствие подтверждения ведущим приёма последнего или единственного байта данных и следующая за этим команда "STOP". 

ипичная ошибка при реализации программ "Master"-абонента – управление значением порта МК для установки состояний лог. 0 и лог. 1 линий SCL и SDA. Если для МК семейства MCS-51 это нормальный режим работы, так как единичное состояние порта у них реализуется встроенным подтягивающим резистором, то для МК с симметричными портами (Motorola 68HCxx, Microchip PIC, Atmel AVR) это будет порождать электрические конфликты. Например, в руководстве "Microchip. Embedded Control Handbook 1994/1995" приведены практические программы для связи PIC c EEPROM 24Cxx, содержащие подобные грубые ошибки. Положение усугубляется ещё и тем, что в случае микросхем EEPROM такой вариант может сработать, так как они являются 100% аппаратными схемами и не вносят задержек в связной протокол, а паузу ожидания окончания цикла программирования производят переходом в пассивное состояние. Однако использование таких подпрограмм с микросхемами, производящими захват линии SCL (практически любой "Slave"-абонент, реализованный с применением МК), приведёт к невозможности связи, а возможно, и к выходу микросхемы из строя.

Реализовать настоящую имитацию режима "Открытый коллектор" (ОК) (мы назвали этот режим имитацией ОК, так как он не позволяет устанавливать на линии напряжение выше напряжения питания, что было бы нормально для настоящего ОК, но так как по спецификации I2C напряжение на линиях SCL и SDA не должно превышать напряжение питания, его вполне законно можно считать выходом с ОК) на порте с симметричным выходом можно, если установить значение порта постоянно в лог. 0, а управлять состоянием линии через манипуляции с регистром направления данных. Для МК семейства PIC это будет регистр "TRISx", переводящий порт либо в третье состояние, либо подключающий линии в соответствии с состоянием регистра "PORTx". Практически так же это реализуется в МК AVR и MC68HC05 (08, 11), где "DDRx" коммутирует порт "PORTx", с той лишь разницей, что у них другая полярность управляющего сигнала – у PIC лог. 0 в "TRISx" соответствует лог. 0 на выходе, а у AVR и MC68HC05 лог. 1 в "DDRx" соответствует лог. 0 на выходе.

Другая важная сторона вопроса – необходимость тщательного соблюдения параметров временной диаграммы процесса обмена. Несмотря на то, что шина I2C асинхронная и позволяет затягивать передачу бита (байта) на сколь угодно длительное время (это свойство позволяет реализовывать программы I2C-обмена на самом низком уровне приоритета, прерывая процесс передачи в любое время), требования к минимальным значениям длительностей импульсов очень жёсткие. Ситуация усугубляется тем, что положительные перепады состояния линии имеют склонность затягиваться, так как несимметричные управляющие выходы не могут создать крутые положительные фронты.

При написании программ очень важно контролировать время между операциями на шине, реализуемыми различными подпрограммами, например выдача "START" и "STOP"-условия, передача бита, передача байта. При состыковке этих подпрограмм не должны быть нарушены минимальные значения времени, что очень легко происходит при использовании высокоскоростных процессоров (AVR, PIC). Кроме того, необходимо следить, чтобы время между изменением на линии SDA и стробированием положительным импульсом на линии SCL было не меньше половины минимальной длительности полупериода SCL (2,4 мкс для скорости 100 кБит/сек). Помимо этого, некоторые "Slave"-приборы могут ужесточить требования к максимальной частоте обмена, в этом случае необходимо пропорционально снижению частоты обмена увеличивать значения минимумов временных допусков.

Ещё одна распространенная ошибка – игнорирование требования слежения за захватом линии SCL "Slave"-абонентом. Грамотно реализованные прграммы операций "Master"-абонента должны контролировать возврат линии SCL после того, как переводят её в единичное состояние, и только дождавшись реальной установки линии SCL в единичное состояние продолжать операции приемо-передачи. 



// про сохранение костант



адрес коробки
номер версии по
номер версии прибора
серийный номер

усреднение для ацп
настройка времени для определения максимума

группа калибровок 1
    калибр таблица 1
    калибр таблица 2
    
группа калибровок 2
    калибр таблица 1
    калибр таблица 2
номер группы текущей таблицы
реверс выбора группы и передачи


пороги реле, таймауты реле

настройка индикаторов
настройка 
 

AN2594 EEPROM emulation.
AN3969


заработала передача
когда из шлейфа 9 ножку посадил на PD3 который ==1
т.е. по схеме mod-rs485 DE=1
но при этом ~RE присоединенный на PD4, которая=0 не работает, а когда он висит в воздухе то работает!!

странна как та..
кварц внутренный при этом спешит так же на 3 сек в минуту

оказывается прием так же работает!!!

протокол выбираем слудующий (каждая цифра кодируется аски):
: ADR LEN kom n1 n2 n3 n4 n5 .. (enter)

1. установить время
: 01 10 vrem yy mm dd hh mm ss (enter)

2. записать калибровку первой передачи

3. записать калибровку второй передачи

4. установить адрес

5. установить порог

6. установить время для накопления максимума

7. рестарт

8. активный режим
: 01 10 aktiv on enter
3a30313130

9. тихий режим
: 01 10 silens enter
3a30313130

10. прочитать калибровку первой передачи

11. прочитать калибровку второй передачи

12. прочитать адрес

13. прочитать время

14. прочитать значение и время
: 1 10 read enter

15. прочитать порог

16. прочитать время для накопления максимума

17. прочитать всю конфигу
: 1 10 rd_conf enter

18. записать всю конфигу
: 1 10 wr_conf 1 2 3 4 5 6 7 8 9 .. enter


типы раюоты порта
GPIO_Mode_AIN                — аналоговый вход;
GPIO_Mode_IN_FLOATING  — цифровой  вход, третье состояние;
GPIO_Mode_IPD                — цифровой вход, подтяжка к земле;
GPIO_Mode_IPU                — цифровой вход, подтяжка к плюсу питания;
GPIO_Mode_Out_OD          — выход общего назначения, открытый сток;
GPIO_Mode_Out_PP           — симметричный выход общего назначения;
GPIO_Mode_AF_OD           -  выход альтернативной ф-ии, открытый сток;
GPIO_Mode_AF_PP            -  симметричный выход альтернативной ф-ии 